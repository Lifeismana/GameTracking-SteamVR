__gmon_start__
_init
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
QVariant::QVariant(int)
QVariant::QVariant(QByteArray const&)
QImage::color(int) const
operator delete(void*)
QImageIOHandler::~QImageIOHandler()
QArrayData::deallocate(QArrayData*, unsigned long, unsigned long)
QVariant::toByteArray() const
QVariant::toInt(bool*) const
memcmp
QByteArray::operator=(QByteArray const&)
QByteArray::QByteArray(char const*, int)
QImageIOHandler::QImageIOHandler()
operator new(unsigned long)
QIODevice::peek(long long)
QByteArray::startsWith(QByteArray const&) const
QArrayData::shared_null
QImageIOHandler::device() const
QImageIOHandler::setFormat(QByteArray const&) const
QImage::QImage()
QMessageLogger::debug(char const*, ...) const
operator new[](unsigned long)
operator delete[](void*)
malloc
QImage::scanLine(int)
free
QImage::operator=(QImage const&)
QImage::height() const
QImage::width() const
QImage::depth() const
QImage::allGray() const
QImage::hasAlphaChannel() const
QString::toLatin1_helper(QString const&)
qstrdup(char const*)
QIODevice::write(char const*, long long)
QString::append(QLatin1String)
QString::fromLatin1_helper(char const*, int)
QString::arg(double, int, char, int, QChar) const
QString::append(QString const&)
QString::toLocal8Bit_helper(QChar const*, int)
QImage::~QImage()
QIODevice::readAll()
QByteArray::reallocData(unsigned int, QFlags<QArrayData::AllocationOption>)
QImage::QImage(int, int, QImage::Format)
vtable for __cxxabiv1::__si_class_type_info
typeinfo for QImageIOHandler
QImageIOHandler::jumpToNextImage()
QImageIOHandler::jumpToImage(int)
QImageIOHandler::loopCount() const
QImageIOHandler::imageCount() const
QImageIOHandler::nextImageDelay() const
QImageIOHandler::currentImageNumber() const
QImageIOHandler::currentImageRect() const
__assert_fail
floor
ceil
memmove
abort
stderr
vfprintf
fputc
strcmp
strlen
__ctype_b_loc
qsort
fwrite
strrchr
realloc
memset
__isoc99_fscanf
fputs
strcat
memcpy
unlink
lseek
fclose
fseek
fread
open
tmpnam
vsprintf
strcpy
gettimeofday
strtol
strchr
strtod
strncpy
strtok
sqrt
fflush
ferror
getenv
__isoc99_sscanf
tmpfile
rewind
fgetc
QImageIOHandler::setDevice(QIODevice*)
QImageIOHandler::setFormat(QByteArray const&)
QObjectData::dynamicMetaObject() const
QImageIOPlugin::~QImageIOPlugin()
qstrcmp(QByteArray const&, char const*)
QIODevice::isOpen() const
QIODevice::isReadable() const
QIODevice::isWritable() const
QListData::dispose(QListData::Data*)
qt_plugin_query_metadata
qt_plugin_instance
QImageIOPlugin::QImageIOPlugin(QObject*)
QtSharedPointer::ExternalRefCountData::getAndRef(QObject const*)
__cxa_guard_acquire
__cxa_guard_release
__cxa_atexit
QListData::detach_grow(int*, int)
QListData::append()
QListData::shared_null
QListData::detach(int)
QImageIOPlugin::qt_metacast(char const*)
QImageIOPlugin::qt_metacall(QMetaObject::Call, int, void**)
typeinfo for QImageIOPlugin
QObject::event(QEvent*)
QObject::eventFilter(QObject*, QEvent*)
QObject::timerEvent(QTimerEvent*)
QObject::childEvent(QChildEvent*)
QObject::customEvent(QEvent*)
QObject::connectNotify(QMetaMethod const&)
QObject::disconnectNotify(QMetaMethod const&)
QImageIOPlugin::staticMetaObject
libQt5Gui.so.5
libQt5Core.so.5
libGL.so.1
libpthread.so.0
libstdc++.so.6
libm.so.6
libgcc_s.so.1
libc.so.6
_edata
__bss_start
_end
$ORIGIN/../../lib
GLIBC_2.2.5
GLIBC_2.3
GLIBC_2.7
CXXABI_1.3
GLIBCXX_3.4
default
mode=real
 rate=%1
JAS_CLRSPC_FAM_UNKNOWN
JAS_CLRSPC_FAM_XYZ
JAS_CLRSPC_FAM_LAB
JAS_CLRSPC_FAM_GRAY
JAS_CLRSPC_FAM_RGB
JAS_CLRSPC_FAM_YCBCR
Unknown
JAS_CLRSPC_CIEXYZ
JAS_CLRSPC_CIELAB
JAS_CLRSPC_SGRAY
JAS_CLRSPC_SRGB
JAS_CLRSPC_SYCBCR
JAS_CLRSPC_GENGRAY
JAS_CLRSPC_GENRGB
JAS_CLRSPC_GENYCBCR
Jasper Library initialization failed
Unable to handle color depth %d
Jpeg2000 decoder is not able to handle color space %s - %s
Jasper library can't decode Jpeg2000 image data
The Qt JPEG 2000 reader was unable to convert colorspace to RGB or grayscale
The Qt JPEG 2000 reader does not support images where component geometry differs from image geometry
The Qt JPEG 2000 reader does not support components with precision != 8
Qt JPEG 2000 reader does not support signed components
JPEG 2000 reader expected 1 or 2 components, got %d
JPEG 2000 reader missing a color component
\fjP  \r\n
11QJp2Handler
MbP?
Y@333333
?../../../3rdparty/jasper/src/libjasper/base/jas_cm.c
i >= 0 && i <= pxformseq->numpxforms
pxformseq->numpxforms < pxformseq->maxpxforms
prof->numchans == 3 && prof->numrefchans == 3
prof->refclrspc == (((1) << 8) | (1))
n >= 2
n >= pxformseq->numpxforms
bufmax > 0
prfprof
jas_cmxform_apply
jas_cmxform_create
jas_cmshapmatlut_invert
jas_cmpxformseq_resize
jas_cmpxformseq_insertpxform
jas_cmshapmat_apply
jas_cmprof_createsycc
%04x:
 %02x
unknown long option %s\n
unknown short option %s\n
missing argument for option %s\n
string = "%s"\n
ascii = "%s"\n
uclangcode = %d; uclen = %d\n
sccode = %d\n
maclen = %d\n
(%f, %f, %f)\n
e[%d][%d]=%f 
number of entires = %d\n
gamma = %f\n
entry[%d] = %f\n
maxents >= tab->numattrs
newprof->attrtab
attrval->ops->output
reloff >= 0
cannot get header\n
cannot get tab table\n
numattrs=%d\n
---\n
numinchans=%d, numoutchans=%d, clutlen=%d\n
numintabents=%d, numouttabents=%d\n
../../../3rdparty/jasper/src/libjasper/base/jas_icc.c
i >= 0 && i <= attrtab->numattrs
curoff == ((long) (tagtabent->off))
refcnt = %d; type = 0x%08x %s\n
attrno=%d; attrname="%s"(0x%08x); attrtype="%s"(0x%08x)\n
jas_iccprof_save
jas_iccattrtab_add
jas_iccattrtab_resize
jas_iccprof_copy
../../../3rdparty/jasper/src/libjasper/base/jas_image.c
cmptno >= 0 && cmptno <= image->numcmpts_
prec=%d, sgnd=%d, cmpttype=%d\n
cmptno >= 0 && cmptno < image->numcmpts_
oldcmpt->tlx_ == 0 && oldcmpt->tly_ == 0
oldx >= 0 && oldx < oldcmpt->width_ && oldy >= 0 && oldy < oldcmpt->height_
x >= 0
id >= 0 && name && ext && ops
 f(%d,%d)=%ld
inprof
!((outimage)->cmprof_)
incmptfmts
j >= 0
outcmptfmts
jas_image_chclrspc
uptomult
downtomult
jas_image_sampcmpt
jas_image_addcmpt
jas_image_addfmt
My Image Format (MIF)
Portable Graymap/Pixmap (PNM)
Microsoft Bitmap (BMP)
Sun Rasterfile (RAS)
JPEG (ISO/IEC 10918-1)
JPEG-2000 VM Format (PGX)
JPEG-2000 JP2 File Format Syntax (ISO/IEC 15444-1)
JPEG-2000 Code Stream Syntax (ISO/IEC 15444-1)
../../../3rdparty/jasper/src/libjasper/base/jas_seq.c
xstart <= xend && ystart <= yend
!(matrix->flags_ & 0x0001)
n >= 0
%d %d
%d %d\n
%s%4ld
jas_matrix_asr
jas_seq2d_copy
jas_matrix_destroy
jas_seq2d_create
../../../3rdparty/jasper/src/libjasper/base/jas_stream.c
(stream->bufmode_ & 0x0020) == 0
stream->ptr_ - stream->bufstart_ <= stream->bufsize_
stream->ptr_ - stream->bufbase_ <= stream->bufsize_ + 16
!((stream->bufmode_ & 0x0010) && (stream->bufmode_ & 0x0020))
newbufsize >= 0
m->buf_
ret == cnt
!stream->bufbase_
bufsize > 0
!(stream->bufmode_ & 0x0010)
stream->cnt_ > 0
%08x:
jas_stream_flushbuf
jas_stream_fillbuf
jas_stream_seek
jas_stream_gets
jas_stream_putc_func
jas_stream_getc_func
jas_stream_initbuf
mem_resize
mem_write
.A1.900.1
warning: ignoring BMP decoder options\n
THE BMP FORMAT IS NOT FULLY SUPPORTED!\nTHAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\nIF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\nTO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n
error: unsupported BMP encoding\n
error: possibly bad bitmap offset?\n
skipping unknown data in BMP file\n
../../../3rdparty/jasper/src/libjasper/bmp/bmp_dec.c
info->depth == 8 || info->depth == 24
unsupported BMP encoding\n
info->enctype == 0
cannot get info\n
bmp_getdata
../../../3rdparty/jasper/src/libjasper/bmp/bmp_enc.c
warning: ignoring BMP encoder options\n
error: BMP format does not support color space\n
error: missing color component\n
The BMP format cannot be used to represent an image with this geometry.\n
no palettized image support for BMP format\n
val >= 0
warning: inaccurate color\n
bmp_putint32
channo=%d; type=%d; assoc=%d\n
numchans = %d\n
cmptno=%d; map=%d; pcol=%d\n
numents=%d; numchans=%d\n
LUT[%d][%d]=%d\n
method=%d; pri=%d; approx=%d\n
csid=%d\n
JP2 box: 
cannot copy box data\n
cannot parse box data\n
FTYP
JP2H
IHDR
BPCC
COLR
PCLR
CMAP
CDEF
RESC
RESD
JP2C
JP2I
UUID
UINF
ULST
type=%c%s%c (0x%08x); length=%d\n
warning: cannot handle large 64-bit box length\n
error: cannot get box\n
incorrect magic number\n
expecting file type box\n
box type %s\n
error: missing IHDR box\n
error: no components\n
error: no COLR box\n
iccprof
ICC Profile CS %08x\n
dec->image->cmprof_
error: no memory\n
error: no code stream found\n
error: expecting signature box\n
error: cannot decode code stream\n
warning: number of components mismatch\n
warning: component data type mismatch\n
error: unsupported compression type\n
warning: superfluous BPCC box\n
../../../3rdparty/jasper/src/libjasper/jp2/jp2_dec.c
warning: missing PCLR box or superfluous CMAP box\n
warning: missing CMAP box or superfluous PCLR box\n
error: invalid component number in CMAP box\n
error: invalid CMAP LUT index\n
jp2_decode
iccstream
colr->iccp
%s\n_jp2overhead=%lu\n
../../../3rdparty/jasper/src/libjasper/jp2/jp2_enc.c
jp2_encode
../../../3rdparty/jasper/src/libjasper/jpc/jpc_bs.c
!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (mode) && __builtin_constant_p ("r") && (__s1_len = strlen (mode), __s2_len = strlen ("r"), (!((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("r") + 1) - (size_t)(const void *)("r") == 1) || __s2_len >= 4)) ? __builtin_strcmp (mode, "r") : (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) && (__s1_len = strlen (mode), __s1_len < 4) ? (__builtin_constant_p ("r") && ((size_t)(const void *)(("r") + 1) - (size_t)(const void *)("r") == 1) ? __builtin_strcmp (mode, "r") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("r"); register int __result = (((__const unsigned char *) (__const char *) (mode))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (mode))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("r") && ((size_t)(const void *)(("r") + 1) - (size_t)(const void *)("r") == 1) && (__s2_len = strlen ("r"), __s2_len < 4) ? (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) ? __builtin_strcmp (mode, "r") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (mode); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("r"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("r"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("r"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("r"))[3]); } } __result; }))) : __builtin_strcmp (mode, "r")))); }) || !__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (mode) && __builtin_constant_p ("w") && (__s1_len = strlen (mode), __s2_len = strlen ("w"), (!((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("w") + 1) - (size_t)(const void *)("w") == 1) || __s2_len >= 4)) ? __builtin_strcmp (mode, "w") : (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) && (__s1_len = strlen (mode), __s1_len < 4) ? (__builtin_constant_p ("w") && ((size_t)(const void *)(("w") + 1) - (size_t)(const void *)("w") == 1) ? __builtin_strcmp (mode, "w") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("w"); register int __result = (((__const unsigned char *) (__const char *) (mode))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (mode))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("w") && ((size_t)(const void *)(("w") + 1) - (size_t)(const void *)("w") == 1) && (__s2_len = strlen ("w"), __s2_len < 4) ? (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) ? __builtin_strcmp (mode, "w") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (mode); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("w"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("w"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("w"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("w"))[3]); } } __result; }))) : __builtin_strcmp (mode, "w")))); }) || !__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (mode) && __builtin_constant_p ("r+") && (__s1_len = strlen (mode), __s2_len = strlen ("r+"), (!((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("r+") + 1) - (size_t)(const void *)("r+") == 1) || __s2_len >= 4)) ? __builtin_strcmp (mode, "r+") : (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) && (__s1_len = strlen (mode), __s1_len < 4) ? (__builtin_constant_p ("r+") && ((size_t)(const void *)(("r+") + 1) - (size_t)(const void *)("r+") == 1) ? __builtin_strcmp (mode, "r+") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("r+"); register int __result = (((__const unsigned char *) (__const char *) (mode))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (mode))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("r+") && ((size_t)(const void *)(("r+") + 1) - (size_t)(const void *)("r+") == 1) && (__s2_len = strlen ("r+"), __s2_len < 4) ? (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) ? __builtin_strcmp (mode, "r+") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (mode); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("r+"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("r+"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("r+"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("r+"))[3]); } } __result; }))) : __builtin_strcmp (mode, "r+")))); }) || !__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (mode) && __builtin_constant_p ("w+") && (__s1_len = strlen (mode), __s2_len = strlen ("w+"), (!((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("w+") + 1) - (size_t)(const void *)("w+") == 1) || __s2_len >= 4)) ? __builtin_strcmp (mode, "w+") : (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) && (__s1_len = strlen (mode), __s1_len < 4) ? (__builtin_constant_p ("w+") && ((size_t)(const void *)(("w+") + 1) - (size_t)(const void *)("w+") == 1) ? __builtin_strcmp (mode, "w+") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("w+"); register int __result = (((__const unsigned char *) (__const char *) (mode))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (mode))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (mode))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("w+") && ((size_t)(const void *)(("w+") + 1) - (size_t)(const void *)("w+") == 1) && (__s2_len = strlen ("w+"), __s2_len < 4) ? (__builtin_constant_p (mode) && ((size_t)(const void *)((mode) + 1) - (size_t)(const void *)(mode) == 1) ? __builtin_strcmp (mode, "w+") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (mode); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("w+"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("w+"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("w+"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("w+"))[3]); } } __result; }))) : __builtin_strcmp (mode, "w+")))); })
bitstream->cnt_ >= 0 && bitstream->cnt_ < 8
(bitstream->buf_ & 0xff) != 0xff
(bitstream)->openmode_ & 0x02
n >= 0 && n < 32
!(v & (~((1 << (n)) - 1)))
bitstream->openmode_ & 0x01
bitstream->cnt_ <= 0
(bitstream)->openmode_ & 0x01
bitstream->openmode_ & 0x02
!(filldata & (~0x3f))
jpc_bitstream_outalign
jpc_bitstream_needalign
jpc_bitstream_fillbuf
jpc_bitstream_putbits
jpc_bitstream_getbits
jpc_bitstream_putbit_func
jpc_bitstream_getbit_func
jpc_bitstream_sopen
%02x 
hoff[%d] = %d; voff[%d] = %d\n
seqno = %d;\n
po[%d] = %d; 
cs[%d] = %d; ce[%d] = %d; 
rs[%d] = %d; re[%d] = %d; 
le[%d] = %d\n
caps = 0x%02x;\n
csty = 0x%02x;\n
prg = %d; numlyrs = %d;\n
regid = %d;\n
data = 
ind=%d; len = %d;\n
data =\n
type = 0x%04x (%s);
 len = %d;
compparms->numdlvls <= 32
compparms->stepsizes
coc->compparms.numdlvls <= 32
compno = %d; qntsty = %d; numguard = %d; numstepsizes = %d\n
expn[%d] = 0x%04x; mant[%d] = 0x%04x;\n
qntsty = %d; numguard = %d; numstepsizes = %d\n
compno = %d; roisty = %d; roishift = %d\n
compno = %d; csty = 0x%02x; numdlvls = %d;\n
cblkwidthval = %d; cblkheightval = %d; cblksty = 0x%02x; qmfbid = %d;\n
width = %d; height = %d; xoff = %d; yoff = %d;\n
tilewidth = %d; tileheight = %d; tilexoff = %d; tileyoff = %d;\n
prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; vsamp[%d] = %d\n
tileno = %d; len = %d; partno = %d; numparts = %d\n
numdlvls = %d; qmfbid = %d; mctrans = %d\n
cblkwidthval = %d; cblkheightval = %d; cblksty = 0x%02x;\n
prcwidth[%d] = %d, prcheight[%d] = %d\n
../../../3rdparty/jasper/src/libjasper/jpc/jpc_cs.c
warning: trailing garbage in marker segment (%ld bytes)\n
cod->numlyrs > 0 && cod->compparms.numdlvls <= 32
cod->compparms.numdlvls == cod->compparms.numrlvls - 1
siz->width && siz->height && siz->tilewidth && siz->tileheight && siz->numcomps
jpc_siz_putparms
jpc_cod_putparms
jpc_cox_putcompparms
jpc_coc_putparms
jpc_qcx_getcompparms
invalid component number in RGN marker segment\n
warning: ignoring unknown marker segment\n
warning: possibly corrupt code stream\n
../../../3rdparty/jasper/src/libjasper/jpc/jpc_dec.c
invalid component number in COC marker segment\n
invalid component number in QCC marker segment\n
warning: ignoring invalid option %s\n
unexpected marker segment type\n
streamno < streamlist->numstreams
!((expn + (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))) & (~0x1f))
xs =%d, ys = %d, xe = %d, ye = %d, w = %d, h = %d\n
warning: ignoring trailing garbage (%lu bytes)\n
warning: not enough tile data (%lu bytes)\n
invalid tile number in SOT marker segment\n
jpc_dec_decodecblks failed\n
absstepsize >= 0
dec->numcomps == 3
write component failed\n
rlvl->numprcs
prc->numcblks > 0
pchg
cannot get marker segment\n
RESOLUTION LEVEL %d\n
BAND %d\n
CODE BLOCK GROUP %d\n
CODE BLOCK %d\n
jpc_dec_decodepkts failed\n
read error\n
compinfos
!tile->cp
maxlyrs
maxpkts
debug
jpc_streamlist_get
jpc_dec_process_sot
jpc_dec_tileinit
calcstepsizes
jpc_dequantize
jpc_dec_tiledecode
../../../3rdparty/jasper/src/libjasper/jpc/jpc_enc.c
tcmpt->numstepsizes <= (3 * 33 + 1)
cblktlx < cblkbrx && cblktly < cblkbry
start=%d end=%d type=%d term=%d lyrno=%d firstchar=%02x size=%ld pos=%ld\n
lyrno=%02d cmptno=%02d rlvlno=%02d bandno=%02d prcno=%02d cblkno=%03d passno=%03d\n
min rdslope = %f max rdslope = %f\n
maxlen=%08ld actuallen=%08ld thresh=%f\n
warning: empty layer generated\n
        prc %5d %5d %5d %5d (%5d %5d)\n
         cblk %5d %5d %5d %5d\n
ignoring invalid progression order %s\n
ignoring bad rate specifier %s\n
warning: invalid intermediate layer rates specifier ignored (%s)\n
warning: overriding imgareatlx value\n
warning: overriding imgareatly value\n
warning: color space apparently not RGB\n
invalid tile grid offset (%lu, %lu)\n
cannot use real mode for lossless coding\n
must be at least one resolution level\n
warning: specified rate is unreasonably large (%lu > %lu)\n
intermediate layer rates must increase monotonically\n
warning: intermediate layer rates must be less than overall rate\n
((enc->image)->numcmpts_) == 3
error: too few guard bits (need at least %d)\n
!((expn) & (~0x1f))
cannot write SOC marker\n
siz->comps
cannot write SIZ marker\n
Creator: JasPer Version %s
cannot write COM marker\n
cannot write COD marker\n
enc->tmpstream
pass0
lyrno = %02d\n
lyrno == numlyrs - 1
oldpos >= 0
success %d goodthresh %f\n
  tcmpt %5d %5d %5d %5d\n
    rlvl %5d %5d %5d %5d\n
      band %5d %5d %5d %5d\n
unsupported image type\n
ignoring invalid mode %s\n
invalid tile width %lu\n
invalid tile height %lu\n
invalid precinct width\n
invalid precinct height\n
invalid code block width %d\n
invalid code block height %d\n
code block size too large\n
too many layers\n
invalid number of guard bits\n
cannot open tmp file\n
cannot write SOT marker\n
cannot write SOD marker\n
dotile failed\n
cannot write EOI marker\n
invalid JP encoder options\n
lrcp
rlcp
rpcl
pcrl
cprl
imgareatlx
imgareatly
tilegrdtlx
tilegrdtly
tilewidth
tileheight
prcwidth
prcheight
cblkwidth
cblkheight
nomct
numrlvls
lazy
termall
segsym
vcausal
pterm
resetprob
numgbits
rate
ilyrrates
_jp2overhead
cblk_create
tcmpt_create
rateallocate
calcrdslopes
jpc_enc_encodetiledata
jpc_enc_encodemainbody
jpc_abstorelstepsize
jpc_enc_encodemainhdr
 ?../../../3rdparty/jasper/src/libjasper/jpc/jpc_math.c
jpc_firstone
jpc_floorlog2
../../../3rdparty/jasper/src/libjasper/jpc/jpc_mct.c
((c1)->numrows_) == numrows && ((c1)->numcols_) == numcols && ((c2)->numrows_) == numrows && ((c2)->numcols_) == numcols
((c1)->numrows_) == numrows && ((c2)->numrows_) == numrows
((c1)->numcols_) == numcols && ((c2)->numcols_) == numcols
jpc_iict
jpc_ict
jpc_irct
jpc_rct
../../../3rdparty/jasper/src/libjasper/jpc/jpc_mqdec.c
MQDEC A = %08lx, C = %08lx, CT=%08lx, 
maxctxs > 0
CTX = %d, 
IND %d, MPS %d, QEVAL %x\n
jpc_mqdec_create
AREG = %08x, CREG = %08x, CTREG = %d\n
IND = %02d, MPS = %d, QEVAL = %04x\n
../../../3rdparty/jasper/src/libjasper/jpc/jpc_t1cod.c
!(x & (~((1 << (bitpos + 1)) - 1)))
qmfbid == 0x01
orient == 0
jpc_getsignmsedec_func
JPC_SEGPASSCNT
JPC_NOMINALGAIN
JPC_PASSTYPE
../../../3rdparty/jasper/src/libjasper/jpc/jpc_t1dec.c
warning: bad segmentation symbol\n
coding pass failed passtype=%d segtype=%d\n
warning: bad termination pattern detected\n
dopartial ? (!cblk->curseg) : 1
seg->stream
seg->type == 2
warning: corrupt code stream\n
bpno >= 0 && bpno < 31
(in)->openmode_ & 0x01
seg->type == 1
dec_rawrefpass
dec_rawsigpass
jpc_dec_decodecblk
../../../3rdparty/jasper/src/libjasper/jpc/jpc_t1enc.c
cblk->stream
cblk->mqenc
cblk->passes
pass->term == 1
cblk->flags
pass->type == 2
bout
bitpos >= 0
((out))->openmode_ & 0x02
(out)->openmode_ & 0x02
pass->type == 1
cblk->numimsbs >= 0
jpc_encrawrefpass
jpc_encrawsigpass
jpc_enc_enccblk
getthebyte
jpc_enc_enccblks
../../../3rdparty/jasper/src/libjasper/jpc/jpc_t2cod.c
pi->prcno < pi->pirlvl->numprcs
jpc_pchglist_remove
jpc_pi_nextcprl
jpc_pi_nextpcrl
jpc_pi_nextrpcl
jpc_pi_nextrlcp
pchgno < pchglist->numpchgs
warning: stopping decode prematurely as requested\n
../../../3rdparty/jasper/src/libjasper/jpc/jpc_t2dec.c
packet offset=%08ld prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n
cannot get (EPH) marker segment\n
pi->valid
missing SOP marker segment\n
(inb)->openmode_ & 0x01
alignment failed\n
hdrlen=%lu bodylen=%lu \n
missing EPH marker segment\n
packet body offset=%06ld\n
jpc_getcommacode
jpc_getnumnewpasses
jpc_dec_decodepkt
jpc_dec_decodepkts
outb
(outb)->openmode_ & 0x02
../../../3rdparty/jasper/src/libjasper/jpc/jpc_t2enc.c
leaf->known_ && i == leaf->value_ + 1
jpc_firstone(datalen) < cblk->numlenbits + jpc_floorlog2(passcount)
pass->lyrno < 0 || pass->lyrno > lyrno
jas_stream_tell(cblk->stream) == startpass->start
jpc_init_t2state
jpc_putcommacode
jpc_putnumnewpasses
jpc_enc_encpkt
jpc_enc_encpkts
../../../3rdparty/jasper/src/libjasper/jpc/jpc_tagtree.c
numleafsh > 0 && numleafsv > 0
srctree->numleafsh_ == dsttree->numleafsh_ && srctree->numleafsv_ == dsttree->numleafsv_
node %p, parent %p, value %d, lower %d, known %d\n
value >= 0
leaf
threshold >= 0
jpc_tagtree_decode
jpc_tagtree_encode
jpc_tagtree_setvalue
jpc_tagtree_copy
jpc_tagtree_create
../../../3rdparty/jasper/src/libjasper/jpc/jpc_util.c
jpc_seq_conv
../../../3rdparty/jasper/src/libjasper/mif/mif_cod.c
warning: ignoring unsupported options\n
component tlx=%ld tly=%ld sampperx=%ld samppery=%ld width=%ld height=%ld prec=%d sgnd=%d
maxcmpts >= hdr->numcmpts
error: bad signature\n
error: PNM support required\n
end\n
 data=%s
sampperx
samppery
prec
sgnd
component
mif_hdr_growcmpts
unsigned
bigendian
littleendian
byteorder=%s sgnd=%s prec=%d width=%d height=%d\n
%c%c
 %s %s %d %ld %ld\n
The PNM format cannot be used to represent an image with this geometry.\n
warning: ignoring options\n
../../../3rdparty/jasper/src/libjasper/pnm/pnm_dec.c
(tmpval & (1 << (wordsize - 1))) == 0
pnm_getsint
\n%lu %lu\n%ld\n
%s%ld
text
invalid PNM encoder options specified\n
error: unsupported color space\n
warning: support for signed sample data requires use of nonstandard extension to PNM format\n
You may not be able to read or correctly display the resulting PNM data with other software.\n
warning: ignoring RAS decoder options\n
warning: palettized images not fully supported\n
../../../3rdparty/jasper/src/libjasper/ras/ras_dec.c
error: RLE encoding method not supported\n
error: encoding method not supported\n
numcolors <= 256
data[i]
ras_getdatastd
ras_getcmap
warning: ignoring RAS encoder options\n
The RAS format cannot be used to represent an image with this geometry.\n
../../../3rdparty/jasper/src/libjasper/ras/ras_enc.c
ras_putdatastd
@&LH
A'\r:
QC,A
TF<)
VGy#
KNQ\r
M0@\n
a\">
c]$8
eaFO
hd=<
c]^7
if1R
kh9F
gc^A
okOP
pm"U
E\v0~
sAmTb
BKbhTb~XBK!;
A!;I2
"\v0A-
\t#3R
&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
$3br
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
E\v0~
sAmTb
BKbhTb~XBK!;
A!;I2
"\v0A-
Bogus message code %d
Bogus buffer control mode
Invalid crop request
DCT coefficient out of range
Bogus input colorspace
Bogus JPEG colorspace
Bogus marker length
Invalid memory pool code %d
Bogus sampling factors
Bogus virtual array access
Suspension not allowed here
Bogus DAC index %d
Bogus DAC value 0x%x
Bogus DHT index %d
Bogus DQT index %d
Read from EMS failed
Write to EMS failed
Input file read error
Empty input file
Premature end of input file
Not implemented yet
Backing store not supported
Insufficient memory (case %d)
Read failed on temporary file
Seek failed on temporary file
Read from XMS failed
Write to XMS failed
8c  16-Jan-2011
Define Huffman Table 0x%02x
Define Restart Interval %u
Freed EMS handle %u
Obtained EMS handle %u
End Of Image
Unexpected marker 0x%02x
Quantizing to %d colors
RST%d
Start of Image
Start Of Scan: %d components
    Component %d: dc=%d ac=%d
  Ss=%d, Se=%d, Ah=%d, Al=%d
Closed temporary file %s
Opened temporary file %s
Freed XMS handle %u
Obtained XMS handle %u
Premature end of JPEG file
ALIGN_TYPE is wrong, please fix
MAX_ALLOC_CHUNK is wrong, please fix
Invalid component ID %d in SOS
DCT scaled block size %dx%d not supported
Component index %d: mismatching sampling ratio %d:%d, %d:%d, %c
Bogus Huffman table definition
Wrong JPEG library version: library is %d, caller expects %d
Sampling factors too large for interleaved scan
Unsupported JPEG data precision %d
Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d
Invalid progressive parameters at scan script entry %d
Invalid scan script at entry %d
Improper call to JPEG library in state %d
JPEG parameter struct mismatch: library thinks size is %u, caller expects %u
Buffer passed to JPEG library is too small
CCIR601 sampling not implemented yet
Too many color components: %d, max %d
Unsupported color conversion request
Empty JPEG image (DNL not supported)
Didn't expect more than one scan
Output file write error --- out of disk space?
Fractional sampling not implemented yet
Huffman code size table overflow
Missing Huffman code table entry
Maximum supported image dimension is %u pixels
Cannot transcode due to multiple use of quantization table %d
Scan script does not transmit all data
Invalid color quantization mode change
Requested feature was omitted at compile time
Arithmetic table 0x%02x was not defined
Huffman table 0x%02x was not defined
JPEG datastream contains no image
Quantization table 0x%02x was not defined
Not a JPEG file: starts with 0x%02x 0x%02x
Cannot quantize more than %d color components
Cannot quantize to fewer than %d colors
Cannot quantize to more than %d colors
Invalid JPEG file structure: two SOF markers
Invalid JPEG file structure: missing SOS marker
Unsupported JPEG process: SOF type 0x%02x
Invalid JPEG file structure: two SOI markers
Invalid JPEG file structure: SOS before SOF
Failed to create temporary file %s
Write failed on temporary file --- out of disk space?
Application transferred too few scanlines
Unsupported marker type 0x%02x
Virtual array controller messed up
Image too wide for this implementation
Copyright (C) 2011, Thomas G. Lane, Guido Vollbeding
Caution: quantization tables are too coarse for baseline JPEG
Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d
Unknown APP0 marker (not JFIF), length %u
Unknown APP14 marker (not Adobe), length %u
Define Arithmetic Table 0x%02x: 0x%02x
Define Quantization Table %d  precision %d
        %3d %3d %3d %3d %3d %3d %3d %3d
JFIF APP0 marker: version %d.%02d, density %dx%d  %d
Warning: thumbnail image size does not match data length %u
JFIF extension marker: type 0x%02x, length %u
    with %d x %d thumbnail image
Miscellaneous marker 0x%02x, length %u
        %4u %4u %4u %4u %4u %4u %4u %4u
Quantizing to %d = %d*%d*%d colors
Selected %d colors for quantization
At marker 0x%02x, recovery action %d
Smoothing not supported with nonstandard sampling ratios
Start Of Frame 0x%02x: width=%u, height=%u, components=%d
    Component %d: %dhx%dv q=%d
JFIF extension marker: JPEG-compressed thumbnail image, length %u
JFIF extension marker: palette thumbnail image, length %u
JFIF extension marker: RGB thumbnail image, length %u
Unrecognized component IDs %d %d %d, assuming YCbCr
Unknown Adobe color transform code %d
Corrupt JPEG data: bad arithmetic code
Inconsistent progression sequence for component %d coefficient %d
Corrupt JPEG data: %u extraneous bytes before marker 0x%02x
Corrupt JPEG data: premature end of data segment
Corrupt JPEG data: bad Huffman code
Warning: unknown JFIF revision number %d.%02d
Corrupt JPEG data: found marker 0x%02x instead of RST%d
Invalid SOS parameters for sequential JPEG
Application transferred too many scanlines
\n?u=
?u='@
JPEGMEM
%ld%c
../../../3rdparty/jasper/src/libjasper/jpg/jpg_dec.c
cinfo->output_components == ((dinfo->image)->numcmpts_)
jpg_put_pixel_rows
src_mgr->data
quality
ignoring bad quality specifier %s\n
error: JPG format does not support color space\n
error: The JPG encoder cannot handle an image with this geometry.\n
../../../3rdparty/jasper/src/libjasper/jpg/jpg_enc.c
jpg_encode
QJp2Plugin
10QJp2Plugin
vruc
 ZYX
csed
txet
1tfm
2tfm
scnrGRAYXYZ 
!acsp
KODAsGry
-JPEG
desc
cprt
+wtpt
kTRC
desc
,Restricted ICC profile describing sRGB-grey
text
Copyright 2003 sRGB-grey Reference
XYZ 
curv
\fHLino
mntrRGB XYZ 
acspMSFT
IEC sRGB
-HP  
cprt
3desc
lwtpt
bkpt
rXYZ
gXYZ
bXYZ
dmnd
pdmdd
vued
view
$lumi
meas
$tech
\frTRC
\fgTRC
\fbTRC
\ftext
Copyright (c) 1998 Hewlett-Packard Company
desc
sRGB IEC61966-2.1
sRGB IEC61966-2.1
XYZ 
XYZ 
XYZ 
XYZ 
XYZ 
desc
IEC http://www.iec.ch
IEC http://www.iec.ch
desc
.IEC 61966-2.1 Default RGB colour space - sRGB
.IEC 61966-2.1 Default RGB colour space - sRGB
desc
,Reference Viewing Condition in IEC61966-2.1
,Reference Viewing Condition in IEC61966-2.1
view
XYZ 
meas
sig 
CRT curv
\t%\t:\tO\td\ty\t
\n'\n=\nT\nj\n
\v\v\v"\v9\vQ\vi\v
\f*\fC\f\\fu\f
\r\r\r&\r@\rZ\rt\r
 A l 
!H!u!
"'"U"
#\n#8#f#
$M$|$
%\t%8%h%
&'&W&
'I'z'
(\r(?(q(
)8)k)
*5*h*
+6+i+
,9,n,
-\f-A-v-
/$/Z/
050l0
2*2c2
3\r3F3
4+4e4
676r6
7$7`7
:6:t:
;-;k;
<'<e<
="=a=
> >`>
?!?a?
@#@d@
A)AjA
B0BrB
C:C}C
F"FgF
G5G{G
J7J}J
K\fKSK
L*LrL
N%NnN
P'PqP
R1R|R
U(UuU
X/X}X
]']x]
  Pj
pytf
h2pj
rdhi
ccpb
rloc
rlcp
pamc
fedc
 ser
cser
dser
c2pj
i2pj
 lmx
diuu
fniu
tscu
 lru
?{r}+G
P@<s
W@*/
p@@K
_$Q\rv
@Wgl
>z @
M'@[KX
MG@k
MW@\t
zp@Nd
;@Kb
C@j5
{@.!\t
?4x3
D'\n@>L
y"@;
 *@8
y2@-!
 :@Y
yR@4
yb@m
yr@T
, \t\n
GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-9)
GCC: (GNU) 4.9.1 20140922 (Red Hat 4.9.1-10)
