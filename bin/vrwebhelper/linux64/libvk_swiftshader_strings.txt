                                                                                
  This option category has no options.\n
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 "$&(*,.02468:<>@BDFHJLNPRTVXZ\^`bdfhjlnprtvxz|~
 $(,048<AEIMQUY]aeimquy}
 (default: 
 (member index 
 (must be 0 or 1)
 (must be 0, 1 or 2)
 (not another case construct, corresponding merge, outer loop merge or outer loop continue)
 (or requires extension or capability)
 (or requires extension)
 4 columns of 3-component vectors of 32-bit floats. 
 <subcommand> -help" to get more help on a specific subcommand
 Constituent <id> 
 Constituent <id> count does not match Result Type <id> 
 Constituent count does not match Result Type <id> 
 Either both Hint and Bits should be provided or neither.
 Found result <id> 
 In Vulkan, BufferBlock is disallowed on variables in the StorageBuffer storage class
 NumIDs=
 OpTypeVector. Found Op
 Profile specification
 TaskEXT execution model. 
 [options]
 [subcommand]
 and ending with 
 and rows 
 appears in the binary before its dominator 
 are referenced but not defined in function 
 arguments.
 arguments. OpTypeFunction <id> 
 as an operand of <id> 
 at minimum or one of the following extensions: 
 at minimum.
 back-edge blocks but the standard requires exactly one
 based on the function's type
 because it is targeted by an OpEntryPoint instruction.
 branches to the 
 branches to the loop continue target 
 can only be applied to structure members
 can only be used with physical addressing models
 cannot appear before the memory model instruction
 cannot appear in a function declaration
 cannot be OpTypeVoid.
 cannot be a constant zero.
 cannot be a type
 cannot be a void pointer.
 cannot be applied to structure members
 cannot be used as a member decoration 
 cannot be used by an entry point with the FPFastMathDefault execution mode
 cannot find index 
 cannot have a null value.
 cannot have the sign bit set to 1.
 columns, but access index is 
 component type does not match Result Type <id> 
 components are not float scalar.
 components are not int scalar.
 components for 
 components, 
 components, but given 
 components, but given only 
 components.
 construct headed by 
 construct with the 
 construct, but not to the 
 contains members with BuiltIn decoration. Therefore this 
 contains structure <id> 
 count must be one.
 decorated as 
 decorated variable must not be used in fragment execution model as an Output storage class for Entry Point id 
 decorated variable must not be used in vertex execution model as an Input storage class for Entry Point id 
 decoration applied to a non-object
 decoration applied to a value with void type
 decoration applied to an object with invalid type
 decoration may not be applied to 
 decoration must not be applied to this storage class
 decoration on a non-struct type.
 decoration on target <id> 
 decoration targeting 
 default value must be at least 1: found 
 defined in block 
 definition does not dominate its parent 
 depends on 
 did not find an member index to get underlying data type for struct type.
 do not match.
 does not dominate its use in block 
 does not fit in a 
 does not have a 
 does not match Pointer <id> 
 does not match incoming value <id> 
 does not match the Function Type's return type <id> 
 does not match the OpTypeFunction parameter type of the same index.
 does not meet this requirement.
 does not reference a function
 does not reference an OpExtInstImport result Id
 does not reference an entry-point
 does not represent a value.
 does not structurally dominate its case construct 
 environments.
 execution mode must not be specified multiple times for the same entry point and operands
 execution mode must not be specified multiple times per entry point
 exits the 
 extension requires SPIR-V version 1.4 or later.
 for target environment 
 for variable in 
 from a depth image read to result in a scalar float value
 gets larger than 3
 has a consumer in a different basic block. The consumer instruction <id> is 
 has bit width 
 has branches to multiple other case construct targets 
 has branches to the case construct that targets 
 has columns 
 has components with bit width 
 has conflicting component assignments
 has conflicting location assignments
 has illegal type.\n
 has invalid branch to block 
 has invalid mask component 
 has no type
 has not been defined
 headed by <ID> 
 in Vertex or Tessellation execution model requires the 
 in function <
 in semantic instruction cannot be a non-semantic instruction
 in the structure <id> '
 index is larger than Type <id> 
 indexes.
 instruction can only have 2 additional operands
 instruction must be a pointer.
 instructions require Geometry execution model
 into the structure <id> 
 is a pointer, which is invalid in the Logical addressing model.
 is a type, not a value
 is a void type.
 is already a merge block for another header
 is banned when using the Vulkan memory model.
 is contained in the 
 is decorated with BuiltIn. BuiltIn decoration should only be applied to struct types, variables and constants.
 is defined more than once
 is disallowed
 is in an invalid layout section
 is invalid
 is missing a location assignment
 is missing or void.
 is not
 is not Workgroup or StorageBuffer.
 is not Workgroup, StorageBuffer, or PhysicalStorageBuffer.
 is not a bool scalar.
 is not a boolean type.
 is not a composite type.
 is not a constant instruction with scalar integer type.
 is not a constant integer type.
 is not a constant or module-scope variable.
 is not a constant or undef.
 is not a constant.
 is not a cooperative matrix type.
 is not a decoration group.
 is not a float scalar.
 is not a float vector.
 is not a function type.
 is not a function.
 is not a logical pointer.
 is not a pointer.
 is not a predecessor of <id> 
 is not a sampler type.
 is not a scalar constant type.
 is not a scalar integer
 is not a scalar numeric type
 is not a scalar numerical type.
 is not a scalar type.
 is not a struct type.
 is not a type
 is not a type id
 is not a type.
 is not a valid debug type
 is not aligned to 
 is not aligned to scalar element size 
 is not allowed by OpenCL 1.2 
 is not allowed by OpenCL 2.0/2.1 
 is not allowed by OpenCL 2.2 
 is not allowed by Vulkan 1.0 specification
 is not allowed by Vulkan 1.1 specification
 is not allowed by Vulkan 1.2 specification
 is not an OpLabel.
 is not an OpString.
 is not an array.
 is not an int scalar.
 is not an int vector.
 is not an object.
 is not pointer type
 is not the Entry Point operand of an OpEntryPoint.
 is not valid in 
 is out of bounds for 
 is out of bounds. The structure has 
 is referencing 
 is reserved for future use.
 is targeted by 
 is targeted by block 
 is used outside of it's defining function 
 layout rules: member 
 location assignment at location 
 may not exceed 
 members. Largest valid index is 
 multiple times is not allowed.
 multiple times.
 must be 0 for a floating-point type, 
 must be 32. Found 
 must be OpConstant. Found Op
 must be OpTypeCooperativeMatrixKHR.
 must be OpTypeCooperativeMatrixNV.
 must be OpTypeInt with width 32 and signedness 0.
 must be OpTypeInt. Found Op
 must be OpTypePointer. Found Op
 must be a 32-bit integer constant instruction.
 must be a boolean constant instruction.
 must be a pointer to an OpTypeStruct.
 must be a result id of 32-bit unsigned OpConstant
 must be a result id of a lexical scope
 must be a scalar integer type.
 must be an OpLabel
 must be an OpTypeRuntimeArray.
 must be an the last member of the struct.
 must be explicitly laid out with ArrayStride decorations.
 must be explicitly laid out with MatrixStride decorations.
 must be explicitly laid out with Offset decorations.
 must be explicitly laid out with RowMajor or ColMajor decorations.
 must be of type integer.
 must be present.
 must not point to OpTypeArray, OpTypeMatrix, or OpTypeStruct.
 must point to a storage class of StorageBuffer, PhysicalStorageBuffer, or Uniform.
 must refer only to GLCompute entry-points
 not equal to expected 
 not satisfying alignment to 
 numerical scalar type
 of function 
 of struct ID <
 of the 
 operand at word offset 
 operand index 
 operand of 
 option: 
 or Op
 or earlier
 overlaps previous member ending at offset 
 provided in OpGroupMemberDecorate for struct <id> 
 provided in OpMemberDecorate for struct <id> 
 reached non-composite type while indexes still remain to be traversed.
 requires Kernel capability
 requires RayGenerationKHR execution model
 requires Shader capability
 requires a previous definition
 requires a type
 requires a variable pointers capability
 requires capability InterpolationFunction
 requires one of the following extensions: 
 requires one of these capabilities: 
 requires the Vector16 capability
 requires version 
 result type (Op
 says it has 
 spec BuiltIn FragCoord variable needs to be a 4-component 32-bit float vector. 
 spec BuiltIn FragDepth variable needs to be a 32-bit float scalar. 
 spec BuiltIn FrontFacing variable needs to be a bool scalar. 
 spec BuiltIn InstanceIndex variable needs to be a 32-bit int scalar. 
 spec BuiltIn VertexIndex variable needs to be a 32-bit int scalar. 
 spec BuiltIn WorkgroupSize variable needs to be a 3-component 32-bit int vector. 
 spec allows BuiltIn FragCoord to be only used for variables with Input storage class. 
 spec allows BuiltIn FragCoord to be used only with Fragment execution model. 
 spec allows BuiltIn FragDepth to be only used for variables with Output storage class. 
 spec allows BuiltIn FragDepth to be used only with Fragment execution model. 
 spec allows BuiltIn FrontFacing to be only used for variables with Input storage class. 
 spec allows BuiltIn FrontFacing to be used only with Fragment execution model. 
 spec allows BuiltIn InstanceIndex to be only used for variables with Input storage class. 
 spec allows BuiltIn InstanceIndex to be used only with Vertex execution model. 
 spec allows BuiltIn VertexIndex to be only used for variables with Input storage class. 
 spec allows BuiltIn VertexIndex to be used only with Vertex execution model. 
 spec requires DepthReplacing execution mode to be declared when using BuiltIn FragDepth. 
 starting at word 
 storage class for pointer type <id> 
 storage class is read-only
 storage class must follow 
 storage class requires an additional capability
 that is not a scalar or vector
 the same type as Result Type components
 to be int or float scalar or vector type
 to be int or float scalar type
 to be int or float vector type
 to be not be used with GLCompute execution model. 
 to be used only with Fragment, Vertex, TessellationControl, TessellationEvaluation or Geometry execution models. 
 to be used only with GLCompute, MeshNV, TaskNV, MeshEXT or
 to be used only with GLCompute, MeshNV, TaskNV, MeshEXT or 
 to be used only with MeshEXT execution model. 
 to be used only with Vertex, Geometry, or MeshNV execution models. 
 to be used only with Vertex, MeshNV, TaskNV , MeshEXT or
 to be used only with Vertex, TessellationEvaluation, Geometry, or Fragment execution models. 
 to be used only with the Fragment execution model. 
 to be used with the execution model 
 to have 4 components
 to index into a structure must be an OpConstant.
 type does not match the Result Type <id> 
 used in function 
 uses storage class 
 variable needs to be a 2-component 32-bit int array.
 variable needs to be a 2-component 32-bit int vector. 
 variable needs to be a 3-component 32-bit int array.
 variable needs to be a 32-bit float array. 
 variable needs to be a 32-bit int array.
 variable needs to be a 32-bit int vector. 
 variable needs to be a 32-bit int. 
 variable needs to be a 4-component 32-bit int vector. 
 variable needs to be a int scalar. 
 variable needs to be a matrix with
 vector component count does not match Result Type <id> 
 which is decorated with BuiltIn 
 which is dependent on 
 with Input interfaces with integer or float type must have a Flat decoration for Entry Point id 
 with two memory access operands requires SPIR-V 1.4 or later
 words instead of 
 words instead.
 words long
 words, but found 
 words, but stated word count is 
 words.
 words: 
 yielding Result Id 
!)19BJRZcks{
"$&(*,.02468:<>@
"3DUfw
$jumptable
$jumptable$__
%.0Lf
%H:%M:%S%m/%d/%y%Y-%m-%d%I:%M:%S %p%H:%M%H:%M:%S
%I:%M:%S %p
%a %b %d %H:%M:%S %Y
%s failed to acquire mutex
%s failed to broadcast
%s failed to release mutex
%s:%d TRACE: ()\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBool32 depthBiasEnable = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBool32 depthBoundsTestEnable = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBool32 depthTestEnable = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBool32 depthWriteEnable = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBool32 primitiveRestartEnable = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBool32 rasterizerDiscardEnable = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBool32 stencilTestEnable = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer buffer = %p, VkDeviceSize offset = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer buffer = %p, VkDeviceSize offset = %d, VkBuffer countBuffer = %p, VkDeviceSize countBufferOffset = %d, uint32_t maxDrawCount = %d, uint32_t stride = %d\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer buffer = %p, VkDeviceSize offset = %d, VkIndexType indexType = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer buffer = %p, VkDeviceSize offset = %d, uint32_t drawCount = %d, uint32_t stride = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer dstBuffer = %p, VkDeviceSize dstOffset = %d, VkDeviceSize dataSize = %d, const void* pData = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer dstBuffer = %p, VkDeviceSize dstOffset = %d, VkDeviceSize size = %d, uint32_t data = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer srcBuffer = %p, VkBuffer dstBuffer = %p, uint32_t regionCount = %d, const VkBufferCopy* pRegions = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkBuffer srcBuffer = %p, VkImage dstImage = %p, VkImageLayout dstImageLayout = %d, uint32_t regionCount = %d, const VkBufferImageCopy* pRegions = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkCommandBufferResetFlags flags = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkCompareOp depthCompareOp = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkCullModeFlags cullMode = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkEvent event = %p, VkPipelineStageFlags stageMask = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkEvent event = %p, VkPipelineStageFlags2 stageMask = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkEvent event = %p, const VkDependencyInfo* pDependencyInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkFrontFace frontFace = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkImage image = %p, VkImageLayout imageLayout = %d, const VkClearColorValue* pColor = %p, uint32_t rangeCount = %d, const VkImageSubresourceRange* pRanges = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkImage image = %p, VkImageLayout imageLayout = %d, const VkClearDepthStencilValue* pDepthStencil = %p, uint32_t rangeCount = %d, const VkImageSubresourceRange* pRanges = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkImage srcImage = %p, VkImageLayout srcImageLayout = %d, VkBuffer dstBuffer = %p, uint32_t regionCount = %d, const VkBufferImageCopy* pRegions = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkImage srcImage = %p, VkImageLayout srcImageLayout = %d, VkImage dstImage = %p, VkImageLayout dstImageLayout = %d, uint32_t regionCount = %d, const VkImageBlit* pRegions = %p, VkFilter filter = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkImage srcImage = %p, VkImageLayout srcImageLayout = %d, VkImage dstImage = %p, VkImageLayout dstImageLayout = %d, uint32_t regionCount = %d, const VkImageCopy* pRegions = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkImage srcImage = %p, VkImageLayout srcImageLayout = %d, VkImage dstImage = %p, VkImageLayout dstImageLayout = %d, uint32_t regionCount = %d, const VkImageResolve* pRegions = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkPipelineBindPoint pipelineBindPoint = %d, VkPipeline pipeline = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkPipelineBindPoint pipelineBindPoint = %d, VkPipelineLayout layout = %p, uint32_t firstSet = %d, uint32_t descriptorSetCount = %d, const VkDescriptorSet* pDescriptorSets = %p, uint32_t dynamicOffsetCount = %d, const uint32_t* pDynamicOffsets = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkPipelineLayout layout = %p, VkShaderStageFlags stageFlags = %d, uint32_t offset = %d, uint32_t size = %d, const void* pValues = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkPipelineStageFlagBits pipelineStage = %d, VkQueryPool queryPool = %p, uint32_t query = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkPipelineStageFlags srcStageMask = 0x%08X, VkPipelineStageFlags dstStageMask = 0x%08X, VkDependencyFlags dependencyFlags = %d, uint32_t memoryBarrierCount = %d, onst VkMemoryBarrier* pMemoryBarriers = %p, uint32_t bufferMemoryBarrierCount = %d, const VkBufferMemoryBarrier* pBufferMemoryBarriers = %p, uint32_t imageMemoryBarrierCount = %d, const VkImageMemoryBarrier* pImageMemoryBarriers = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkPipelineStageFlags2 stage = %d, VkQueryPool queryPool = %p, uint32_t query = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkPrimitiveTopology primitiveTopology = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkQueryPool queryPool = %p, uint32_t firstQuery = %d, uint32_t queryCount = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkQueryPool queryPool = %p, uint32_t firstQuery = %d, uint32_t queryCount = %d, VkBuffer dstBuffer = %p, VkDeviceSize dstOffset = %d, VkDeviceSize stride = %d, VkQueryResultFlags flags = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkQueryPool queryPool = %p, uint32_t query = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkQueryPool queryPool = %p, uint32_t query = %d, VkQueryControlFlags flags = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkStencilFaceFlags faceMask = %d, VkStencilOp failOp = %d, VkStencilOp passOp = %d, VkStencilOp depthFailOp = %d, VkCompareOp compareOp = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkStencilFaceFlags faceMask = %d, uint32_t compareMask = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkStencilFaceFlags faceMask = %d, uint32_t reference = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkStencilFaceFlags faceMask = %d, uint32_t writeMask = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, VkSubpassContents contents = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, baseGroupX = %u, baseGroupY = %u, baseGroupZ = %u, groupCountX = %u, groupCountY = %u, groupCountZ = %u)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkBlitImageInfo2* pBlitImageInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkCommandBufferBeginInfo* pBeginInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkCopyBufferInfo2* pCopyBufferInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkCopyImageInfo2* pCopyImageInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkDebugUtilsLabelEXT* pLabelInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkDependencyInfo* pDependencyInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkRenderPassBeginInfo* pRenderPassBegin = %p, const VkSubpassBeginInfoKHR* pSubpassBeginInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkRenderingInfo* pRenderingInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkResolveImageInfo2* pResolveImageInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkSubpassBeginInfoKHR* pSubpassBeginInfo = %p, const VkSubpassEndInfoKHR* pSubpassEndInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const VkSubpassEndInfoKHR* pSubpassEndInfo = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, const float blendConstants[4] = {%f, %f, %f, %f})\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, float depthBiasConstantFactor = %f, float depthBiasClamp = %f, float depthBiasSlopeFactor = %f)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, float lineWidth = %f)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, float minDepthBounds = %f, float maxDepthBounds = %f)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t attachmentCount = %d, const VkClearAttachment* pAttachments = %p, uint32_t rectCount = %d, const VkClearRect* pRects = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t commandBufferCount = %d, const VkCommandBuffer* pCommandBuffers = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t deviceMask = %d\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t eventCount = %d, const VkEvent* pEvents = %p, VkPipelineStageFlags srcStageMask = 0x%08X, VkPipelineStageFlags dstStageMask = 0x%08X, uint32_t memoryBarrierCount = %d, const VkMemoryBarrier* pMemoryBarriers = %p, uint32_t bufferMemoryBarrierCount = %d, const VkBufferMemoryBarrier* pBufferMemoryBarriers = %p, uint32_t imageMemoryBarrierCount = %d, const VkImageMemoryBarrier* pImageMemoryBarriers = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t eventCount = %d, const VkEvent* pEvents = %p, const VkDependencyInfo* pDependencyInfos = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t firstBinding = %d, uint32_t bindingCount = %d, const VkBuffer* pBuffers = %p, const VkDeviceSize* pOffsets = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t firstBinding = %d, uint32_t bindingCount = %d, const VkBuffer* pBuffers = %p, const VkDeviceSize* pOffsets = %p, const VkDeviceSize *pSizes = %p, const VkDeviceSize *pStrides = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t firstScissor = %d, uint32_t scissorCount = %d, const VkRect2D* pScissors = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t firstViewport = %d, uint32_t viewportCount = %d, const VkViewport* pViewports = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t groupCountX = %d, uint32_t groupCountY = %d, uint32_t groupCountZ = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t indexCount = %d, uint32_t instanceCount = %d, uint32_t firstIndex = %d, int32_t vertexOffset = %d, uint32_t firstInstance = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t lineStippleFactor = %u, uint16_t lineStipplePattern = %u)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t scissorCount = %d, const VkRect2D *pScissors = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t vertexBindingDescriptionCount = %d, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions = %p, uint32_t vertexAttributeDescriptionCount = %d, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions = %p)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t vertexCount = %d, uint32_t instanceCount = %d, uint32_t firstVertex = %d, uint32_t firstInstance = %d)\n
%s:%d TRACE: (VkCommandBuffer commandBuffer = %p, uint32_t viewportCount = %d, const VkViewport *pViewports = %p)\n
%s:%d TRACE: (VkDevice device = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkBuffer buffer = %p, VkDeviceMemory memory = %p, VkDeviceSize memoryOffset = %d)\n
%s:%d TRACE: (VkDevice device = %p, VkBuffer buffer = %p, VkMemoryRequirements* pMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkBuffer buffer = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkBufferView bufferView = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkCommandPool commandPool = %p, VkCommandPoolResetFlags flags = %d)\n
%s:%d TRACE: (VkDevice device = %p, VkCommandPool commandPool = %p, VkCommandPoolTrimFlags flags = %d)\n
%s:%d TRACE: (VkDevice device = %p, VkCommandPool commandPool = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkCommandPool commandPool = %p, uint32_t commandBufferCount = %d, const VkCommandBuffer* pCommandBuffers = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDescriptorPool descriptorPool = %p, VkDescriptorPoolResetFlags flags = 0x%08X)\n
%s:%d TRACE: (VkDevice device = %p, VkDescriptorPool descriptorPool = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDescriptorPool descriptorPool = %p, uint32_t descriptorSetCount = %d, const VkDescriptorSet* pDescriptorSets = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDescriptorSet descriptorSet = %p, VkDescriptorUpdateTemplate descriptorUpdateTemplate = %p, const void* pData = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDescriptorSetLayout descriptorSetLayout = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDescriptorUpdateTemplate descriptorUpdateTemplate = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDeviceMemory memory = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDeviceMemory memory = %p, VkDeviceSize offset = %d, VkDeviceSize size = %d, VkMemoryMapFlags flags = %d, void** ppData = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDeviceMemory memory = %p, VkDeviceSize* pCommittedMemoryInBytes = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkDeviceMemory memory = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkEvent event = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkEvent event = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkExternalMemoryHandleTypeFlagBits handleType = %x, const void *pHostPointer = %p, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkExternalMemoryHandleTypeFlagBits handleType = %x, int fd = %d, VkMemoryFdPropertiesKHR* pMemoryFdProperties = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkFence fence = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkFence fence = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkFramebuffer framebuffer = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkImage image = %p, VkDeviceMemory memory = %p, VkDeviceSize memoryOffset = %d)\n
%s:%d TRACE: (VkDevice device = %p, VkImage image = %p, VkMemoryRequirements* pMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkImage image = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkImage image = %p, const VkImageSubresource* pSubresource = %p, VkSubresourceLayout* pLayout = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkImage image = %p, const VkImageSubresource2KHR* pSubresource = %p, VkSubresourceLayout2KHR* pLayout = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkImage image = %p, uint32_t* pSparseMemoryRequirementCount = %p, VkSparseImageMemoryRequirements* pSparseMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkImageView imageView = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkObjectType objectType = %d, uint64_t objectHandle = %lu, VkPrivateDataSlot privateDataSlot = %p, uint64_t data = %lu)\n
%s:%d TRACE: (VkDevice device = %p, VkObjectType objectType = %d, uint64_t objectHandle = %lu, VkPrivateDataSlot privateDataSlot = %p, uint64_t data = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPipeline pipeline = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPipelineCache dstCache = %p, uint32_t srcCacheCount = %d, const VkPipelineCache* pSrcCaches = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPipelineCache pipelineCache = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPipelineCache pipelineCache = %p, size_t* pDataSize = %p, void* pData = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPipelineCache pipelineCache = %p, uint32_t createInfoCount = %d, const VkComputePipelineCreateInfo* pCreateInfos = %p, const VkAllocationCallbacks* pAllocator = %p, VkPipeline* pPipelines = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPipelineCache pipelineCache = %p, uint32_t createInfoCount = %d, const VkGraphicsPipelineCreateInfo* pCreateInfos = %p, const VkAllocationCallbacks* pAllocator = %p, VkPipeline* pPipelines = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPipelineLayout pipelineLayout = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkPrivateDataSlot privateDataSlot = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkQueryPool queryPool = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkQueryPool queryPool = %p, uint32_t firstQuery = %d, uint32_t queryCount = %d)\n
%s:%d TRACE: (VkDevice device = %p, VkQueryPool queryPool = %p, uint32_t firstQuery = %d, uint32_t queryCount = %d, size_t dataSize = %d, void* pData = %p, VkDeviceSize stride = %d, VkQueryResultFlags flags = %d)\n
%s:%d TRACE: (VkDevice device = %p, VkRenderPass renderPass = %p, VkExtent2D* pGranularity = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkRenderPass renderPass = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSampler sampler = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSamplerYcbcrConversion ycbcrConversion = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSemaphore semaphore = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSemaphore semaphore = %p, uint64_t* pValue = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkShaderModule shaderModule = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSurfaceKHR surface = %p, VkDeviceGroupPresentModeFlagsKHR *pModes = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSwapchainKHR swapchain = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSwapchainKHR swapchain = %p, uint32_t* pSwapchainImageCount = %p, VkImage* pSwapchainImages = %p)\n
%s:%d TRACE: (VkDevice device = %p, VkSwapchainKHR swapchain = %p, uint64_t timeout = %lu, VkSemaphore semaphore = %p, VkFence fence = %p, uint32_t* pImageIndex = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkAcquireNextImageInfoKHR *pAcquireInfo = %p, uint32_t *pImageIndex = %p\n
%s:%d TRACE: (VkDevice device = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkBufferCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkBuffer* pBuffer = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkBufferDeviceAddressInfo* pInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkBufferMemoryRequirementsInfo2* pInfo = %p, VkMemoryRequirements2* pMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkBufferViewCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkBufferView* pView = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkCommandBufferAllocateInfo* pAllocateInfo = %p, VkCommandBuffer* pCommandBuffers = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkCommandPoolCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkCommandPool* pCommandPool = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDebugUtilsObjectNameInfoEXT* pNameInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDebugUtilsObjectTagInfoEXT* pTagInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDescriptorPoolCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkDescriptorPool* pDescriptorPool = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDescriptorSetAllocateInfo* pAllocateInfo = %p, VkDescriptorSet* pDescriptorSets = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDescriptorSetLayoutCreateInfo* pCreateInfo = %p, VkDescriptorSetLayoutSupport* pSupport = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDescriptorSetLayoutCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkDescriptorSetLayout* pSetLayout = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDeviceBufferMemoryRequirements* pInfo = %p, VkMemoryRequirements2* pMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDeviceImageMemoryRequirements* pInfo = %p, VkMemoryRequirements2* pMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDeviceImageMemoryRequirements* pInfo = %p, uint32_t* pSparseMemoryRequirementCount = %p, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkDeviceQueueInfo2* pQueueInfo = %p, VkQueue* pQueue = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkEventCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkEvent* pEvent = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkFenceCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkFence* pFence = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkFramebufferCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkFramebuffer* pFramebuffer = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkImageCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkImage* pImage = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkImageMemoryRequirementsInfo2* pInfo = %p, VkMemoryRequirements2* pMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkImageSparseMemoryRequirementsInfo2* pInfo = %p, uint32_t* pSparseMemoryRequirementCount = %p, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkImageViewCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkImageView* pView = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreInfo = %p\n
%s:%d TRACE: (VkDevice device = %p, const VkMemoryAllocateInfo* pAllocateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkDeviceMemory* pMemory = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkMemoryGetFdInfoKHR* getFdInfo = %p, int* pFd = %p\n
%s:%d TRACE: (VkDevice device = %p, const VkPipelineCacheCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkPipelineCache* pPipelineCache = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkPipelineLayoutCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkPipelineLayout* pPipelineLayout = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkPrivateDataSlotCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkPrivateDataSlot* pPrivateDataSlot = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkQueryPoolCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkQueryPool* pQueryPool = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkReleaseSwapchainImagesInfoEXT *pReleaseInfo = %p\n
%s:%d TRACE: (VkDevice device = %p, const VkRenderPassCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkRenderPass* pRenderPass = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkSamplerCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkSampler* pSampler = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkSamplerYcbcrConversion* pYcbcrConversion = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkSemaphoreCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkSemaphore* pSemaphore = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkSemaphoreGetFdInfoKHR* pGetFdInfo = %p, int* pFd = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkSemaphoreSignalInfo *pSignalInfo = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkSemaphoreWaitInfo *pWaitInfo = %p, uint64_t timeout = %lu)\n
%s:%d TRACE: (VkDevice device = %p, const VkShaderModuleCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkShaderModule* pShaderModule = %p)\n
%s:%d TRACE: (VkDevice device = %p, const VkSwapchainCreateInfoKHR* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkSwapchainKHR* pSwapchain = %p)\n
%s:%d TRACE: (VkDevice device = %p, const char* pName = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t bindInfoCount = %d, const VkBindBufferMemoryInfo* pBindInfos = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t bindInfoCount = %d, const VkBindImageMemoryInfo* pBindInfos = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t descriptorWriteCount = %d, const VkWriteDescriptorSet* pDescriptorWrites = %p, uint32_t descriptorCopyCount = %d, const VkCopyDescriptorSet* pDescriptorCopies = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t fenceCount = %d, const VkFence* pFences = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t fenceCount = %d, const VkFence* pFences = %p, VkBool32 waitAll = %d, uint64_t timeout = %lu)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t heapIndex = %d, uint32_t localDeviceIndex = %d, uint32_t remoteDeviceIndex = %d, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t memoryRangeCount = %d, const VkMappedMemoryRange* pMemoryRanges = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t queueFamilyIndex = %d, uint32_t queueIndex = %d, VkQueue* pQueue = %p)\n
%s:%d TRACE: (VkDevice device = %p, uint32_t transitionCount = %u, const VkHostImageLayoutTransitionInfoEXT* pTransitions = %p)\n
%s:%d TRACE: (VkInstance instance = %p, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity = %d, VkDebugUtilsMessageTypeFlagsEXT messageTypes = %d, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData = %p)\n
%s:%d TRACE: (VkInstance instance = %p, VkDebugUtilsMessengerEXT messenger = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkInstance instance = %p, VkHeadlessSurfaceCreateInfoEXT* pCreateInfo = %p, VkAllocationCallbacks* pAllocator = %p, VkSurface* pSurface = %p)\n
%s:%d TRACE: (VkInstance instance = %p, VkSurfaceKHR surface = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkInstance instance = %p, VkWaylandSurfaceCreateInfoKHR* pCreateInfo = %p, VkAllocationCallbacks* pAllocator = %p, VkSurface* pSurface = %p)\n
%s:%d TRACE: (VkInstance instance = %p, VkXcbSurfaceCreateInfoKHR* pCreateInfo = %p, VkAllocationCallbacks* pAllocator = %p, VkSurface* pSurface = %p)\n
%s:%d TRACE: (VkInstance instance = %p, const VkAllocationCallbacks* pAllocator = %p)\n
%s:%d TRACE: (VkInstance instance = %p, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkDebugUtilsMessengerEXT* pMessenger = %p)\n
%s:%d TRACE: (VkInstance instance = %p, const char* pName = %p)\n
%s:%d TRACE: (VkInstance instance = %p, uint32_t* pPhysicalDeviceCount = %p, VkPhysicalDevice* pPhysicalDevices = %p)\n
%s:%d TRACE: (VkInstance instance = %p, uint32_t* pPhysicalDeviceGroupCount = %p, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkFormat format = %d, VkFormatProperties2* pFormatProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkFormat format = %d, VkImageType type = %d, VkImageTiling tiling = %d, VkImageUsageFlags usage = %d, VkImageCreateFlags flags = %d, VkImageFormatProperties* pImageFormatProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkFormat format = %d, VkImageType type = %d, VkSampleCountFlagBits samples = %d, VkImageUsageFlags usage = %d, VkImageTiling tiling = %d, uint32_t* pPropertyCount = %p, VkSparseImageFormatProperties* pProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkPhysicalDeviceFeatures* pFeatures = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkPhysicalDeviceFeatures2* pFeatures = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkPhysicalDeviceMemoryProperties* pMemoryProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkPhysicalDeviceMemoryProperties2* pMemoryProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkPhysicalDeviceProperties* pProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkPhysicalDeviceProperties2* pProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo = %p. uint32_t* pSurfaceFormatCount = %p, VkSurfaceFormat2KHR* pSurfaceFormats = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkSurfaceKHR surface = %p uint32_t* pPresentModeCount = %p, VkPresentModeKHR* pPresentModes = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkSurfaceKHR surface = %p, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkSurfaceKHR surface = %p, uint32_t* pRectCount = %p, VkRect2D* pRects = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, VkSurfaceKHR surface = %p. uint32_t* pSurfaceFormatCount = %p, VkSurfaceFormatKHR* pSurfaceFormats = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const VkDeviceCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkDevice* pDevice = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo = %p, VkExternalBufferProperties* pExternalBufferProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo = %p, VkExternalFenceProperties* pExternalFenceProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo = %p, VkExternalSemaphoreProperties* pExternalSemaphoreProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo = %p, VkImageFormatProperties2* pImageFormatProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo = %p, uint32_t* pPropertyCount = %p, VkSparseImageFormatProperties2* pProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo = %p, VkSurfaceCapabilities2KHR *pSurfaceCapabilities = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, const char* pLayerName, uint32_t* pPropertyCount = %p, VkExtensionProperties* pProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, uint32_t queueFamilyIndex = %d, VkSurface surface = %p, VKBool32* pSupported = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, uint32_t queueFamilyIndex = %d, struct wl_display* display = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, uint32_t queueFamilyIndex = %d, xcb_connection_t* connection = %p, xcb_visualid_t visual_id = %d)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, uint32_t* pPropertyCount = %p, VkLayerProperties* pProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, uint32_t* pQueueFamilyPropertyCount = %p, VkQueueFamilyProperties* pQueueFamilyProperties = %p))\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, uint32_t* pQueueFamilyPropertyCount = %p, VkQueueFamilyProperties2* pQueueFamilyProperties = %p)\n
%s:%d TRACE: (VkPhysicalDevice physicalDevice = %p, uint32_t* pToolCount = %p, VkPhysicalDeviceToolProperties* pToolProperties = %p)\n
%s:%d TRACE: (VkQueue queue = %p)\n
%s:%d TRACE: (VkQueue queue = %p, const VkDebugUtilsLabelEXT* pLabelInfo = %p)\n
%s:%d TRACE: (VkQueue queue = %p, const VkPresentInfoKHR* pPresentInfo = %p)\n
%s:%d TRACE: (VkQueue queue = %p, uint32_t submitCount = %d, const VkSubmitInfo* pSubmits = %p, VkFence fence = %p)\n
%s:%d TRACE: (VkQueue queue = %p, uint32_t submitCount = %d, const VkSubmitInfo2* pSubmits = %p, VkFence fence = %p)\n
%s:%d TRACE: (const VkInstanceCreateInfo* pCreateInfo = %p, const VkAllocationCallbacks* pAllocator = %p, VkInstance* pInstance = %p)\n
%s:%d TRACE: (const char* pLayerName = %p, uint32_t* pPropertyCount = %p, VkExtensionProperties* pProperties = %p)\n
%s:%d TRACE: (uint32_t* pApiVersion = %p)\n
%s:%d TRACE: (uint32_t* pPropertyCount = %p, VkLayerProperties* pProperties = %p)\n
%s:%d TRACE: Cannot export semaphore as opaque FD (exportableHandleType = 0x%08X, want 0x%08X)\n
%s:%d TRACE: Cannot export semaphore with a temporary import!\n
%s:%d TRACE: GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice = %p, VkFormat format = %d, VkFormatProperties* pFormatProperties = %p)\n
%s:%d TRACE: LinuxMemFd::close() failed with: %s\n
%s:%d TRACE: ftruncate() %lld returned %d: %s\n
%s:%d TRACE: memfd.allocate() returned %s\n
%s:%d TRACE: memfd_create() returned %d: %s\n
%s:%d TRACE: mmap() failed: %s\n
%s:%d WARNING: SPIR-V string literal was not null-terminated\n
%s:%d WARNING: UNIMPLEMENTED: b/141246700: Function block instruction %d : %s\n
%s:%d WARNING: UNIMPLEMENTED: b/141246700: Function block number of instructions: %d\n
%s:%d WARNING: UNIMPLEMENTED: b/148241854: Non-constant initializers not yet implemented\n
%s:%d WARNING: UNIMPLEMENTED: b/148242443: layerCount != 1\n
%s:%d WARNING: UNIMPLEMENTED: b/148242443: levelCount != 1\n
%s:%d WARNING: UNIMPLEMENTED: b/176819536\n
%s:%d WARNING: UNREACHABLE: %s should have already been lowered.\n
%s:%d WARNING: UNREACHABLE: %s\n
%s:%d WARNING: UNREACHABLE: EvalSpecConstantBinaryOp op: %s\n
%s:%d WARNING: UNREACHABLE: EvalSpecConstantUnaryOp op: %s\n
%s:%d WARNING: UNREACHABLE: Execution mode: %d\n
%s:%d WARNING: UNREACHABLE: ExtInst %d\n
%s:%d WARNING: UNREACHABLE: Failed to find executable section that matches input function names\n
%s:%d WARNING: UNREACHABLE: Format: %s\n
%s:%d WARNING: UNREACHABLE: GLSLstd450Determinant can only operate with square matrices. Got %d elements\n
%s:%d WARNING: UNREACHABLE: GLSLstd450IMix has been removed from the specification\n
%s:%d WARNING: UNREACHABLE: GLSLstd450MatrixInverse can only operate with square matrices. Got %d elements\n
%s:%d WARNING: UNREACHABLE: Image descriptorType: %d\n
%s:%d WARNING: UNREACHABLE: Invalid component\n
%s:%d WARNING: UNREACHABLE: Invalid pointer kind %d\n
%s:%d WARNING: UNREACHABLE: MemorySemanticsMask: %x\n
%s:%d WARNING: UNREACHABLE: Not possible until we have multiple bit widths\n
%s:%d WARNING: UNREACHABLE: RValue<Float4> RcpApprox()\n
%s:%d WARNING: UNREACHABLE: RValue<Float4> RcpSqrtApprox()\n
%s:%d WARNING: UNREACHABLE: RValue<Float> RcpApprox()\n
%s:%d WARNING: UNREACHABLE: Sampler function %d\n
%s:%d WARNING: UNREACHABLE: Scope for execution must be limited to Workgroup or Subgroup\n
%s:%d WARNING: UNREACHABLE: Storage class %d\n
%s:%d WARNING: UNREACHABLE: Unexpected Block Kind: %d\n
%s:%d WARNING: UNREACHABLE: Unexpected Extension name %d\n
%s:%d WARNING: UNREACHABLE: Unexpected StorageClass %d\n
%s:%d WARNING: UNREACHABLE: Unknown Extension::Name<%d>\n
%s:%d WARNING: UNREACHABLE: Unknown Optimization Level %d\n
%s:%d WARNING: UNREACHABLE: Unknown constant vector type: %d\n
%s:%d WARNING: UNREACHABLE: Unknown interpolation type: %d\n
%s:%d WARNING: UNREACHABLE: Unknown non-terminal instruction %s\n
%s:%d WARNING: UNREACHABLE: Unknown terminal instruction %s\n
%s:%d WARNING: UNREACHABLE: VkImageType: %d\n
%s:%d WARNING: UNREACHABLE: addressingMode %d\n
%s:%d WARNING: UNREACHABLE: task.type %d\n
%s:%d WARNING: UNREACHABLE: texelSize: %d\n
%s:%d WARNING: UNREACHABLE: unknown affinity policy\n
%s:%d WARNING: UNREACHABLE: usage %d\n
%s:%d WARNING: UNSUPPORTED: %s\n
%s:%d WARNING: UNSUPPORTED: Blitter destination format %d\n
%s:%d WARNING: UNSUPPORTED: Blitter source format %d\n
%s:%d WARNING: UNSUPPORTED: Compressed format %d\n
%s:%d WARNING: UNSUPPORTED: Cube doesn't have square faces : (%d, %d)\n
%s:%d WARNING: UNSUPPORTED: Depth format: %d\n
%s:%d WARNING: UNSUPPORTED: EmitGroupNonUniform op: %s\n
%s:%d WARNING: UNSUPPORTED: EvalSpecConstantOp op: %s\n
%s:%d WARNING: UNSUPPORTED: ExecutionModel: %d\n
%s:%d WARNING: UNSUPPORTED: Format %d\n
%s:%d WARNING: UNSUPPORTED: Format: %d\n
%s:%d WARNING: UNSUPPORTED: Group operation: %d\n
%s:%d WARNING: UNSUPPORTED: GroupOperation %d\n
%s:%d WARNING: UNSUPPORTED: Image operands 0x%08X\n
%s:%d WARNING: UNSUPPORTED: SPIR-V Extension: %s\n
%s:%d WARNING: UNSUPPORTED: SPIR-V Float16 or Float64 Capability (OpFConvert)\n
%s:%d WARNING: UNSUPPORTED: SPIR-V Float64 Capability (GLSLstd450PackDouble2x32)\n
%s:%d WARNING: UNSUPPORTED: SPIR-V Float64 Capability (GLSLstd450UnpackDouble2x32)\n
%s:%d WARNING: UNSUPPORTED: SPIR-V GenericPointer Capability (StorageClassGeneric)\n
%s:%d WARNING: UNSUPPORTED: SPIR-V ImageFormat %u\n
%s:%d WARNING: UNSUPPORTED: SPIR-V Int16 or Int64 Capability (OpSConvert)\n
%s:%d WARNING: UNSUPPORTED: SPIR-V Int16 or Int64 Capability (OpUConvert)\n
%s:%d WARNING: UNSUPPORTED: SPIR-V OpenCL Execution Model (StorageClassCrossWorkgroup)\n
%s:%d WARNING: UNSUPPORTED: SPIR-V does not define a OpGroupNonUniformQuadSwap result for a direction of %d\n
%s:%d WARNING: UNSUPPORTED: Sample count %d\n
%s:%d WARNING: UNSUPPORTED: Samples: %d\n
%s:%d WARNING: UNSUPPORTED: StorageClass %d not yet supported\n
%s:%d WARNING: UNSUPPORTED: Unknown integer pragma option %d\n
%s:%d WARNING: UNSUPPORTED: Unknown semaphore type\n
%s:%d WARNING: UNSUPPORTED: Unsupported Descriptor Type: %d\n
%s:%d WARNING: UNSUPPORTED: Unsupported advanced VkBlendOp: %d\n
%s:%d WARNING: UNSUPPORTED: Unsupported capability %u\n
%s:%d WARNING: UNSUPPORTED: Unsupported robustness behavior\n
%s:%d WARNING: UNSUPPORTED: Unsupported sample count\n
%s:%d WARNING: UNSUPPORTED: Unsupported stage\n
%s:%d WARNING: UNSUPPORTED: VK_KHR_draw_indirect_count\n
%s:%d WARNING: UNSUPPORTED: VkBlendFactor: %d\n
%s:%d WARNING: UNSUPPORTED: VkBlendOp: %d\n
%s:%d WARNING: UNSUPPORTED: VkCompareOp: %d\n
%s:%d WARNING: UNSUPPORTED: VkComponentSwizzle %d\n
%s:%d WARNING: UNSUPPORTED: VkDynamicState %d\n
%s:%d WARNING: UNSUPPORTED: VkExportMemoryAllocateInfo::handleTypes %d\n
%s:%d WARNING: UNSUPPORTED: VkFormat %d\n
%s:%d WARNING: UNSUPPORTED: VkFormat: %d\n
%s:%d WARNING: UNSUPPORTED: VkImageTiling %d\n
%s:%d WARNING: UNSUPPORTED: VkImageViewType %d\n
%s:%d WARNING: UNSUPPORTED: VkImportMemoryFdInfoKHR::handleType %d\n
%s:%d WARNING: UNSUPPORTED: VkIndexType %d\n
%s:%d WARNING: UNSUPPORTED: VkPhysicalDeviceFeatures::alphaToOne\n
%s:%d WARNING: UNSUPPORTED: VkPhysicalDeviceFeatures::inheritedQueries\n
%s:%d WARNING: UNSUPPORTED: VkPhysicalDeviceFeatures::logicOp\n
%s:%d WARNING: UNSUPPORTED: VkPhysicalDeviceFeatures::multiViewport\n
%s:%d WARNING: UNSUPPORTED: VkPhysicalDeviceFeatures::pipelineStatisticsQuery\n
%s:%d WARNING: UNSUPPORTED: VkPhysicalDeviceVulkan11Features::protectedMemory\n
%s:%d WARNING: UNSUPPORTED: VkPipelineBindPoint %d\n
%s:%d WARNING: UNSUPPORTED: VkPrimitiveTopology %d\n
%s:%d WARNING: UNSUPPORTED: VkRenderPassCreateInfo2KHR->subpass[%d]->pNext sType: %s\n
%s:%d WARNING: UNSUPPORTED: VkStencilOp: %d\n
%s:%d WARNING: UNSUPPORTED: addressMode %d\n
%s:%d WARNING: UNSUPPORTED: aspect %x\n
%s:%d WARNING: UNSUPPORTED: aspectMask %X\n
%s:%d WARNING: UNSUPPORTED: aspectMask %x\n
%s:%d WARNING: UNSUPPORTED: attachment.aspectMask %X\n
%s:%d WARNING: UNSUPPORTED: attachment.loadOp %d\n
%s:%d WARNING: UNSUPPORTED: attachment.stencilLoadOp %d\n
%s:%d WARNING: UNSUPPORTED: colorBlendState->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: colorBlendState->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: coordinateIndex: %d\n
%s:%d WARNING: UNSUPPORTED: curExtension->sType: %s\n
%s:%d WARNING: UNSUPPORTED: depthStencilState->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: descriptor type %u\n
%s:%d WARNING: UNSUPPORTED: dstSubresource.aspectMask %X\n
%s:%d WARNING: UNSUPPORTED: dynamicStateCreateInfo->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: enabledLayerCount\n
%s:%d WARNING: UNSUPPORTED: exportInfo->handleTypes 0x%08X (supports 0x%08X)\n
%s:%d WARNING: UNSUPPORTED: extendedAllocationInfo->exportMemoryAllocateInfo->handleTypes %u\n
%s:%d WARNING: UNSUPPORTED: extendedAllocationInfo->importMemoryFdInfo->handleType %u\n
%s:%d WARNING: UNSUPPORTED: extendedAllocationInfo->importMemoryHostPointerInfo->handleType %u\n
%s:%d WARNING: UNSUPPORTED: extendedAllocationInfo.importMemoryHostPointerInfo->handleType, %d\n
%s:%d WARNING: UNSUPPORTED: flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: format %d\n
%s:%d WARNING: UNSUPPORTED: format: %d\n
%s:%d WARNING: UNSUPPORTED: handleType %u\n
%s:%d WARNING: UNSUPPORTED: imageViewType %d\n
%s:%d WARNING: UNSUPPORTED: layoutInfo->sType = %s\n
%s:%d WARNING: UNSUPPORTED: layoutSupport->sType = %s\n
%s:%d WARNING: UNSUPPORTED: magFilter %d\n
%s:%d WARNING: UNSUPPORTED: minFilter %d\n
%s:%d WARNING: UNSUPPORTED: mipmapMode %d\n
%s:%d WARNING: UNSUPPORTED: pAllocateInfo->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pBeginInfo->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pBindInfos[%d].pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->enabledLayerCount != 0\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pInputAssemblyState->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pMultisampleState->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pNext->sType = %s\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pQueueCreateInfos[%d]->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pQueueCreateInfos[%d].pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pRasterizationState->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pRasterizationState->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pViewportState->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->pViewportState->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pCreateInfo->templateType %d\n
%s:%d WARNING: UNSUPPORTED: pFormatProperties->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pFramebufferCreateInfo->pNext->sType = %s\n
%s:%d WARNING: UNSUPPORTED: pGetFdInfo->handleType %d\n
%s:%d WARNING: UNSUPPORTED: pGetFdInfo->handleType %u\n
%s:%d WARNING: UNSUPPORTED: pImageFormatInfo->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pImageFormatProperties->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pImportSemaphoreInfo->handleType %d\n
%s:%d WARNING: UNSUPPORTED: pInfo->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pLayout->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pMemoryProperties->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pMemoryRequirements->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pProperties->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pQueueFamilyProperties->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pQueueInfo->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pRenderPassBegin->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pSparseMemoryRequirements->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pStage->flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: pSupport->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: pSurfaceCapabilities->pNext sType = %s\n
%s:%d WARNING: UNSUPPORTED: polygon mode: %d\n
%s:%d WARNING: UNSUPPORTED: remoteDeviceIndex: %d\n
%s:%d WARNING: UNSUPPORTED: sint/uint/sfloat border: %u\n
%s:%d WARNING: UNSUPPORTED: srcSubresource.aspectMask %X\n
%s:%d WARNING: UNSUPPORTED: state.textureFormat %d\n
%s:%d WARNING: UNSUPPORTED: stream.format %d\n
%s:%d WARNING: UNSUPPORTED: submitInfo[%d]->pNext sType: %s\n
%s:%d WARNING: UNSUPPORTED: topology %d\n
%s:%d WARNING: UNSUPPORTED: vertexInputState->flags\n
%s:%d WARNING: UNSUPPORTED: vkBindBufferMemory with invalid external memory\n
%s:%d WARNING: UNSUPPORTED: vkBindBufferMemory2 with invalid external memory\n
%s:%d WARNING: UNSUPPORTED: vkBindImageMemory with invalid external memory\n
%s:%d WARNING: UNSUPPORTED: vkBindImageMemory2 with invalid external memory\n
%s:%d WARNING: UNSUPPORTED: vkCmdBeginQuery::flags 0x%08X\n
%s:%d WARNING: UNSUPPORTED: vkQueueBindSparse\n
%s:%d WARNING: UNSUPPORTED: ycbcrModel %d\n
%s:%d WARNING: nextInfo->sType = %s\n
%s:%d WARNING: vkCmdSetLineStippleEXT: line stipple pattern ignored : 0x%04X\n
' could not be inlined because the return instruction is not at the end of the function. This could be fixed by running merge-return before inlining.
' decorated with 
' decorated with both 
' is invalid value for boolean argument! Try 0 or 1
' is missing Binding decoration.\n
' is missing Block decoration.\n
' is missing Block or BufferBlock decoration.\n
' is missing DescriptorSet decoration.\n
' is not valid for the Vulkan execution environment.
' must be less than the ID bound '
' registered more than once!\n
' uses more than one PushConstant interface.\n
' value invalid for integer argument!
' value invalid for uint argument!
', member '
'. This structure has 
'Target Label' operands for OpBranch must be the ID of an OpLabel instruction
'Target Label' operands for OpSwitch must be IDs of an OpLabel instruction
(except for OpLine, which can be mixed with OpPhi).
) can only be formed between a block and a loop header.
) cannot be applied to function id 
) cannot have any Location or Component decorations
) does not match block's predecessor count (
) does not match the type that results from indexing into the Composite (Op
) does not match the type that results from indexing into the base <id> (Op
) does not match the type that results from indexing into the composite (Op
) exceeds the limit (
) has exceeded the limit (
) has no register assigned - function 
) may not be decorated with Import Linkage type.
) may not be targeted by both an OpEntryPoint instruction and an OpFunctionCall instruction.
) must have a LinkageAttributes decoration with the Import Linkage type.
) requires SPIR-V version 
) requires one of these extensions: 
) used for OpTypeFloat.
) used for OpTypeInt.
), words(
*no default*
, OpTypeRuntimeArray must only be used for the last member of an OpTypeStruct
, OpTypeStruct containing an OpTypeRuntimeArray 
, OpTypeStruct must not contain an opaque type.
, but does not immediately precede it in the OpSwitch's target list
, but is not contained in the associated loop construct 
, but its merge block 
, but not via a structured exit
, but parsed version is 
, but with an element size of 
, component 
, has a disallowed initializer & storage class 
, if you are creating a new source language please use value 0 (Unknown) and when ready, add your source language to SPRIV-Headers
, initializer are not allowed for HitObjectAttributeNV
, initializer are not allowed for Input
, initializer are not allowed for TaskPayloadWorkgroupEXT
, initializers are limited to OpConstantNull in Workgroup storage class
, is attempting to create memory for an illegal type, 
, since it is not specified as taking an 
, which cannot be used with the current execution model:\n
, which cannot be used with the current execution modes:\n
, zero found
-bit float literals
-bit integer for the addressing model used in the module)
-bit integer literals
. This may be a bug in the validator.
../../third_party/libc++/src/include/__algorithm/pop_heap.h:40: assertion __len > 0 failed: The heap given to pop_heap must be non-empty\n
../../third_party/libc++/src/include/__algorithm/sort.h:333: assertion __k != __leftmost failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:643: assertion __first != __end failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:655: assertion __last != __begin failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:673: assertion __first != __end failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:678: assertion __last != __begin failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:710: assertion __first != __end failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:723: assertion __last != __begin failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:733: assertion __first != __end failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__algorithm/sort.h:738: assertion __last != __begin failed: Would read out of bounds, does your comparator satisfy the strict-weak ordering requirement?\n
../../third_party/libc++/src/include/__hash_table:1830: assertion __p != end() failed: unordered container::erase(iterator) called with a non-dereferenceable iterator\n
../../third_party/libc++/src/include/__hash_table:292: assertion __node_ != nullptr failed: Attempted to dereference a non-dereferenceable unordered container iterator\n
../../third_party/libc++/src/include/__hash_table:355: assertion __node_ != nullptr failed: Attempted to dereference a non-dereferenceable unordered container const_iterator\n
../../third_party/libc++/src/include/__hash_table:360: assertion __node_ != nullptr failed: Attempted to dereference a non-dereferenceable unordered container const_iterator\n
../../third_party/libc++/src/include/__hash_table:366: assertion __node_ != nullptr failed: Attempted to increment a non-incrementable unordered container const_iterator\n
../../third_party/libc++/src/include/__memory/construct_at.h:40: assertion __location != nullptr failed: null pointer given to construct_at\n
../../third_party/libc++/src/include/__memory/construct_at.h:66: assertion __loc != nullptr failed: null pointer given to destroy_at\n
../../third_party/libc++/src/include/__string/char_traits.h:145: assertion !std::__is_pointer_in_range(__s1, __s1 + __n, __s2) failed: char_traits::copy: source and destination ranges overlap\n
../../third_party/libc++/src/include/__string/char_traits.h:222: assertion !std::__is_pointer_in_range(__s1, __s1 + __n, __s2) failed: char_traits::copy: source and destination ranges overlap\n
../../third_party/libc++/src/include/array:239: assertion __n < _Size failed: out-of-bounds access in std::array<T, N>\n
../../third_party/libc++/src/include/array:243: assertion __n < _Size failed: out-of-bounds access in std::array<T, N>\n
../../third_party/libc++/src/include/deque:1519: assertion !empty() failed: deque::front called on an empty deque\n
../../third_party/libc++/src/include/deque:2262: assertion !empty() failed: deque::pop_front called on an empty deque\n
../../third_party/libc++/src/include/deque:2276: assertion !empty() failed: deque::pop_back called on an empty deque\n
../../third_party/libc++/src/include/fstream:764: assertion __extbufnext_ != nullptr failed: underflow moving from nullptr\n
../../third_party/libc++/src/include/fstream:765: assertion __extbuf_ != nullptr failed: underflow moving into nullptr\n
../../third_party/libc++/src/include/list:1440: assertion this != std::addressof(__c) failed: list::splice(iterator, list) called with this == &list\n
../../third_party/libc++/src/include/list:791: assertion !empty() failed: list::back called on empty list\n
../../third_party/libc++/src/include/optional:790: assertion this->has_value() failed: optional operator-> called on a disengaged value\n
../../third_party/libc++/src/include/string:1241: assertion __pos <= size() failed: string index out of bounds\n
../../third_party/libc++/src/include/string:1249: assertion __pos <= size() failed: string index out of bounds\n
../../third_party/libc++/src/include/string:1359: assertion !empty() failed: string::back(): string is empty\n
../../third_party/libc++/src/include/string:2730: assertion __n == 0 || __s != nullptr failed: string::append received nullptr\n
../../third_party/libc++/src/include/string:2862: assertion __s != nullptr failed: string::append received nullptr\n
../../third_party/libc++/src/include/string:2871: assertion __n == 0 || __s != nullptr failed: string::insert received nullptr\n
../../third_party/libc++/src/include/string:2984: assertion __s != nullptr failed: string::insert received nullptr\n
../../third_party/libc++/src/include/string:3170: assertion __first <= __last failed: string::erase(first, last) called with invalid range\n
../../third_party/libc++/src/include/string:3179: assertion !empty() failed: string::pop_back(): string is already empty\n
../../third_party/libc++/src/include/string:3380: assertion __s != nullptr failed: string::find(): received nullptr\n
../../third_party/libc++/src/include/string:3458: assertion __s != nullptr failed: string::find_first_of(): received nullptr\n
../../third_party/libc++/src/include/string:3498: assertion __s != nullptr failed: string::find_last_of(): received nullptr\n
../../third_party/libc++/src/include/string:3667: assertion __s != nullptr failed: string::compare(): received nullptr\n
../../third_party/libc++/src/include/string:3674: assertion __s != nullptr failed: string::compare(): received nullptr\n
../../third_party/libc++/src/include/string:973: assertion __s != nullptr failed: basic_string(const char*) detected nullptr\n
../../third_party/libc++/src/include/string_view:268: assertion __s != nullptr failed: null pointer passed to non-null argument of char_traits<...>::length\n
../../third_party/libc++/src/include/string_view:318: assertion __len <= static_cast<size_type>(numeric_limits<difference_type>::max()) failed: string_view::string_view(_CharT *, size_t): length does not fit in difference_type\n
../../third_party/libc++/src/include/string_view:320: assertion __len == 0 || __s != nullptr failed: string_view::string_view(_CharT *, size_t): received nullptr\n
../../third_party/libc++/src/include/string_view:330: assertion (__end - __begin) >= 0 failed: std::string_view::string_view(iterator, sentinel) received invalid range\n
../../third_party/libc++/src/include/vector:1411: assertion __n < size() failed: vector[] index out of bounds\n
../../third_party/libc++/src/include/vector:1418: assertion __n < size() failed: vector[] index out of bounds\n
../../third_party/libc++/src/include/vector:1539: assertion !empty() failed: vector::pop_back called on an empty vector\n
../../third_party/libc++/src/include/vector:1547: assertion __position != end() failed: vector::erase(iterator) called with a non-dereferenceable iterator\n
../../third_party/libc++/src/include/vector:1557: assertion __first <= __last failed: vector::erase(first, last) called with invalid range\n
../../third_party/libc++/src/include/vector:614: assertion !empty() failed: front() called on an empty vector\n
../../third_party/libc++/src/include/vector:618: assertion !empty() failed: front() called on an empty vector\n
../../third_party/libc++/src/include/vector:622: assertion !empty() failed: back() called on an empty vector\n
../../third_party/libc++/src/include/vector:626: assertion !empty() failed: back() called on an empty vector\n
../../third_party/libc++/src/src/mutex.cpp:40: assertion ec == 0 failed: call to mutex::unlock failed. A possible reason is that the mutex wasn't locked\n
../../third_party/libc++/src/src/mutex.cpp:54: assertion e == 0 failed: call to ~recursive_mutex() failed\n
../../third_party/libc++/src/src/mutex.cpp:67: assertion e == 0 failed: call to recursive_mutex::unlock() failed. A possible reason is that the mutex wasn't locked\n
../../third_party/libc++abi/src/src/fallback_malloc.cpp
../../third_party/libc++abi/src/src/private_typeinfo.cpp
../../third_party/swiftshader/src/Device/Blitter.cpp
../../third_party/swiftshader/src/Device/Context.cpp
../../third_party/swiftshader/src/Device/Renderer.cpp
../../third_party/swiftshader/src/Device/Sampler.hpp
../../third_party/swiftshader/src/Pipeline/PixelProgram.cpp
../../third_party/swiftshader/src/Pipeline/PixelRoutine.cpp
../../third_party/swiftshader/src/Pipeline/SamplerCore.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShader.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShader.hpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderArithmetic.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderControlFlow.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderGLSLstd450.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderGroup.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderImage.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderMemory.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderSampling.cpp
../../third_party/swiftshader/src/Pipeline/SpirvShaderSpec.cpp
../../third_party/swiftshader/src/Pipeline/VertexRoutine.cpp
../../third_party/swiftshader/src/Reactor/Pragma.cpp
../../third_party/swiftshader/src/Reactor/SubzeroReactor.cpp
../../third_party/swiftshader/src/System/Linux/MemFd.cpp
../../third_party/swiftshader/src/System/SwiftConfig.cpp
../../third_party/swiftshader/src/Vulkan/VkCommandBuffer.cpp
../../third_party/swiftshader/src/Vulkan/VkDescriptorSetLayout.cpp
../../third_party/swiftshader/src/Vulkan/VkDevice.cpp
../../third_party/swiftshader/src/Vulkan/VkDeviceMemory.cpp
../../third_party/swiftshader/src/Vulkan/VkDeviceMemoryExternalHost.cpp
../../third_party/swiftshader/src/Vulkan/VkDeviceMemoryExternalLinux.hpp
../../third_party/swiftshader/src/Vulkan/VkFormat.cpp
../../third_party/swiftshader/src/Vulkan/VkFramebuffer.cpp
../../third_party/swiftshader/src/Vulkan/VkImage.cpp
../../third_party/swiftshader/src/Vulkan/VkImageView.cpp
../../third_party/swiftshader/src/Vulkan/VkImageView.hpp
../../third_party/swiftshader/src/Vulkan/VkPhysicalDevice.cpp
../../third_party/swiftshader/src/Vulkan/VkPipeline.cpp
../../third_party/swiftshader/src/Vulkan/VkQueryPool.cpp
../../third_party/swiftshader/src/Vulkan/VkQueue.cpp
../../third_party/swiftshader/src/Vulkan/VkRenderPass.cpp
../../third_party/swiftshader/src/Vulkan/VkSemaphore.cpp
../../third_party/swiftshader/src/Vulkan/VkSemaphoreExternalLinux.hpp
../../third_party/swiftshader/src/Vulkan/VkStructConversion.hpp
../../third_party/swiftshader/src/Vulkan/libVulkan.cpp
../../third_party/swiftshader/src/WSI/VkSurfaceKHR.cpp
.bss
.data
.data.rel.ro
.p2align
.rel
.rela
.rodata
.rodata.cst
.shstrtab
.strtab
.symtab
.text
0000000000000000
00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899NSt4__Cr14error_categoryE
0123456789
0123456789abcdefABCDEFxX+-pPiInN
16-bit or 32-bit 
2 Entry points cannot share the same name and ExecutionMode.
64-bits unsigned integer scalar type
8- or 16-bit loads must be a scalar, vector or matrix type
8- or 16-bit stores must be a scalar, vector or matrix type
8- or 16-bit types can only be used with width-only conversions
: 64-bit atomics require the Int64Atomics capability
: CommandLine Error: Option '
: Component Count must be 
: Component Count must be 32-bit integer OpConstant
: Component Count must be positive 
: Execution scope is limited to Subgroup or Workgroup
: Function storage class forbidden when the Shader capability is declared.
: MakeAvailableKHR Memory Semantics also requires either Release or AcquireRelease Memory Semantics
: MakeVisibleKHR Memory Semantics also requires either Acquire or AcquireRelease Memory Semantics
: Memory Scope QueueFamilyKHR requires capability 
: Memory Semantics MakeAvailableKHR requires capability 
: Memory Semantics MakeVisibleKHR requires capability 
: Memory Semantics OutputMemoryKHR requires capability 
: Memory Semantics Release and AcquireRelease cannot be used for operand Unequal
: Memory Semantics UniformMemory requires capability Shader
: Memory Semantics Volatile requires capability VulkanMemoryModelKHR
: Memory Semantics can have at most one of the following bits set: Acquire, Release, AcquireRelease or SequentiallyConsistent
: Missing symbol mentioned in reloc
: Vector Count must be 32-bit integer OpConstant
: Vector Count must be positive 
: Vulkan spec only allows storage classes for atomic to be: Uniform, Workgroup, Image, StorageBuffer, PhysicalStorageBuffer or TaskPayloadWorkgroupEXT.
: Vulkan specification requires Memory Semantics to be None if used with Invocation Memory Scope
: Vulkan specification requires Memory Semantics to have one of the following bits set: Acquire, Release, AcquireRelease or SequentiallyConsistent
: can't specify both Aliased and Restrict for PhysicalStorageBuffer pointer.
: can't specify both AliasedPointer and 
: can't specify both AliasedPointer and RestrictPointer for PhysicalStorageBuffer pointer.
: expected 
: expected Aliased or Restrict for PhysicalStorageBuffer pointer.
: expected AliasedPointer or RestrictPointer for 
: expected AliasedPointer or RestrictPointer for PhysicalStorageBuffer pointer.
: expected Comparator to be of type Result Type
: expected Memory Semantics to be a 32-bit int
: expected Memory Semantics to include a Vulkan-supported storage class
: expected Memory Semantics to include a Vulkan-supported storage class if Memory Semantics is not None
: expected Memory Semantics to include a storage class
: expected Named Barrier to be of type OpTypeNamedBarrier
: expected Pointer to be a pointer to integer or float 
: expected Pointer to be of type OpTypePointer
: expected Pointer to point to a value of 32-bit integer type
: expected Pointer to point to a value of type Result Type
: expected Result Type to be OpTypeNamedBarrier
: expected Result Type to be bool scalar type
: expected Result Type to be float scalar type
: expected Result Type to be integer or float scalar type
: expected Result Type to be integer scalar type
: expected Result Type to be void
: expected Stream to be constant instruction
: expected Stream to be int scalar
: expected Subgroup Count to be a 32-bit int
: expected Value to be of type Result Type
: expected Value type and the type pointed to by Pointer to be the same
: expected more operands after 
: expected no more operands after 
: expected operand 
: expected operand Indexes is 
: expected operand Size is a 
: expected scope to be a 32-bit int
: float add atomics require the AtomicFloat32AddEXT capability
: float add atomics require the AtomicFloat64AddEXT capability
: float min/max atomics require the AtomicFloat16MinMaxEXT capability
: float min/max atomics require the AtomicFloat32MinMaxEXT capability
: float min/max atomics require the AtomicFloat64MinMaxEXT capability
: float vector atomics require the AtomicFloat16VectorNV capability
: for the -
: in Vulkan 1.0 environment Memory Scope is can not be Subgroup without SubgroupBallotKHR or SubgroupVoteKHR declared
: in Vulkan environment Execution Scope is limited to 
: in Vulkan environment Execution scope is limited to 
: in Vulkan environment Memory Scope is limited to Device, QueueFamily, Workgroup, ShaderCallKHR, Subgroup, or Invocation
: missing 
: no conversion
: operand 
: out of range
: storage class forbidden by universal validation rules.
: storage class must be Function, Workgroup, CrossWorkGroup or Generic in the OpenCL environment.
: truncated 
; Annotations
; Bound: 
; Debug Information
; Function 
; Generator: 
; IR after last pass
; IR before pass 
; SPIR-V\n
; Schema: 
; Types, variables and constants
; Version: 
<16 x i1>
<16 x i8>
<4 x float>
<4 x i32>
<8 x i16>
<instruction>
= *cannot print option value*\n
= *unknown option value*\n
> is later referenced by 
> is used by entry point '
> which is called with execution model 
>, but is not listed as an interface
@33333333
A BuiltIn variable (id 
A FunctionCall must happen within a function body.
A block must end with a branch instruction.
A function (
A function must begin with a label
A module-scope OpVariable with initialization value cannot be marked with the Import Linkage Type.
ABCDEF
ABGR
ARGB
AbsISubINTEL
AbsUSubINTEL
Accept textual form of PNaCl bitcode records (i.e. not .ll assembly)
AccessQualifier must be a 32-bit unsigned integer OpConstant
According to the 
According to the Vulkan spec BuiltIn 
According to the Vulkan spec BuiltIn HelperInvocation variable needs to be a bool scalar. 
According to the Vulkan spec BuiltIn InvocationId variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn PatchVertices variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn PointCoord variable needs to be a 2-component 32-bit float vector. 
According to the Vulkan spec BuiltIn PointSize variable needs to be a 32-bit float scalar. 
According to the Vulkan spec BuiltIn Position variable needs to be a 4-component 32-bit float vector. 
According to the Vulkan spec BuiltIn PrimitiveId variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn SampleId variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn SampleMask variable needs to be a 32-bit int array. 
According to the Vulkan spec BuiltIn SamplePosition variable needs to be a 2-component 32-bit float vector. 
According to the Vulkan spec BuiltIn TessCoord variable needs to be a 3-component 32-bit float vector. 
According to the Vulkan spec BuiltIn TessLevelOuter variable needs to be a 2-component 32-bit float array. 
According to the Vulkan spec BuiltIn TessLevelOuter variable needs to be a 4-component 32-bit float array. 
Acos
Acosh
Acquire
AcquireRelease
Actual Type
Add bounds checking code in WASM frontend
Address mode optimization
AddressQualifier must be a 32-bit unsigned integer OpConstant
Addressing model must be Logical or PhysicalStorageBuffer64 
Addressing model must be Physical32 or Physical64 
Affinity mask is empty, using all-cores affinity\n
AffinityMask
AffinityPolicy
After Alloca processing
After LICM
After Local CSE
After Phi lowering
After RMW transform
After Short Circuiting
After advanced Phi lowering
After branch optimization
After initial x86 codegen
After linear scan regalloc
After load optimization
After loop analysis
After regalloc of infinite-weight variables
After splitting local variables
After stack frame mapping
After target helper call insertion
After x86 address mode opt
After x86 codegen
Alias for --allow-externally-defined-symbols
AliasDomainDeclINTEL
AliasScopeDeclINTEL
AliasScopeINTEL
AliasScopeINTELMask
AliasScopeListDeclINTEL
Aliased
AliasedPointer
AliasedPointerEXT
Aligned
Alignment
AlignmentId
All OpSampledImage instructions must be in the same block in which their Result <id> are consumed. OpSampledImage Result Type <id> 
All OpVariable instructions in a function must be the first instructions in the first block.
Allocating a variable containing a 16-bit element in 
Allocating a variable containing a 8-bit element in 
Allow IACA (Intel Architecture Code Analyzer) marks to be inserted. These binaries are not executable.
Allow error recovery when reading PNaCl bitcode.
Allow global symbols to be externally defined (other than _start and __pnacl_pso_root).
Allow global variables to be uninitialized
AllowContract
AllowContractFastINTEL
AllowReassoc
AllowReassoc and AllowContract must be specified when AllowTransform is specified
AllowReassocINTEL
AllowRecip
AllowTransform
AnyHitKHR
AnyHitNV
ArbitraryFloatACosINTEL
ArbitraryFloatACosPiINTEL
ArbitraryFloatASinINTEL
ArbitraryFloatASinPiINTEL
ArbitraryFloatATan2INTEL
ArbitraryFloatATanINTEL
ArbitraryFloatATanPiINTEL
ArbitraryFloatAddINTEL
ArbitraryFloatCastFromIntINTEL
ArbitraryFloatCastINTEL
ArbitraryFloatCastToIntINTEL
ArbitraryFloatCbrtINTEL
ArbitraryFloatCosINTEL
ArbitraryFloatCosPiINTEL
ArbitraryFloatDivINTEL
ArbitraryFloatEQINTEL
ArbitraryFloatExp10INTEL
ArbitraryFloatExp2INTEL
ArbitraryFloatExpINTEL
ArbitraryFloatExpm1INTEL
ArbitraryFloatGEINTEL
ArbitraryFloatGTINTEL
ArbitraryFloatHypotINTEL
ArbitraryFloatLEINTEL
ArbitraryFloatLTINTEL
ArbitraryFloatLog10INTEL
ArbitraryFloatLog1pINTEL
ArbitraryFloatLog2INTEL
ArbitraryFloatLogINTEL
ArbitraryFloatMulINTEL
ArbitraryFloatPowINTEL
ArbitraryFloatPowNINTEL
ArbitraryFloatPowRINTEL
ArbitraryFloatRSqrtINTEL
ArbitraryFloatRecipINTEL
ArbitraryFloatSinCosINTEL
ArbitraryFloatSinCosPiINTEL
ArbitraryFloatSinINTEL
ArbitraryFloatSinPiINTEL
ArbitraryFloatSqrtINTEL
ArbitraryFloatSubINTEL
ArbitraryPrecisionFixedPointINTEL
ArbitraryPrecisionFloatingPointINTEL
ArbitraryPrecisionIntegersINTEL
ArgInfo must be an ArgumentInfo extended instruction
ArgInfo must be from the same extended instruction import
ArgNumber
ArgumentInfo
ArgumentPodPushConstant
ArgumentPodStorageBuffer
ArgumentPodUniform
ArgumentPointerPushConstant
ArgumentPointerUniform
ArgumentSampledImage
ArgumentSampler
ArgumentSizes must be a 32-bit unsigned integer OpConstant
ArgumentStorageBuffer
ArgumentStorageImage
ArgumentStorageTexelBuffer
ArgumentUniform
ArgumentUniformTexelBuffer
ArgumentWorkgroup
Array access is out of bounds, array size is 
ArrayLength
Asin
Asinh
AsmCallINTEL
AsmINTEL
AsmTargetINTEL
Assembler can't jmp to memory operand
Assembly ('.s') file
AssumeTrueKHR
Atan
Atan2
Atanh
AtomicAnd
AtomicCompareExchange
AtomicCompareExchangeWeak
AtomicCounter
AtomicCounterMemory
AtomicExchange
AtomicFAddEXT
AtomicFMaxEXT
AtomicFMinEXT
AtomicFlagClear
AtomicFlagTestAndSet
AtomicFloat16AddEXT
AtomicFloat16MinMaxEXT
AtomicFloat16VectorNV
AtomicFloat32AddEXT
AtomicFloat32MinMaxEXT
AtomicFloat64AddEXT
AtomicFloat64MinMaxEXT
AtomicIAdd
AtomicIDecrement
AtomicIIncrement
AtomicISub
AtomicIsLockFree byte size should be compile-time const
AtomicOr
AtomicSMax
AtomicSMin
AtomicStorage
AtomicStorageOps
AtomicType
AtomicUMax
AtomicUMin
AtomicXor
Attempt to call base Inst::isMemoryWrite() method
Attempted to get underlying data type via member index for non-struct type.
Attributes must be an OpString
AutoINTEL
BFloat16ConversionINTEL
Back-edges (
Bad type for atomicRMW
Bad type for cmpxchg
Bad type for sdiv
Bad type for srem
Bad type for udiv
Bad type for urem
Ballot must be a 4-component integer vector
Ballot must be present when Operation is PartitionedReduceNV, PartitionedInclusiveScanNV, or PartitionedExclusiveScanNV
BankBitsINTEL
BankwidthINTEL
BaryCoordKHR
BaryCoordNV
BaryCoordNoPerspAMD
BaryCoordNoPerspCentroidAMD
BaryCoordNoPerspKHR
BaryCoordNoPerspNV
BaryCoordNoPerspSampleAMD
BaryCoordPullModelAMD
BaryCoordSmoothAMD
BaryCoordSmoothCentroidAMD
BaryCoordSmoothSampleAMD
Base Type
BaseVertex
Before RMW
Before SPIR-V 1.5, 
BeginInvocationInterlockEXT
Behavior is undefined unless ClusterSize is at least 1 and a power of 2.
Binding
Binding must be a 32-bit unsigned integer OpConstant
BindlessImageNV
BindlessSamplerNV
BindlessTextureNV
BitFieldInsert
BitFieldSExtract
BitFieldUExtract
BitInstructions
BitPiece
BitReverse
Bitcast
BlitRoutine
Block(s) 
Block-local variable splitting (O2 only)
BlockMatchSamplerQCOM
BlockMatchTextureQCOM
BlockingPipesINTEL
Boolean
BoundImageNV
BoundSamplerNV
Branch
BranchConditional
Break down timing for specific functions (use ':' for all)
BufferBlock
BufferSize must be a 32-bit unsigned integer OpConstant
Build ICE instructions when reading bitcode
BuildNDRange
BuiltIn
BuiltIn (No allowed mixing of built-in variables and 
BuiltIns can only target variables, structure members or constants
BurstCoalesceINTEL
ByVal
CPP_for_OpenCL
CPacked
CacheControlLoadINTEL
CacheControlStoreINTEL
CacheControlsINTEL
CacheSizeINTEL
Callable Data must be the result of a OpVariable
Callable Data must have storage class CallableDataKHR or IncomingCallableDataKHR
CallableDataKHR Storage Class is limited to RayGenerationKHR, ClosestHitKHR, CallableKHR, and MissKHR execution model
Can not compute
Can't lower unsupported instruction type
Cannot allocate a variable containing a 16-bit type in 
Cannot allocate a variable containing a 8-bit type in 
Cannot copy composites of 8- or 16-bit types
Cannot copy memory of objects containing 8- or 16-bit types
Cannot create a composite containing 8- or 16-bit types
Cannot create undefined values with 8- or 16-bit types
Cannot create undefined values with void type
Cannot declare a function in a function body
Cannot extract from a composite of 8- or 16-bit types
Cannot extract from a vector of 8- or 16-bit types
Cannot find option named '
Cannot form constants of 8- or 16-bit types
Cannot insert into a composite of 8- or 16-bit types
Cannot insert into a vector of 8- or 16-bit types
Cannot load a runtime-sized array
Cannot parse key-value pair at line %d of configuration (key or value is empty), skipping key-value pair\n
Cannot parse line %d of configuration, skipping line\n
Cannot put a negative number in an unsigned literal
Cannot shuffle a vector of 8- or 16-bit types
Cannot specify more than one option with cl::ConsumeAfter!
Cannot transpose matrices of 16-bit floats
Cannot use a pointer in the PhysicalStorageBuffer storage class
Capability
Capability 
Capability Image1D is required to access storage image
Capability ImageBuffer is required to access storage image
Capability ImageCubeArray is required to access 
Capability ImageMSArray is required to access storage 
Capability ImageRect is required to access storage image
Capability Int64ImageEXT is required when using Sampled Type of 64-bit int
Capability StorageImageMultisample is required when using multisampled storage image
Capability StorageImageReadWithoutFormat is required to 
Capability StorageImageWriteWithoutFormat is required to write 
CaptureEventProfilingInfo
Case construct that targets 
Cast type not supported
Ceil
Child
ClampToEdge
ClipDistancePerViewNV
ClobberINTEL
ClosestHitNV
ClusterSize must be a constant instruction
ClusterSize must be a scalar of integer type, whose Signedness operand is 0.
ClusterSize must be an unsigned integer scalar
ClusterSize must be present when Operation is ClusteredReduce
ClusterSize must come from a constant instruction.
CmdExecTime
CoalescedInputCountAMDX
CoalescingAMDX
CodeSectionINTEL
Codeplay
Coherent
ColMajor
Column
Column Major operand <id> 
Column type is not defined.
ColumnMajorKHR
Columns in a matrix must be of type vector.
Component
Component Count
Component decoration only allowed on 64-bit scalar and 2-component vector
Component decoration specified for type 
Component decoration value must not be 1 or 3 for 64-bit data types
Component decoration value must not be greater than 3
Component index 
Component type is not defined.
CompositeConstruct
CompositeConstructContinuedINTEL
CompositeExtract
CompositeInsert
ComputeDerivativeGroupLinearNV
ComputeDerivativeGroupQuadsNV
ComputeProgram
Condition operand for OpBranchConditional must be of boolean type
ConduitKernelArgumentINTEL
Configuration
Const
ConstCachedINTEL
ConstOffset
ConstOffset image operand not allowed 
ConstOffsets
ConstType
Constant pool counters
ConstantDataPointerPushConstant
ConstantDataStorageBuffer
ConstantDataUniform
ConstantFunctionPointerINTEL
ConstantNull
ConstantPipeStorage
ConstantSampler
Construct 
Constu
Continue Target 
ContractionOff
ControlBarrier
ControlBarrierArriveINTEL
ControlBarrierWaitINTEL
Convert additions to lea when it reduces code size
ConvertBF16ToFINTEL
ConvertFToBF16INTEL
ConvertFToS
ConvertFToU
ConvertImageToUNV
ConvertPtrToU
ConvertSToF
ConvertSampledImageToUNV
ConvertSamplerToUNV
ConvertUToAccelerationStructureKHR
ConvertUToF
ConvertUToImageNV
ConvertUToPtr
ConvertUToSampledImageNV
ConvertUToSamplerNV
Cooperative matrix 'K' mismatch: 
Cooperative matrix 'M' mismatch: 
Cooperative matrix 'N' mismatch: 
Cooperative matrix can only be cast to another cooperative 
Cooperative matrix scopes must match: 
Cooperative matrix type must be A Type: 
Cooperative matrix type must be Accumulator Type: 
Cooperative matrix type must be B Type: 
Cooperative matrix types (or types containing them) can only be allocated 
CooperativeMatrixLengthKHR
CooperativeMatrixLengthNV
CooperativeMatrixMulAddKHR
CooperativeMatrixMulAddNV
CopyLogical
CopyMemory
CopyMemorySized
CopyObject
CoreBuiltinsARM
CoreCountARM
CoreIDARM
CoreMaxIDARM
Corrupt image type definition
Cosh
Couldn't lower RMW instruction
CounterBuffer
CreatePipeFromPipeStorage
CreateUserEvent
Cross
CrossDevice
CrossWorkgroup or Function: 
CrossWorkgroupCastToPtrINTEL
CrossWorkgroupMemory
CubeFaceCoordAMD
CubeFaceIndexAMD
Cull Mask must be a 32-bit int scalar
Cull mask must be a 32-bit int scalar
CullBackFacingTrianglesKHR
CullDistancePerViewNV
CullFrontFacingTrianglesKHR
CullNoOpaqueKHR
CullOpaqueKHR
CullPrimitiveEXT
Current Times must be a 32-bit float scalar type
CurrentRayTimeNV
DPdx
DPdxCoarse
DPdxFine
DPdy
DPdyCoarse
DPdyFine
DWARF Version
Data must be an OpString
Debug info extension instruction found inside function but outside block
Debug info extension instruction other than DebugScope, DebugNoScope, DebugDeclare, and DebugValue found inside function
Debug info extension instruction other than DebugScope, DebugNoScope, DebugFunctionDefinition, DebugDeclare, and DebugValue found inside function
Debug info extension instructions other than 
DebugBuildIdentifier
DebugCompilationUnit
DebugDeclare
DebugEntryPoint
DebugExpression
DebugFunctionDeclaration
DebugFunctionDefinition
DebugGlobalVariable
DebugGlobalVariable or DebugLocalVariable with a 32- or 
DebugImportedEntity
DebugInfo
DebugInfoModuleINTEL
DebugInlinedAt
DebugInlinedVariable
DebugLexicalBlock
DebugLexicalBlockDiscriminator
DebugLine
DebugLocalVariable
DebugMacroDef
DebugMacroUndef
DebugModuleINTEL
DebugNoLine
DebugNoScope
DebugOperation
DebugScope
DebugScope, DebugNoScope, DebugDeclare, DebugValue 
DebugSource
DebugSourceContinued
DebugStoragePath
DebugTypeArray
DebugTypeBasic
DebugTypeComposite
DebugTypeEnum
DebugTypeFunction
DebugTypeMatrix
DebugTypeMember
DebugTypePointer
DebugTypePtrToMember
DebugTypeQualifier
DebugTypeTemplate
DebugTypeTemplateParameter
DebugTypeTemplateParameter or 
DebugTypeTemplateParameterPack
DebugTypeTemplateTemplateParameter
DebugTypeVector
DebugTypedef
DebugValue
Decorate textual asm output with register liveness info
DecorationGroup
Decorations taking ID parameters may not be used with OpDecorateId
Decorations that don't take ID parameters may not be used with OpDecorateId
Default must be an OpLabel instruction
Define default function prefix for naming unnamed functions
Define default global prefix for naming unnamed globals
Define format of input file:
Degrees
Delta must be a scalar of integer type, whose Signedness operand is 0.
DemoteToHelperInvocation
DemoteToHelperInvocationEXT
DenormFlushToZero
DenormPreserve
DependencyArrayINTEL
DependencyInfinite
DependencyLength
DepthGreater
DepthLess
DepthReplacing
DepthStencil
DepthUnchanged
Deref
Derivative instructions require DerivativeGroupQuadsNV or DerivativeGroupLinearNV execution mode for GLCompute execution model: 
Derivative instructions require Fragment or GLCompute execution model: 
DerivativeControl
DescriptorSet
DescriptorSet must be a 32-bit unsigned integer OpConstant
DescriptorSetBuffer
DescriptorSetImage
DescriptorSetSampler
Determinant
DeviceEnqueue
DeviceGroup
DeviceIndex
DeviceOnlyINTEL
Dim SubpassData requires Arrayed to be 0 in the Vulkan environment
Dim SubpassData requires Fragment execution model: 
Dim SubpassData requires Sampled to be 2
Dim SubpassData requires format Unknown
Dim TileImageDataEXT requires Arrayed to be 0
Dim TileImageDataEXT requires Depth to be 0
Dim TileImageDataEXT requires Sampled Type to be not OpTypeVoid
Dim TileImageDataEXT requires Sampled to be 2
Dim TileImageDataEXT requires format Unknown
Dim must be a 32-bit unsigned integer OpConstant
Dim must not be Rect in the Vulkan environment
Disable Subzero translation
Disable hybrid assembly when -filetype=iasm
Disassembly failed before pass 
Display all available options
Display available options (-help-hidden for more)
Display list of all available options
Display list of available options (-help-list-hidden for more)
Don't use specified registers
DontFlatten
DontInline
DontStaticallyCoalesceINTEL
DontUnroll
DotProduct
DotProductInput4x8Bit
DotProductInput4x8BitKHR
DotProductInput4x8BitPacked
DotProductInput4x8BitPackedKHR
DotProductInputAll
DotProductInputAllKHR
DotProductKHR
DoublepumpINTEL
DragonJoker
DragonJoker ShaderWriter
DrawIndex
DrawParameters
Dref sampling operation is invalid for multisample image
Dump string pools during compilation
Duplicate non-aggregate type declarations are not allowed. Opcode: 
ERROR_not_op_extension
ESSL
EarlyAndLateFragmentTestsAMD
EarlyFragmentTests
ElemSize must be a 32-bit unsigned integer OpConstant
Element type is not defined.
Embark Studios
Embark Studios Rust GPU Compiler Backend
Embedded
Emit (global) data into separate sections
Emit Subzero revision string into the output
Emit functions into separate sections
EmitMeshTasksEXT
EmitStreamVertex
EmitVertex
Enable -time-passes memory tracking (this may be slow)
Enable ARM Neon instructions
Enable ARM integer divide instructions in ARM mode
Enable X86 SSE 4.1 instructions
Enable X86 SSE2 instructions
Enable breakdown timing of Subzero translation
Enable edge splitting for Phi lowering
EnableSpirvProfiling
Encoding
Encountered extended instruction GLSLstd450Bad
End of input reached while decoding Op
EndInvocationInterlockEXT
EndPrimitive
EndStreamPrimitive
EnqueueKernel
EnqueueMarker
EnqueuedWorkgroupSize
Entry point id '
Entry points may not have a call graph with cycles.
Entry-point has conflicting 
Entry-point has more than one variable with the HitAttributeKHR storage class in the interface
Entry-point has more than one variable with the IncomingCallableDataKHR storage class in the interface
Entry-point has more than one variable with the IncomingRayPayloadKHR storage class in the interface
Entry-point has more than one variable with the PushConstant storage class in the interface
Error: Result Id is 0
Error: Type Id is 0
ExclusiveScan
ExecuteCallableKHR
ExecuteCallableNV
Execution mode can only be used with a Geometry or tessellation execution model.
Execution mode can only be used with a Geometry, tessellation, MeshNV or MeshEXT execution model.
Execution mode can only be used with a Kernel or GLCompute execution model.
Execution mode can only be used with a Kernel, GLCompute, MeshNV, MeshEXT, TaskNV or TaskEXT execution model.
Execution mode can only be used with a tessellation execution model.
Execution mode can only be used with the Fragment execution model.
Execution mode can only be used with the Fragment or GLCompute execution model.
Execution mode can only be used with the Geometry MeshNV or MeshEXT execution model.
Execution mode can only be used with the Geometry execution model.
Execution mode can only be used with the Kernel execution model.
Execution mode can only be used with the MeshEXT or MeshNV execution model.
ExecutionMode
ExecutionModeId
Exit with success status, even if errors found
Exp2
Expect to see OpLoad
ExpectAssumeKHR
ExpectKHR
Expected 
Expected 32-bit float scalar or vector type as Result Type: 
Expected 32-bit floating-point type 3-component vector as Result Type: 
Expected 32-bit floating-point type scalar as Result Type: 
Expected 32-bit int type for Base operand: 
Expected 32-bit integer type 2-component vector as Result Type: 
Expected 32-bit integer type scalar as Result Type: 
Expected 64-bit uint scalar or 2-component 32-bit uint vector as input: 
Expected Acceleration Structure to be of type OpTypeAccelerationStructureKHR
Expected Base Type to be equal to Result Type: 
Expected Base dimension to be equal to Result Type dimension: 
Expected Base to be int scalar or vector: 
Expected Base to have the same bit width 
Expected Base to have the same dimension 
Expected Component Operand to be a const object for Vulkan environment
Expected Component to be 32-bit int scalar
Expected Component type to be equal to Result Type 
Expected Composite to be an object of composite type
Expected Constituent type to be equal to the 
Expected Constituent type to be equal to the column 
Expected Constituent type to be equal to the component type
Expected Constituents to be scalars or vectors of
Expected Coordinate to be float scalar or vector
Expected Coordinate to be int or float scalar or vector
Expected Coordinate to be int scalar or vector
Expected Coordinate to be integer scalar or vector
Expected Coordinate to have 
Expected Coordinate to have at least 
Expected Count Type to be int scalar: 
Expected Dref to be of 32-bit float type
Expected Image 'Dim' must be one of 1D, 2D, or Cube when Arrayed is 1
Expected Image 'Dim' parameter to be 1D, 2D, 3D or Rect
Expected Image 'Dim' parameter to be not SubpassData.
Expected Image 'Dim' to be 2D, Cube, or Rect
Expected Image 'MS' parameter to be 0
Expected Image 'Sampled Type' to be the same as 
Expected Image 'Sampled Type' to be the same as Texel 
Expected Image 'Sampled Type' to be the same as the Type pointed to by Result Type
Expected Image 'Sampled' parameter to be 0 or 1
Expected Image 'Sampled' parameter to be 0 or 2
Expected Image 'Sampled' parameter to be 1
Expected Image 'Sampled' parameter to be 1 for Vulkan environment.
Expected Image 'arrayed' parameter to be 0
Expected Image Operand Bias to be float scalar
Expected Image Operand ConstOffset to be a const object
Expected Image Operand ConstOffset to be int scalar or 
Expected Image Operand ConstOffset to have 
Expected Image Operand ConstOffsets array components to be int vectors of size 2
Expected Image Operand ConstOffsets to be a const object
Expected Image Operand ConstOffsets to be an array of size 4
Expected Image Operand Grad dx to have 
Expected Image Operand Grad dy to have 
Expected Image Operand Lod to be float scalar when used 
Expected Image Operand Lod to be int scalar when used with 
Expected Image Operand MinLod to be float scalar
Expected Image Operand Offset to be int scalar or 
Expected Image Operand Offset to have 
Expected Image Operand Sample to be int scalar
Expected Image operand to be of type OpTypeSampledImage
Expected Image to be OpTypePointer
Expected Image to be OpTypePointer with Type OpTypeImage
Expected Image to be of type OpTypeImage
Expected Image to be of type OpTypeImage.
Expected Index to be int scalar
Expected Insert Type to be equal to Result Type: 
Expected Level of Detail to be int scalar
Expected Matrix to be of type OpTypeMatrix
Expected Offset Type to be int scalar: 
Expected P type and Result Type to be the same: 
Expected Resident Code to be int scalar
Expected Result Type and Operand type to be the same
Expected Result Type struct member types to be identical: 
Expected Result Type struct member types to be integer scalar 
Expected Result Type struct member types to be unsigned 
Expected Result Type struct to have two members: 
Expected Result Type to be OpTypeImage
Expected Result Type to be OpTypePointer
Expected Result Type to be OpTypePointer whose Storage Class operand is Image
Expected Result Type to be OpTypePointer whose Type operand must be a scalar numerical type or OpTypeVoid
Expected Result Type to be OpTypeSampledImage.
Expected Result Type to be OpTypeStruct
Expected Result Type to be OpTypeVector
Expected Result Type to be a Acceleration Structure: 
Expected Result Type to be a composite type
Expected Result Type to be a matrix type
Expected Result Type to be a pointer or int or float vector 
Expected Result Type to be a pointer: 
Expected Result Type to be a scalar or vector of floating-point, integer or boolean type.
Expected Result Type to be a scalar type
Expected Result Type to be a struct containing an int scalar and a texel
Expected Result Type to be an unsigned integer type scalar.
Expected Result Type to be bool scalar type
Expected Result Type to be float scalar or vector type: 
Expected Result Type to be float vector type
Expected Result Type to be int scalar or vector type
Expected Result Type to be int scalar type
Expected Result Type to be of target storage class: 
Expected Result Type to have 2 components
Expected Result Type to have storage class Generic: 
Expected Result Type to have storage class Workgroup, 
Expected Sample Image image type to be equal to Result Type
Expected Sample Image to be of type OpTypeSampleImage
Expected Sample for Image with MS 0 to be a valid <id> for the value 0
Expected Sample to be integer scalar
Expected Sampled Image to be of type OpTypeSampledImage
Expected Sampled Type to be a 32-bit int, 64-bit int or 32-bit float scalar type for Vulkan environment
Expected Sampled Type to be either void or
Expected Sampler to be of type OpTypeSampler
Expected Shift to be int scalar or vector: 
Expected Shift to have the same dimension 
Expected Texel to be int or float vector or scalar
Expected Use of Matrix type and Result Type to be 
Expected Value to be a vector of four components of integer type scalar
Expected Value to be a vector of two components of unsigned integer or 64bit unsigned integer
Expected Vector component type to be equal to Result Type
Expected Vector type to be OpTypeVector
Expected Vector type to be equal to Result Type
Expected a consumer instruction
Expected a struct as Result Type: 
Expected a vector compare
Expected a vector select
Expected arithmetic operands to be of Result Type: 
Expected arithmetic operands to have the same bit width 
Expected arithmetic operands to have the same dimension 
Expected at least one index to Op
Expected bool scalar or vector type as Result Type: 
Expected bool scalar or vector type as condition: 
Expected bool scalar type as Result Type: 
Expected both Image Operand Grad ids to be float scalars or 
Expected both objects to be of Result Type: 
Expected both operands to be of Result Type member type: 
Expected both operands to be of Result Type: 
Expected both operands to have the same component bit width: 
Expected column type of Result Type to be equal to the type 
Expected column type of the matrix to be equal to Result Type: 
Expected column types of Result Type and left matrix to be 
Expected columns of Matrix type and Result Type to be 
Expected component type to be equal to Result Type: 
Expected component types of Matrix and Result Type to be 
Expected component types of Result Type and matrix to be 
Expected component types of Result Type and right matrix to be 
Expected component types of Result Type and vector to be 
Expected component types of the operands to be equal: 
Expected cooperative matrix type as A Type: 
Expected cooperative matrix type as B Type: 
Expected cooperative matrix type as C Type: 
Expected cooperative matrix type as Result Type: 
Expected cooperative matrix types
Expected float matrix type as Result Type: 
Expected float matrix type as left operand: 
Expected float matrix type as right operand: 
Expected float scalar or vector type as Result Type: 
Expected float scalar type as Result Type: 
Expected float vector as operand: 
Expected float vector type as Result Type: 
Expected float vector type as left operand: 
Expected float vector type as right operand: 
Expected floating scalar or vector type as Result Type: 
Expected input and Result Type to point to the same type: 
Expected input to be a pointer or int or float vector 
Expected input to be a pointer or int scalar if Result Type is pointer: 
Expected input to be a pointer, int scalar or 32-bit int vector if Result Type is pointer: 
Expected input to be a pointer: 
Expected input to be float scalar or vector: 
Expected input to be int scalar or vector: 
Expected input to have a type: 
Expected input to have different bit width from Result Type: 
Expected input to have storage class Generic: 
Expected input to have storage class Workgroup, 
Expected input to have the same dimension as Result Type: 
Expected input to have the same total bit width as 
Expected input type to be equal to Result Type: 
Expected int scalar as input: 
Expected int scalar or vector as input: 
Expected int scalar or vector as operand: 
Expected int scalar or vector type as Result Type: 
Expected int scalar or vector type as operand: 
Expected int scalar or vector type for Base operand: 
Expected left and right operands to have the same type: 
Expected matrix operand type to be equal to Result Type: 
Expected number of columns and the column size of Matrix 
Expected number of columns of Result Type and right matrix to 
Expected number of columns of left matrix and number of rows 
Expected number of columns of the matrix to be equal to 
Expected number of columns of the matrix to be equal to the 
Expected number of constituents to be at least 2
Expected number of rows of the matrix to be equal to the 
Expected operand to be of Result Type: 
Expected operand to be of type OpTypeImage
Expected operand to be scalar or vector float: 
Expected operand to be vector bool: 
Expected operands to be scalar or vector float: 
Expected operands to be scalar or vector int: 
Expected operands to have the same bit width 
Expected operands to have the same dimension 
Expected operands to have the same number of components: 
Expected rows of Matrix type and Result Type to be 
Expected scalar operand type to be equal to the component 
Expected scalar or 
Expected scopes of Matrix and Result Type to be 
Expected single constituent
Expected target storage class to be Workgroup, 
Expected the Image Format in Image to be R64i, R64ui, R32f, R32i, or R32ui for Vulkan environment
Expected total number of Constituents to be equal 
Expected total number of given components to be equal 
Expected unsigned int scalar or vector type as Result Type: 
Expected unsigned int scalar type as Result Type: 
Expected vector compare
Expected vector operand type to be equal to Result Type: 
Expected vector sizes of Result Type and the condition to be equal: 
Expected vector sizes of Result Type and the operand to be equal: 
Expected vector sizes of Result Type and the operands to be
Expected vector sizes of Result Type and the operands to be equal: 
ExplicitInterpAMD
Export
ExtInstImport
Extended instruction GLSLstd450IMix is not supported
Externalize all symbols
Extra amount of stack to add to the frame in bytes (for testing).
FAbs
FClamp
FConvert
FDiv
FMax3AMD
FMid3AMD
FMin3AMD
FMix
FMod
FNegate
FOrdEqual
FOrdGreaterThan
FOrdGreaterThanEqual
FOrdLessThan
FOrdLessThanEqual
FOrdNotEqual
FP denorm mode
FP operation mode
FPFastMathDefault
FPFastMathDefault and ContractionOff execution modes cannot be applied to the same entry point
FPFastMathDefault and SignedZeroInfNanPreserve execution modes cannot be applied to the same entry point
FPFastMathMode
FPFastMathMode Fast
FPFastMathMode and NoContraction cannot decorate the same target
FPFastMathModeINTEL
FPGAArgumentInterfacesINTEL
FPGABufferLocationINTEL
FPGAClusterAttributesINTEL
FPGAClusterAttributesV2INTEL
FPGADSPControlINTEL
FPGAInvocationPipeliningAttributesINTEL
FPGAKernelAttributesINTEL
FPGAKernelAttributesv2INTEL
FPGALatencyControlINTEL
FPGALoopControlsINTEL
FPGAMemoryAccessesINTEL
FPGAMemoryAttributesINTEL
FPGARegINTEL
FPMaxErrorDecorationINTEL
FPMaxErrorINTEL
FPRoundingMode
FPRoundingMode decoration can be applied only to a width-only conversion instruction for floating-point object.
FPRoundingMode decoration can be applied only to the Object operand of an OpStore in the StorageBuffer, PhysicalStorageBuffer, Uniform, PushConstant, Input, or Output Storage Classes.
FPRoundingMode decoration can be applied only to the Object operand of an OpStore storing through a pointer to a 16-bit floating-point scalar or vector object.
FPRoundingMode decoration can be applied only to the Object operand of an OpStore.
FRem
FSign
FSub
FUnordEqual
FUnordGreaterThan
FUnordGreaterThanEqual
FUnordLessThan
FUnordLessThanEqual
FUnordNotEqual
FaceForward
Failed to find splice operand
Fatal inconsistency in liveness analysis
FetchMicroTriangleVertexBarycentricNV
FetchMicroTriangleVertexPositionNV
File to append -stats and -timer output to
FinalizeNodePayloadsAMDX
Finalizer
FindILsb
FindSMsb
FindUMsb
FinishWritingNodePayloadAMDX
First block 
FixedCosINTEL
FixedCosPiINTEL
FixedExpINTEL
FixedLogINTEL
FixedRecipINTEL
FixedRsqrtINTEL
FixedSinCosINTEL
FixedSinCosPiINTEL
FixedSinINTEL
FixedSinPiINTEL
FixedSqrtINTEL
FlagArtificial
FlagExplicit
FlagFwdDecl
FlagIndirectVariable
FlagIsDefinition
FlagIsEnumClass
FlagIsLocal
FlagIsOptimized
FlagIsPrivate
FlagIsProtected
FlagIsPublic
FlagLValueReference
FlagObjectPointer
FlagPrototyped
FlagRValueReference
FlagStaticMember
FlagTypePassByReference
FlagTypePassByValue
Flags
Flags must be a 32-bit unsigned integer OpConstant
Flat
Float16
Float16Buffer
Float16ImageAMD
Float64
FloatControls2
FloatingPointModeALTINTEL
FloatingPointModeIEEEINTEL
Floor
For OpExecutionModeId all Extra Operand ids must be constant instructions.
For Vulkan with RuntimeDescriptorArrayEXT, a variable 
For Vulkan, OpTypeStruct variables containing 
For Vulkan, an OpTypeStruct variable containing an 
Force -O2 for certain functions (assumes -Om1)
Force optimization of memory intrinsics.
ForceOpacityMicromap2StateEXT
ForcePow2DepthINTEL
FormatString must be an OpString
Forward pointers must point to a structure
Found RMW in 
Found empty section name at line %d of configuration\n
Found unrecognized extension 
Fract
FragInvocationCountEXT
FragSizeEXT
FragStencilRefEXT
Fragment
Fragment OpEntryPoint operand 
Fragment execution model entry points can only specify one of OriginUpperLeft or OriginLowerLeft execution modes.
Fragment execution model entry points can specify at most one fragment shader interlock execution mode.
Fragment execution model entry points can specify at most one of DepthGreater, DepthLess or DepthUnchanged execution modes.
Fragment execution model entry points can specify at most one of StencilRefUnchangedBackAMD, StencilRefLessBackAMD or StencilRefGreaterBackAMD execution modes.
Fragment execution model entry points can specify at most one of StencilRefUnchangedFrontAMD, StencilRefLessFrontAMD or StencilRefGreaterFrontAMD execution modes.
Fragment execution model entry points require either an OriginUpperLeft or OriginLowerLeft execution mode.
FragmentBarycentricKHR
FragmentBarycentricNV
FragmentDensityEXT
FragmentFetchAMD
FragmentFullyCoveredEXT
FragmentMaskAMD
FragmentMaskFetchAMD
FragmentShaderPixelInterlockEXT
FragmentShaderSampleInterlockEXT
FragmentShaderShadingRateInterlockEXT
FragmentShadingRateKHR
FragmentSizeNV
Frexp
FrexpStruct
From 
From ARB_gl_spirv extension:\n
From SPIR-V spec, section 3.32.8 on OpVariable:\n
From Vulkan spec, Push Constant Interface section:\n
From Vulkan spec:\n
Full
FuncParamAttr
FuncParamIOKindINTEL
Function declaration (id 
Function declarations must appear before function definitions.
Function definition (id 
Function end cannot be called in blocks
Function end instructions must be in a function body
Function or Workgroup
Function parameter cannot be the first instruction.
Function parameter instructions must be in a function body
Function parameter must be preceded by a function.
Function parameters must only appear immediately after the function definition
FunctionCall
FunctionDenormModeINTEL
FunctionEnd
FunctionFloatControlINTEL
FunctionFloatingPointModeINTEL
FunctionPointerCallINTEL
FunctionPointersINTEL
FunctionRoundingModeINTEL
FuseLoopsInFunctionINTEL
Fwidth
FwidthCoarse
FwidthFine
GCC: (SteamRT 10.3.0-3+steamrt3.1+bsrt3c.1) 10.3.0
GCC_3.0
GLCompute
GLIBC_2.12
GLIBC_2.14
GLIBC_2.16
GLIBC_2.17
GLIBC_2.2.5
GLIBC_2.27
GLIBC_2.28
GLIBC_2.29
GLIBC_2.3
GLIBC_2.3.2
GLIBC_2.3.3
GLIBC_2.3.4
GLIBC_2.4
GLIBC_2.6
GLIBC_2.7
GLSL
GLSL.std.450
GLSL450
GLSLPacked
GLSLShared
Ga=u
Gather operation is invalid for multisample image
General options
Generate list of build attributes associated with this executable.
Generating variable pointers requires capability 
Generic Options
GenericCastToPtr
GenericCastToPtrExplicit
GenericPointer
GenericPtrMemSemantics
Geometry
Geometry Index must be a 32-bit int scalar
Geometry execution model entry points must specify exactly one of InputPoints, InputLines, InputLinesAdjacency, Triangles or InputTrianglesAdjacency execution modes.
Geometry execution model entry points must specify exactly one of OutputPoints, OutputLineStrip or OutputTriangleStrip execution modes.
GeometryPointSize
GeometryShaderPassthroughNV
GeometryStreams
GetDefaultQueue
GetKernelLocalSizeForSubgroupCount
GetKernelMaxNumSubgroups
GetKernelNDrangeMaxSubGroupSize
GetKernelNDrangeSubGroupCount
GetKernelPreferredWorkGroupSizeMultiple
GetKernelWorkGroupSize
GetMaxPipePackets
GetNumPipePackets
Global
Global initializers
Global live range splitting
GlobalInvocationId
GlobalLinearId
GlobalVariableFPGADecorationsINTEL
GlobalVariableHostAccessINTEL
GlobalVariableOffsetINTEL
Google
Google ANGLE Shader Compiler
Google Clspv
Google MLIR SPIR-V Serializer
Google Shaderc over Glslang
Google Skia SkSL
Google Tint Compiler
Google rspirv
Google spiregg
Group Count X must be a 32-bit unsigned int scalar
Group Count Y must be a 32-bit unsigned int scalar
Group Count Z must be a 32-bit unsigned int scalar
GroupAll
GroupAny
GroupAsyncCopy
GroupBitwiseAndKHR
GroupBitwiseOrKHR
GroupBitwiseXorKHR
GroupBroadcast
GroupCommitReadPipe
GroupCommitWritePipe
GroupDecorate
GroupFAdd
GroupFAddNonUniformAMD
GroupFMax
GroupFMaxNonUniformAMD
GroupFMin
GroupFMinNonUniformAMD
GroupFMulKHR
GroupIAdd
GroupIAddNonUniformAMD
GroupIMulKHR
GroupLogicalAndKHR
GroupLogicalOrKHR
GroupLogicalXorKHR
GroupNonUniform
GroupNonUniformAll
GroupNonUniformAllEqual
GroupNonUniformAny
GroupNonUniformArithmetic
GroupNonUniformBallot
GroupNonUniformBallotBitCount
GroupNonUniformBallotBitExtract
GroupNonUniformBallotFindLSB
GroupNonUniformBallotFindMSB
GroupNonUniformBitwiseAnd
GroupNonUniformBitwiseOr
GroupNonUniformBitwiseXor
GroupNonUniformBroadcast
GroupNonUniformBroadcastFirst
GroupNonUniformClustered
GroupNonUniformElect
GroupNonUniformFAdd
GroupNonUniformFMax
GroupNonUniformFMin
GroupNonUniformFMul
GroupNonUniformIAdd
GroupNonUniformIMul
GroupNonUniformInverseBallot
GroupNonUniformLogicalAnd
GroupNonUniformLogicalOr
GroupNonUniformLogicalXor
GroupNonUniformPartitionNV
GroupNonUniformPartitionedNV
GroupNonUniformQuad
GroupNonUniformQuadAllKHR
GroupNonUniformQuadAnyKHR
GroupNonUniformQuadBroadcast
GroupNonUniformQuadSwap
GroupNonUniformRotateKHR
GroupNonUniformSMax
GroupNonUniformSMin
GroupNonUniformShuffle
GroupNonUniformShuffleDown
GroupNonUniformShuffleRelative
GroupNonUniformShuffleUp
GroupNonUniformShuffleXor
GroupNonUniformUMax
GroupNonUniformUMin
GroupNonUniformVote
GroupReserveReadPipePackets
GroupReserveWritePipePackets
GroupSMax
GroupSMaxNonUniformAMD
GroupSMin
GroupSMinNonUniformAMD
GroupUMax
GroupUMaxNonUniformAMD
GroupUMin
GroupUMinNonUniformAMD
GroupUniformArithmeticKHR
GroupWaitEvents
HERO_C
HLSL
HalfFloat
Having 
Header block 
Helper call was expected
Hint and Bits are optional together i.e 
Hint must be a 32-bit int scalar
Hit Kind must be a 32-bit unsigned int scalar
Hit Object Attributes id must be a OpVariable of storage class HitObjectAttributeNV
Hit Object Attributes id must be a OpVariable of storage class RayPayloadKHR
Hit Object must be a memory object declaration
Hit Object must be a pointer
Hit T must be a 32-bit float scalar
Hit must be a 32-bit int scalar
HitAttributeKHR
HitAttributeKHR Storage Class is limited to IntersectionKHR, AnyHitKHR, sand ClosestHitKHR execution model
HitAttributeKHR Storage Class variables are read only with AnyHitKHR and ClosestHitKHR
HitAttributeNV
HitKindBackFacingMicroTriangleNV
HitKindFrontFacingMicroTriangleNV
HitKindKHR
HitMicroTriangleVertexBarycentricsNV
HitMicroTriangleVertexPositionsNV
HitObjectAttributeNV Storage Class is limited to RayGenerationKHR, ClosestHitKHR or MissKHR execution model
HitObjectExecuteShaderNV
HitObjectGetAttributesNV
HitObjectGetCurrentTimeNV
HitObjectGetGeometryIndexNV
HitObjectGetHitKindNV
HitObjectGetInstanceCustomIndexNV
HitObjectGetInstanceIdNV
HitObjectGetObjectRayDirectionNV
HitObjectGetObjectRayOriginNV
HitObjectGetObjectToWorldNV
HitObjectGetPrimitiveIndexNV
HitObjectGetRayTMaxNV
HitObjectGetRayTMinNV
HitObjectGetShaderBindingTableRecordIndexNV
HitObjectGetShaderRecordBufferHandleNV
HitObjectGetWorldRayDirectionNV
HitObjectGetWorldRayOriginNV
HitObjectGetWorldToObjectNV
HitObjectIsEmptyNV
HitObjectIsHitNV
HitObjectIsMissNV
HitObjectRecordEmptyNV
HitObjectRecordHitMotionNV
HitObjectRecordHitNV
HitObjectRecordHitWithIndexMotionNV
HitObjectRecordHitWithIndexNV
HitObjectRecordMissMotionNV
HitObjectRecordMissNV
HitObjectShaderRecordBufferNV
HitObjectTraceRayMotionNV
HitObjectTraceRayNV
HitTNV
HitTriangleVertexPositionsKHR
HlslCounterBufferGOOGLE
HlslSemanticGOOGLE
Hoist loop invariant arithmetic operations
Horizontal2Pixels
Horizontal4Pixels
HostOnlyINTEL
IAddCarry
IAddSatINTEL
IAverageINTEL
IAverageRoundedINTEL
ID overflow. Try running compact-ids.
IEEE
IEqual
IMix
IMul32x16INTEL
INotEqual
IO failure on output stream.
IOPipeStorageINTEL
IOPipesINTEL
IR File
ISubBorrow
ISubSatINTEL
Id must be an unsigned integer scalar
If OpTypeBool is stored in conjunction with OpVariable using Input or Output Storage Classes it requires a BuiltIn decoration
If OpTypeBool is stored in conjunction with OpVariable, it can only be used with non-externally visible shader Storage Classes: Workgroup, CrossWorkgroup, Private, Function, Input, Output, RayPayloadKHR, IncomingRayPayloadKHR, HitAttributeKHR, CallableDataKHR, IncomingCallableDataKHR, or UniformConstant
IgnoreIntersectionKHR
IgnoreIntersectionNV
Illegal number of components (
Illegal use of QCOM image processing decorated texture
Image 'Dim' cannot be Cube
Image 'Dim' cannot be SubpassData
Image 'Dim' cannot be TileImageDataEXT
Image 'Dim' must be 1D, 2D, 3D or Cube
Image 'Dim' must be 1D, Buffer, 2D, Cube, 3D or Rect
Image 'Dim' must be 2D
Image 'MS' must be 0
Image 'MS' must be 1
Image Dim SubpassData cannot be used with ImageSparseRead
Image Dim SubpassData cannot be used with OpImageTexelPointer
Image Dim TileImageDataEXT cannot be used with 
Image Dim TileImageDataEXT cannot be used with OpImageTexelPointer
Image Operand Bias can only be used with ImplicitLod opcodes
Image Operand Bias requires 'Dim' parameter to be 1D, 2D, 3D or Cube
Image Operand ConstOffset cannot be used with Cube Image 'Dim'
Image Operand ConstOffsets can only be used with OpImageGather and OpImageDrefGather
Image Operand ConstOffsets cannot be used with Cube Image 'Dim'
Image Operand Grad can only be used with ExplicitLod opcodes
Image Operand Lod can only be used with ExplicitLod opcodes 
Image Operand Lod requires 'Dim' parameter to be 1D, 2D, 3D or Cube
Image Operand MakeTexelAvailableKHR can only be used with Op
Image Operand MakeTexelAvailableKHR requires NonPrivateTexelKHR is also specified: Op
Image Operand MakeTexelVisibleKHR can only be used with Op
Image Operand MakeTexelVisibleKHR requires NonPrivateTexelKHR is also specified: Op
Image Operand MinLod can only be used with ImplicitLod 
Image Operand MinLod requires 'Dim' parameter to be 1D, 2D, 3D or Cube
Image Operand MinLod requires 'MS' parameter to be 0
Image Operand Offset can only be used with OpImage*Gather operations
Image Operand Offset cannot be used with Cube Image 'Dim'
Image Operand Sample can only be used with OpImageFetch, 
Image Operand Sample is required for operation on multi-sampled image
Image Operand Sample requires non-zero 'MS' parameter
Image Operand bits Lod and Grad cannot be set at the same time
Image Operands Offset, ConstOffset, ConstOffsets, Offsets cannot be used together
Image must have either 'MS'=1 or 'Sampled'=0 or 'Sampled'=2
Image1D
ImageArgumentInfoChannelDataTypePushConstant
ImageArgumentInfoChannelDataTypeUniform
ImageArgumentInfoChannelOrderPushConstant
ImageArgumentInfoChannelOrderUniform
ImageBasic
ImageBlockMatchGatherSADQCOM
ImageBlockMatchGatherSSDQCOM
ImageBlockMatchSADQCOM
ImageBlockMatchSSDQCOM
ImageBlockMatchWindowSADQCOM
ImageBlockMatchWindowSSDQCOM
ImageBoxFilterQCOM
ImageBuffer
ImageCubeArray
ImageFootprintNV
ImageGather
ImageGatherBiasLodAMD
ImageGatherExtended
ImageMSArray
ImageMipmap
ImageQuery
ImageQueryFormat
ImageQueryLevels
ImageQueryLod
ImageQueryOrder
ImageQuerySamples
ImageQuerySize
ImageQuerySizeLod
ImageRead
ImageReadWrite
ImageReadWriteLodAMD
ImageRect
ImageSampleDrefExplicitLod
ImageSampleDrefImplicitLod
ImageSampleExplicitLod
ImageSampleFootprintNV
ImageSampleImplicitLod
ImageSampleProjDrefExplicitLod
ImageSampleProjDrefImplicitLod
ImageSampleProjExplicitLod
ImageSampleProjImplicitLod
ImageSampleWeightedQCOM
ImageSparseDrefGather
ImageSparseFetch
ImageSparseGather
ImageSparseSampleDrefExplicitLod
ImageSparseSampleDrefImplicitLod
ImageSparseSampleExplicitLod
ImageSparseSampleImplicitLod
ImageSparseSampleProjDrefExplicitLod
ImageSparseSampleProjDrefImplicitLod
ImageSparseSampleProjExplicitLod
ImageSparseSampleProjImplicitLod
ImageSparseTexelsResident
ImageWrite
Imagination
ImplementInRegisterMapINTEL
ImplicitLod instructions require DerivativeGroupQuadsNV or DerivativeGroupLinearNV execution mode for GLCompute execution model: 
ImplicitLod instructions require Fragment or GLCompute execution model: 
ImportedDeclaration
ImportedModule
In Logical addressing with variable pointers, variables 
In Logical addressing, variables may not allocate a pointer 
In OpPhi instruction 
In SPIR-V 1.6 or later, True Label and False Label must be different labels
In SPIR-V 1.6 or later, sampled image dimension must not be Buffer
In Vulkan, OpImage*Dref* instructions must not use images with a 3D Dim
In Vulkan, OpTypeForwardPointer must have 
In Vulkan, the FPRoundingMode mode must only by RTE or RTZ.
In Vulkan: The OpGroupNonUniformBallotBitCount group operation must be only: Reduce, InclusiveScan, or ExclusiveScan.
In entry points using the MaximallyReconvergesKHR execution mode, True Label and False Label must be different labels
In entry points using the MaximallyReconvergesKHR execution mode, this basic block must not have multiple unique predecessors
In the OpenCL environment, Arrayed may only be set to 1 
In the OpenCL environment, the optional Access Qualifier
In the Vulkan environment, GLCompute execution model entry points require either the LocalSize or LocalSizeId execution mode or an object decorated with WorkgroupSize must be specified.
In the Vulkan environment, cannot store to Uniform Blocks
In the Vulkan environment, the OriginLowerLeft execution mode must not be used.
In the Vulkan environment, the PixelCenterInteger execution mode must not be used.
InBoundsAccessChain
InBoundsPtrAccessChain
Include deleted instructions
InclusiveScan
IncomingCallableDataKHR Storage Class is limited to CallableKHR execution model
IncomingCallableDataNV
IncomingRayFlagsKHR
IncomingRayFlagsNV
IncomingRayPayloadKHR Storage Class is limited to AnyHitKHR, ClosestHitKHR, and MissKHR execution model
IncomingRayPayloadNV
Index 
Index can only be applied to Fragment output variables
Index is out of bounds, can not find index 
Index is out of bounds: 
Indexes passed to 
IndirectReferencesINTEL
Infinite-weight Variable (
InitModeINTEL
InitOnDeviceReprogramINTEL
InitOnDeviceResetINTEL
InitializeNodePayloadsAMDX
Initializer
Initializer type must match the type pointed to by the Result Type
InitiationIntervalINTEL
Inlined
Inlined At
InputAttachment
InputAttachmentArrayDynamicIndexing
InputAttachmentArrayDynamicIndexingEXT
InputAttachmentArrayNonUniformIndexing
InputAttachmentArrayNonUniformIndexingEXT
InputAttachmentIndex
InputLines
InputLinesAdjacency
InputPoints
InputTrianglesAdjacency
Inst unexpectedly deleted
Instance Id must be a 32-bit int scalar
InstanceId
Instruction cannot for logical addressing model be used without a variable pointers capability
Instruction folding details
Instruction reserved for future use, use of this instruction 
Instrument basic blocks, and output profiling information to stdout at the end of program execution.
Instrument compiled code with Address Sanitizer
Int64
Int64Atomics
Int64ImageEXT
Integer 
IntegerFunctions2INTEL
Intel
Intensity
Interface struct has no Block decoration but has BuiltIn members. Location decorations must be used on each member of OpVariable with a structure type that is a block not decorated with Location.
Interface variable id <
Interfaces passed to OpEntryPoint must be of type OpTypeVariable. Found Op
Internal error: Unhandled operand type: 
Internal error: empty execution models for function id 
Internal error: missing function id 
Internal error: unhandled header parse failure
InterpolateAtCentroid
InterpolateAtOffset
InterpolateAtSample
InterpolateAtVertexAMD
Invalid 
Invalid 16-bit float literal: 
Invalid 32-bit float literal: 
Invalid 64-bit float literal: 
Invalid Arrayed 
Invalid Call dest type
Invalid Depth 
Invalid MS 
Invalid OpSwitch: selector id 
Invalid Opcode name 'Op
Invalid RAK_Unknown
Invalid SPIR-V binary version 
Invalid SPIR-V header.
Invalid SPIR-V magic number '
Invalid SPIR-V magic number.
Invalid SPIR-V.  The id bound is larger than the max id bound 
Invalid Sampled 
Invalid SearchSpan size
Invalid extended instruction import '
Invalid extended instruction number: 
Invalid instruction Op
Invalid instruction word count: 
Invalid number of bits (
Invalid opcode: 
Invalid pointer storage class
Invalid range 
Invalid scope value:\n 
Invalid signed integer literal: 
Invalid storage class for pointer operand 
Invalid storage class for target environment
Invalid type for SignMask intrinsic
Invalid type to assign a location
Invalid unsigned integer literal: 
Invalid use of 8- or 16-bit result
Invalid use of function result id 
Invalid use of function type result id 
Invalid vector multiply type
Invalid word count: Op
InvalidateAfterReadINTEL
Invariant
InverseSqrt
Invocations
InvocationsPerPixelNV
IsFinite
IsHelperInvocationEXT
IsInf
IsNan
IsNormal
IsValidEvent
IsValidReserveId
Isolines
IterationMultiple
IterationMultiple loop control operand must be greater than zero
Its Storage Class operand must be the same as the Storage Class 
Kernel must be a Kernel extended instruction
Kernel must be from the same extended instruction import
Khronos
Khronos Glslang Reference Front End
Khronos LLVM/SPIR-V Translator
Khronos SPIR-V Tools Assembler
Khronos SPIR-V Tools Linker
Kill
LLVM
LLVM ERROR: 
LLVM LLVM SPIR-V Backend
LLVM file (default)
Label instructions must be in a function body
Language
LatencyControlConstraintINTEL
LatencyControlLabelINTEL
LaunchIdKHR
LaunchIdNV
LaunchSizeKHR
LaunchSizeNV
LayerPerViewNV
Ldexp
Length is not defined.
LessOrGreater
Let register allocation use reserve registers
LifetimeStart
LifetimeStop
Linear
Linear scan details
LinkOnceODR
Linkage
Linkage Name
LinkageAttributes
Linker: LLD 19.0.0
Literal string is longer than 
LiteralSampler
Liveness information
Local Variable
Local common subexpression elimination
Local variable exceeds stack size limit
LocalSizeHint
LocalSizeHintId
LocalSizeId
LocalSizeId mode is not allowed by the current environment.
Location
Location decoration can only be applied to a variable or member of a structure type
Log2
Logical addressing not supported: 
LogicalEqual
LogicalNot
LogicalNotEqual
LongCompositesINTEL
Loop header 
Loop nest depth analysis
LoopCoalesceINTEL
LoopControlINTEL
LoopCountINTEL
LoopFuseINTEL
LoopMerge
Low-level integrated assembly ('.s') file
Luminance
LunarG
MMHostInterfaceAddressWidthINTEL
MMHostInterfaceDataWidthINTEL
MMHostInterfaceLatencyINTEL
MMHostInterfaceMaxBurstINTEL
MMHostInterfaceReadWriteModeINTEL
MMHostInterfaceWaitRequestINTEL
MS must be 0 in the OpenCL environment.
MakeAvailable
MakeAvailableKHR
MakePointerAvailable
MakePointerAvailableKHR cannot be used with OpLoad.
MakePointerVisible
MakePointerVisibleKHR cannot be used with OpStore.
MakePointerVisibleKHR is specified.
MakeTexelAvailable
MakeTexelAvailableKHR
MakeTexelVisible
MakeTexelVisibleKHR
MakeVisible
MakeVisibleKHR
Mask must be a 32-bit unsigned integer OpConstant
MaskedGatherINTEL
MaskedGatherScatterINTEL
MaskedScatterINTEL
MathOpDSPModeINTEL
Matrix access is out of bounds, matrix has 
Matrix types can only be parameterized as having only 2, 3, or 4 columns.
Matrix types can only be parameterized with floating-point types.
MatrixAKHR
MatrixASignedComponentsKHR
MatrixAccumulatorKHR
MatrixBKHR
MatrixBSignedComponentsKHR
MatrixCSignedComponentsKHR
MatrixInverse
MatrixResultSignedComponentsKHR
MatrixStride
MatrixTimesMatrix
MatrixTimesScalar
MatrixTimesVector
Max number of nops to insert per instruction
MaxByteOffset
MaxByteOffsetId
MaxConcurrencyINTEL
MaxInterleavingINTEL
MaxIterations
MaxNodeRecursionAMDX
MaxNumWorkgroupsAMDX
MaxPrivateCopiesINTEL
MaxReinvocationDelayINTEL
MaxReplicatesINTEL
MaxWorkDimINTEL
MaxWorkgroupSizeINTEL
MaximallyReconvergesKHR
Maximum Control Flow nesting depth exceeded.
MaximumRegistersIdINTEL
MbcntAMD
Member #
Member index 
MemberDecorateString
MemberDecorateStringGOOGLE
MemberName
Members cannot be assigned a location
Memory Semantics Acquire and AcquireRelease cannot be used with 
Memory Semantics Volatile can only be used with atomic instructions
Memory Semantics ids must be OpConstant when Shader capability is present
Memory Semantics must be a constant instruction when CooperativeMatrixNV capability is present
Memory accesses with PhysicalStorageBuffer must use Aligned.
Memory model must be OpenCL in the OpenCL environment.
Memory usage details
MemoryAccessAliasingINTEL
MemoryBarrier
MemoryLayout operand <id> 
MemoryNamedBarrier
Merge Block 
Merge Block and Continue Target must be different ids
Merge Block may not be the block containing the OpLoopMerge\n
MergeINTEL
MeshEXT
MeshEXT execution model entry points must specify both OutputPrimitivesEXT and OutputVertices Execution Modes.
MeshEXT execution model entry points must specify exactly one of OutputPoints, OutputLinesEXT, or OutputTrianglesEXT Execution Modes.
MeshNV
MeshShadingEXT
MeshShadingNV
MeshViewCountNV
MeshViewIndicesNV
Meta
Meta SparkSL
Mikkosoft Productions
Mikkosoft Productions MSP Shader Compiler
MinIterations
MinLod
Minus
Miss Index must be a 32-bit int scalar
MissKHR
Missing NonSemantic.ClspvReflection import version
Missing OpFunctionEnd at end of module.
Missing argument 
Missing decoration 
Missing function type definition.
Missing module.
Missing required OpMemoryModel instruction.
Missing required OpSamplerImageAddressingModeNV instruction.
Mock bounds checking on loads/stores
Modf
ModfStruct
Module can't mix MeshEXT/TaskEXT with MeshNV/TaskNV Execution Model.
Module contains unreachable blocks during merge return.  Run dead branch elimination before merge return.
Module has incomplete header: only 
ModuleProcessed
MultiView
MultiViewport
Multiple case constructs have branches to the case construct that targets 
Multiply
Must be only one constituent
N10__cxxabiv116__shim_type_infoE
N10__cxxabiv117__class_type_infoE
N10__cxxabiv120__si_class_type_infoE
N10__cxxabiv121__vmi_class_type_infoE
NClamp
NMax
NMin
NONE
NSt4__Cr10__stdinbufIcEE
NSt4__Cr10__stdinbufIwEE
NSt4__Cr10__time_putE
NSt4__Cr10ctype_baseE
NSt4__Cr10money_baseE
NSt4__Cr10moneypunctIcLb0EEE
NSt4__Cr10moneypunctIcLb1EEE
NSt4__Cr10moneypunctIwLb0EEE
NSt4__Cr10moneypunctIwLb1EEE
NSt4__Cr11__money_getIcEE
NSt4__Cr11__money_getIwEE
NSt4__Cr11__money_putIcEE
NSt4__Cr11__money_putIwEE
NSt4__Cr11__stdoutbufIcEE
NSt4__Cr11__stdoutbufIwEE
NSt4__Cr12__do_messageE
NSt4__Cr12codecvt_baseE
NSt4__Cr12system_errorE
NSt4__Cr13basic_filebufIcNS_11char_traitsIcEEEE
NSt4__Cr13basic_istreamIcNS_11char_traitsIcEEEE
NSt4__Cr13basic_istreamIwNS_11char_traitsIwEEEE
NSt4__Cr13basic_ostreamIcNS_11char_traitsIcEEEE
NSt4__Cr13basic_ostreamIwNS_11char_traitsIwEEEE
NSt4__Cr13messages_baseE
NSt4__Cr14__num_get_baseE
NSt4__Cr14__num_put_baseE
NSt4__Cr14__shared_countE
NSt4__Cr14basic_iostreamIcNS_11char_traitsIcEEEE
NSt4__Cr15basic_streambufIcNS_11char_traitsIcEEEE
NSt4__Cr15basic_streambufIwNS_11char_traitsIwEEEE
NSt4__Cr15basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt4__Cr16__narrow_to_utf8ILm32EEE
NSt4__Cr17__widen_from_utf8ILm32EEE
NSt4__Cr18basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt4__Cr19__iostream_categoryE
NSt4__Cr19basic_istringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt4__Cr19basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt4__Cr20__time_get_c_storageIcEE
NSt4__Cr20__time_get_c_storageIwEE
NSt4__Cr23__system_error_categoryE
NSt4__Cr24__generic_error_categoryE
NSt4__Cr5ctypeIcEE
NSt4__Cr5ctypeIwEE
NSt4__Cr6locale5__impE
NSt4__Cr6locale5facetE
NSt4__Cr7codecvtIDiDu11__mbstate_tEE
NSt4__Cr7codecvtIDic11__mbstate_tEE
NSt4__Cr7codecvtIDsDu11__mbstate_tEE
NSt4__Cr7codecvtIDsc11__mbstate_tEE
NSt4__Cr7codecvtIcc11__mbstate_tEE
NSt4__Cr7codecvtIwc11__mbstate_tEE
NSt4__Cr7collateIcEE
NSt4__Cr7collateIwEE
NSt4__Cr7num_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEE
NSt4__Cr7num_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEE
NSt4__Cr7num_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEE
NSt4__Cr7num_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEE
NSt4__Cr8ios_base7failureE
NSt4__Cr8ios_baseE
NSt4__Cr8messagesIcEE
NSt4__Cr8messagesIwEE
NSt4__Cr8numpunctIcEE
NSt4__Cr8numpunctIwEE
NSt4__Cr8time_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEE
NSt4__Cr8time_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEE
NSt4__Cr8time_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEE
NSt4__Cr8time_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEE
NSt4__Cr9__num_getIcEE
NSt4__Cr9__num_getIwEE
NSt4__Cr9__num_putIcEE
NSt4__Cr9__num_putIwEE
NSt4__Cr9basic_iosIcNS_11char_traitsIcEEEE
NSt4__Cr9basic_iosIwNS_11char_traitsIwEEEE
NSt4__Cr9money_getIcNS_19istreambuf_iteratorIcNS_11char_traitsIcEEEEEE
NSt4__Cr9money_getIwNS_19istreambuf_iteratorIwNS_11char_traitsIwEEEEEE
NSt4__Cr9money_putIcNS_19ostreambuf_iteratorIcNS_11char_traitsIcEEEEEE
NSt4__Cr9money_putIwNS_19ostreambuf_iteratorIwNS_11char_traitsIwEEEEEE
NSt4__Cr9time_baseE
NULL
NVIDIA
NVIDIA Slang Compiler
NZSL
Name must match an entry-point for Kernel
NamedBarrierCountINTEL
NamedBarrierInitialize
NamedMaximumRegistersINTEL
Native ELF object ('.o') file
Nearest
Negative
Netease Games
Netease Games Messiah Shader Compiler
No OpEntryPoint instruction was found. This is only allowed if the Linkage capability is being used.
No verbosity
NoAlias
NoAliasINTEL
NoAliasINTELMask
NoCapture
NoContraction
NoFusionINTEL
NoGlobalOffsetINTEL
NoPerspective
NoReadWrite
NoSignedWrap
NoUnsignedWrap
NoWait
NoWrite
NodeMaxPayloadsAMDX
NodeOutputPayloadAMDX
NodeSharesPayloadLimitsWithAMDX
Non-OpFunctionParameter (opcode: %d) found inside function but outside basic block
Non-semantic OpExtInst must not appear before types 
Non-semantic OpExtInst within function definition must appear in a block
Non-unique OpEntryPoint interface 
NonCoherentColorAttachmentReadEXT
NonCoherentDepthAttachmentReadEXT
NonCoherentStencilAttachmentReadEXT
NonPrivatePointer
NonPrivatePointerKHR
NonPrivatePointerKHR must be specified if 
NonPrivatePointerKHR must be specified if MakePointerAvailableKHR is specified.
NonPrivatePointerKHR requires a pointer in Uniform, 
NonPrivateTexel
NonPrivateTexelKHR
NonReadable
NonSemantic extended instruction sets cannot be declared without SPV_KHR_non_semantic_info.
NonSemantic.
NonSemantic.ClspvReflection import does not encode the version correctly
NonSemantic.ClspvReflection.
NonSemantic.Debu
NonSemantic.Shader.DebugInfo.100
NonSemantic.VkspReflection.
NonWritable
Nontemporal
Nop insertion probability as percentage
Normalize
NormalizedSamplerMaskPushConstant
NotInf
NotNaN
NumArguments must be a 32-bit unsigned integer OpConstant
NumEnqueuedSubgroups
NumSIMDWorkitemsINTEL
NumbanksINTEL
Number of (literal, label) pairs in OpSwitch (
Number of Global Variables (Storage Class other than 'Function') exceeded the valid limit (
Number of OpTypeStruct members (
Number of image operand ids doesn't correspond to the bit mask
Number of local variables ('Function' Storage Class) exceeded the valid limit (
Number of times local-cse is run on a block
Number of translation threads (0 for purely sequential)
ONonSemantic.ShadT
OPTIONS:\n
OVERVIEW: 
ObjectOffset must be a 32-bit unsigned integer OpConstant
Only use specified registers for corresponding register classes
OpBeginInvocationInterlockEXT/OpEndInvocationInterlockEXT require Fragment execution model
OpBeginInvocationInterlockEXT/OpEndInvocationInterlockEXT require a fragment shader interlock execution mode.
OpBranch or OpBranchConditional instruction. 
OpBranchConditional or OpSwitch instruction. 
OpBranchConditional requires either 3 or 5 parameters
OpConstant with a 32- or 64-bits integer scalar type or 
OpConstant, DebugGlobalVariable, or 
OpConstantNull Result Type <id> 
OpConstantSampler Result Type <id> 
OpControlBarrier requires one of the following Execution Models: TessellationControl, GLCompute, Kernel, MeshNV or TaskNV
OpCopyObject cannot have void result type
OpDecorate decoration '
OpDecorate, OpDecorateId, and OpGroupMemberDecorate
OpDemoteToHelperInvocationEXT requires Fragment execution model
OpEmitMeshTasksEXT requires TaskEXT execution model
OpEntryPoint Entry Point <id> 
OpEntryPoint interfaces must be OpVariables with Storage Class of Input(1) or Output(3). Found Storage Class 
OpEntryPoint interfaces should only list global variables
OpExecuteCallableKHR requires RayGenerationKHR, ClosestHitKHR, MissKHR and CallableKHR execution models
OpExecutionMode Entry Point <id> 
OpExecutionMode is only valid when the Mode operand is an execution mode that takes no Extra Operands, or takes Extra Operands that are not id operands.
OpExecutionModeId is only valid when the Mode operand is an execution mode that takes Extra Operands that are id operands.
OpExtInst set Id 
OpFunction Function Type <id> 
OpFunction Result Type <id> 
OpFunctionCall Argument <id> 
OpFunctionCall Function <id> 
OpFunctionCall Function <id>'s parameter count does not match the argument count.
OpFunctionCall Result Type <id> 
OpFunctionEnd inside basic block
OpFunctionEnd without corresponding OpFunction
OpFunctionParameter 
OpFunctionParameter Result Type <id> 
OpGroupDecorate Decoration group <id> 
OpGroupDecorate may not target OpDecorationGroup <id> 
OpGroupMemberDecorate Decoration group <id> 
OpGroupMemberDecorate Structure type <id> 
OpIgnoreIntersectionKHR requires AnyHitKHR execution model
OpImageQueryLevels must only consume an "Image" operand whose type has its "Sampled" operand set to 1
OpImageQueryLod requires DerivativeGroupQuadsNV or DerivativeGroupLinearNV execution mode for GLCompute execution model
OpImageQueryLod requires Fragment or GLCompute execution model
OpImageQuerySizeLod must only consume an "Image" operand whose type has its "Sampled" operand set to 1
OpImageRead, OpImageWrite, OpImageSparseFetch and 
OpImageSparseRead
OpIsHelperInvocationEXT requires Fragment execution model
OpKill requires Fragment execution model
OpLabel inside basic block
OpLabel outside function
OpLine Target <id> 
OpLoad Pointer <id> 
OpLoad Result Type <id> 
OpLoad type for pointer <id> 
OpLoopMerge must be the second-to-last instruction in 
OpLoopMerge must immediately precede either an 
OpMemberDecorate Structure type <id> 
OpMemberName Member <id> 
OpMemberName Type <id> 
OpMemoryModel should only be provided once.
OpPhi does not have an equal number of incoming values and basic blocks.
OpPhi must appear within a non-entry block before all 
OpPhi must not have void result type
OpPhi references incoming basic block <id> 
OpPhi's incoming basic block <id> 
OpPhi's number of incoming blocks (
OpPhi's result type <id> 
OpPtrAccessChain Base operand must point to Workgroup, StorageBuffer, or PhysicalStorageBuffer storage class
OpPtrAccessChain Base operand pointing to StorageBuffer storage class must use VariablePointers or VariablePointersStorageBuffer capability
OpPtrAccessChain Base operand pointing to Workgroup storage class must use VariablePointers capability
OpPtrAccessChain must have a Base whose type is decorated with ArrayStride
OpReportIntersectionKHR requires IntersectionKHR execution model
OpReturn can only be called from a function with void 
OpReturnValue Value <id> 
OpReturnValue value's type <id> 
OpSamplerImageAddressingModeNV bitwidth should be 64 or 32
OpSamplerImageAddressingModeNV should only be provided once
OpSamplerImageAddressingModeNV supported only with extension SPV_NV_bindless_texture
OpSelectionMerge must be the second-to-last 
OpSelectionMerge must immediately precede either an 
OpSetMeshOutputsEXT requires MeshEXT execution model
OpSpecConstant opcode table out of sync
OpSpecConstantOp opcode
OpStore Object <id> 
OpStore Pointer <id> 
OpStore type for pointer <id> 
OpSwitch must be preceded by an OpSelectionMerge instruction
OpTerminateInvocation requires Fragment execution model
OpTerminateRayKHR requires AnyHitKHR execution model
OpTraceRayKHR requires RayGenerationKHR, ClosestHitKHR and MissKHR execution models
OpTypeArray Element Type <id> 
OpTypeArray Length <id> 
OpTypeCooperativeMatrix Cols <id> 
OpTypeCooperativeMatrix Component Type <id> 
OpTypeCooperativeMatrix Rows <id> 
OpTypeCooperativeMatrix Scope <id> 
OpTypeCooperativeMatrixKHR Use <id> 
OpTypeFunction Parameter Type <id> 
OpTypeFunction Return Type <id> 
OpTypeFunction may not take more than 
OpTypeInt has invalid signedness:
OpTypePointer Type <id> 
OpTypeRuntimeArray Element Type <id> 
OpTypeRuntimeArray must be decorated with Block if it 
OpTypeRuntimeArray must be decorated with BufferBlock 
OpTypeRuntimeArray.\nFor Vulkan OpTypeRuntimeArray can only 
OpTypeSampledImage, OpTypeAccelerationStructureKHR, 
OpTypeStruct Member Type <id> 
OpTypeVector Component Type <id> 
OpVariable 
OpVariable Initializer <id> 
OpVariable Result Type <id> 
OpVariable storage class cannot be Generic
OpVariable, <id> 
OpVectorShuffle component literals count does not match Result Type <id> 
Opaque_
Opcode 
OpenCL.DebugInfo.100
OpenCL.DebugInfo.100 debug base type encoding
OpenCL.DebugInfo.100 debug composite type
OpenCL.DebugInfo.100 debug imported entity
OpenCL.DebugInfo.100 debug info flags
OpenCL.DebugInfo.100 debug operation
OpenCL.DebugInfo.100 debug type qualifier
OpenCL.std
OpenCL_C
OpenCL_CPP
OpenGL
Operand
Operand 
Operand type must be a pointer
OptNoneINTEL
Optimization level
Optional Image Operands are not allowed in the OpenCL 
Ordered
Ordinal must be a 32-bit unsigned integer OpConstant
OriginLowerLeft
OriginUpperLeft
Other warnings have been suppressed.\n
OuterProduct
Output file type
OutputLineStrip
OutputLinesEXT
OutputLinesNV
OutputMemory
OutputMemoryKHR
OutputPoints
OutputPrimitivesEXT
OutputPrimitivesNV
OutputTriangleStrip
OutputTrianglesEXT
OutputTrianglesNV
OutputVertices
Override output filename
Override with -verbose=none except for specified functions
PNaCl bitcode file
PackDouble2x32
PackHalf2x16
PackSnorm2x16
PackSnorm4x8
PackUnorm2x16
PackUnorm4x8
PackedVectorFormat4x8Bit
PackedVectorFormat4x8BitKHR
Parameter Types
Parent
Parse function blocks in parallel
PartialCount
PartialCount and DontUnroll loop controls must not both be specified
PartitionedInclusiveScanNV
PartitionedReduceNV
Patch
Payload OpVariable must have a storage class of TaskPayloadWorkgroupEXT
Payload must be the result of a OpVariable
Payload must have storage class RayPayloadKHR or IncomingRayPayloadKHR
PayloadNodeNameAMDX
PeelCount
PeelCount and DontUnroll loop controls must not both be specified
Per-component robustness and per-element robustness are mutually exclusive.
PerPrimitiveEXT
PerPrimitiveNV
PerTaskNV
PerVertexKHR
PerVertexKHR can only be applied to Fragment Execution Models
PerVertexKHR must be declared as arrays
PerVertexNV
PerViewAttributesNV
Phi error: missing label for incoming edge
Phi found in regular instruction list
Phi instruction added to the middle of a block
Physical register origins
Physical32
Physical64
PhysicalStorageBuffer
PhysicalStorageBuffer must not be used with OpVariable.
PhysicalStorageBuffer64
PhysicalStorageBuffer64 addressing mode requires the input integer to have a 64-bit width for Vulkan environment.
PhysicalStorageBuffer64 addressing mode requires the result integer type to have a 64-bit width for Vulkan environment.
PhysicalStorageBuffer64EXT
PhysicalStorageBufferAddresses
PhysicalStorageBufferAddressesEXT
PhysicalStorageBufferEXT
PipelineEnableINTEL
Pipes
PixelCenterInteger
PixelInterlockOrderedEXT
PixelInterlockUnorderedEXT
PixelRoutine_%0.8X
Plus
PlusUconst
PointMode
Pointer can only be converted to another pointer or int scalar: 
Pointer can only be converted to another pointer, int scalar or 32-bit int vector: 
Pointer operand 
Pointer storage class must be PhysicalStorageBuffer: 
Pointer type in OpTypeForwardPointer is not a pointer type.
PointerOffset must be a 32-bit unsigned integer OpConstant
PointerSize must be a 32-bit unsigned integer OpConstant
PositionPerViewNV
Possible misaligned vector memory operation
Predicate must be a boolean scalar
Predicate must be a boolean scalar type
PrefetchINTEL
Prepend a prefix to symbol names for testing
Primitive Count must be a 32-bit unsigned int scalar
Primitive Id must be a 32-bit int scalar
PrimitiveCountNV
PrimitiveId
PrimitiveIndicesNV
PrimitiveLineIndicesEXT
PrimitivePointIndicesEXT
PrimitiveShadingRateKHR
PrimitiveTriangleIndicesEXT
Print all option values after command line parsing
Print basic instructions
Print instruction numbers
Print non-default options after command line parsing
Print out more descriptive PNaCl bitcode parse errors when building LLVM IR first
Print statistics after translating each function
Print the name of the function being translated
Print total translation time for each function
PrintfBufferPointerPushConstant
PrintfBufferStorageBuffer
PrintfID must be a 32-bit unsigned integer OpConstant
PrintfInfo
Prior to SPIR-V 1.4, specialization constant operation UConvert requires Kernel capability or extension SPV_AMD_gpu_shader_int16
Processor
Profiler
ProgramScopeVariablePointerPushConstant
ProgramScopeVariablePointerRelocation
ProgramScopeVariablesStorageBuffer
PropertyRequiredWorkgroupSize
PtrCastToCrossWorkgroupINTEL
PtrCastToGeneric
PtrDiff
PtrEqual
PtrNotEqual
Pure
Pure virtual function called!
PushConstant OpVariable <id> 
PushConstant id '
PushConstantEnqueuedLocalSize
PushConstantGlobalOffset
PushConstantGlobalSize
PushConstantNumWorkgroups
PushConstantRegionGroupOffset
PushConstantRegionOffset
QuadControlKHR
QuadDerivativesKHR
Quads
Qualcomm
QuantizeToF16
Queue<%p>
QueueFamily
QueueFamilyKHR
R11fG11fB10f
R16Snorm
R16f
R16i
R16ui
R32f
R32i
R32ui
R64i
R64ui
R8Snorm
R8ui
RND_CONV
RND_CONV_ODD
RND_INF
RND_MIN_INF
RND_ZERO
Radians
RawAccessChainNV
RawAccessChainsNV
Ray Direction must be a 32-bit float 3-component vector
Ray Flags must be a 32-bit int scalar
Ray Origin must be a 32-bit float 3-component vector
Ray Query must be a memory object declaration
Ray Query must be a pointer
Ray Query must be a pointer to OpTypeRayQueryKHR
Ray TMax must be a 32-bit float scalar
Ray TMin must be a 32-bit float scalar
RayCullMaskKHR
RayGenerationKHR
RayGenerationNV
RayGeometryIndexKHR
RayPayloadKHR Storage Class is limited to RayGenerationKHR, ClosestHitKHR, and MissKHR execution model
RayQueryCandidateIntersectionAABBKHR
RayQueryCandidateIntersectionKHR
RayQueryCandidateIntersectionTriangleKHR
RayQueryCommittedIntersectionGeneratedKHR
RayQueryCommittedIntersectionKHR
RayQueryCommittedIntersectionNoneKHR
RayQueryCommittedIntersectionTriangleKHR
RayQueryConfirmIntersectionKHR
RayQueryGenerateIntersectionKHR
RayQueryGetIntersectionBarycentricsKHR
RayQueryGetIntersectionCandidateAABBOpaqueKHR
RayQueryGetIntersectionFrontFaceKHR
RayQueryGetIntersectionGeometryIndexKHR
RayQueryGetIntersectionInstanceCustomIndexKHR
RayQueryGetIntersectionInstanceIdKHR
RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR
RayQueryGetIntersectionObjectRayDirectionKHR
RayQueryGetIntersectionObjectRayOriginKHR
RayQueryGetIntersectionObjectToWorldKHR
RayQueryGetIntersectionPrimitiveIndexKHR
RayQueryGetIntersectionTKHR
RayQueryGetIntersectionTriangleVertexPositionsKHR
RayQueryGetIntersectionTypeKHR
RayQueryGetIntersectionWorldToObjectKHR
RayQueryGetRayFlagsKHR
RayQueryGetRayTMinKHR
RayQueryGetWorldRayDirectionKHR
RayQueryGetWorldRayOriginKHR
RayQueryInitializeKHR
RayQueryPositionFetchKHR
RayQueryProceedKHR
RayQueryProvisionalKHR
RayQueryTerminateKHR
RayTmaxKHR
RayTmaxNV
RayTminKHR
RayTminNV
RayTracingDisplacementMicromapNV
RayTracingKHR
RayTracingMotionBlurNV
RayTracingNV
RayTracingOpacityMicromapEXT
RayTracingPositionFetchKHR
RayTracingProvisionalKHR
RayTraversalPrimitiveCullingKHR
Rayan Hatout
Rayan Hatout SPIRVSmith
Reached non-composite type while indexes still remain to be traversed.
ReadClockKHR
ReadModifyWrite optimization
ReadOnly
ReadPipeBlockingINTEL
ReadWriteINTEL
RecurrentAddExpr
ReferencedIndirectlyINTEL
Reflect
Refract
RegisterINTEL
RegisterLimitsINTEL
RegisterMapInterfaceINTEL
RegisterMapKernelArgumentINTEL
RelaxPrecision decoration cannot be applied to a type
Relaxed
RelaxedPrecision
ReleaseEvent
Rendong Liang
Rendong Liang spq
ReorderThreadWithHintNV
ReorderThreadWithHitObjectNV
Repeat
Repeat register allocation until convergence
RepeatMirrored
ReportIntersectionKHR
ReportIntersectionNV
RequireFullQuadsKHR
ReservedReadPipe
ReservedWritePipe
RestoreMemoryINTEL
Restrict
Restrict local var splitting to specific insts
RestrictPointer
RestrictPointerEXT
RestrictType
Result <id> '
Result <id> from OpSampledImage instruction must not appear as operand for Op
Result <id> from OpSampledImage instruction must not appear as operands of Op
Result Type does not logically match the Operand type
Result Type has 
Result Type must be OpTypeBool
Result Type must be an integer scalar
Result Type must be the same as the type of Value.
Result Type must not equal the Operand type
Result Type vector size: 
Result Type's second member
Result id of OpDecorationGroup can only 
Result must be a 4-component unsigned integer vector
Result must be a boolean scalar
Result must be a boolean scalar or vector
Result must be a boolean scalar type
Result must be a floating-point scalar or vector
Result must be a scalar or vector of integer, floating-point, or boolean type
Result must be an integer scalar or vector
Result must be an unsigned integer scalar
Result must be an unsigned integer scalar or vector
Result of OpExpectKHR must be a scalar or vector of integer type or boolean type
Result type (Op
Result type cannot be Op
Result type component width must be 32 bits
Result type is not defined.
Retain deleted instructions in the Cfg
RetainEvent
Return
Return Type
Return Type must be OpTypeVoid
ReturnValue
Rg16
Rg16Snorm
Rg16f
Rg16i
Rg16ui
Rg32f
Rg32i
Rg32ui
Rg8Snorm
Rg8i
Rg8ui
Rgb10A2
Rgb10a2ui
Rgba16
Rgba16Snorm
Rgba16f
Rgba16i
Rgba16ui
Rgba32f
Rgba32i
Rgba32ui
Rgba8
Rgba8Snorm
Rgba8i
Rgba8ui
RobustnessPerComponentNV
RobustnessPerElementNV
Round
RoundEven
RoundToInfinityINTEL
RoundingModeRTE
RoundingModeRTNINTEL
RoundingModeRTPINTEL
RoundingModeRTZ
RowMajor
RowMajorKHR
RuntimeAlignedAttributeINTEL
RuntimeAlignedINTEL
RuntimeDescriptorArray
RuntimeDescriptorArrayEXT
SAT_SYM
SAT_ZERO
SAbs
SBT Index must be a 32-bit unsigned int scalar
SBT Offset must be a 32-bit int scalar
SBT Offset must be a 32-bit unsigned int scalar
SBT Stride must be a 32-bit int scalar
SBT Stride must be a 32-bit unsigned int scalar
SBT record offset must be a 32-bit unsigned int scalar
SBT record stride must be a 32-bit unsigned int scalar
SClamp
SConvert
SDiv
SDot
SDotAccSat
SDotAccSatKHR
SDotKHR
SGreaterThan
SGreaterThanEqual
SIMTCallINTEL
SLessThan
SLessThanEqual
SMCountNV
SMIDNV
SMax3AMD
SMid3AMD
SMin3AMD
SMod
SMulExtended
SNegate
SPIR-V 1.0
SPIR-V 1.0 (under OpenCL 1.2 Embedded Profile semantics)
SPIR-V 1.0 (under OpenCL 1.2 Full Profile semantics)
SPIR-V 1.0 (under OpenCL 2.0 Embedded Profile semantics)
SPIR-V 1.0 (under OpenCL 2.0 Full Profile semantics)
SPIR-V 1.0 (under OpenCL 2.1 Embedded Profile semantics)
SPIR-V 1.0 (under OpenCL 2.1 Full Profile semantics)
SPIR-V 1.0 (under OpenGL 4.0 semantics)
SPIR-V 1.0 (under OpenGL 4.1 semantics)
SPIR-V 1.0 (under OpenGL 4.2 semantics)
SPIR-V 1.0 (under OpenGL 4.3 semantics)
SPIR-V 1.0 (under OpenGL 4.5 semantics)
SPIR-V 1.0 (under Vulkan 1.0 semantics)
SPIR-V 1.1
SPIR-V 1.2
SPIR-V 1.2 (under OpenCL 2.2 Embedded Profile semantics)
SPIR-V 1.2 (under OpenCL 2.2 Full Profile semantics)
SPIR-V 1.3
SPIR-V 1.3 (under Vulkan 1.1 semantics)
SPIR-V 1.4
SPIR-V 1.4 (under Vulkan 1.1 semantics)
SPIR-V 1.5
SPIR-V 1.5 (under Vulkan 1.2 semantics)
SPIR-V 1.6
SPIR-V 1.6 (under Vulkan 1.3 semantics)
SPIR-V DEBUG: %d:%d %s\n
SPIR-V ERROR: %d:%d %s\n
SPIR-V FATAL: %d:%d %s\n
SPIR-V INFO: %d:%d %s\n
SPIR-V INTERNAL_ERROR: %d:%d %s\n
SPIR-V MESSAGE: %d:%d %s\n
SPIR-V WARNING: %d:%d %s\n
SPV_AMDX_shader_enqueue
SPV_AMD_gcn_shader
SPV_AMD_gpu_shader_half_float
SPV_AMD_gpu_shader_half_float_fetch
SPV_AMD_shader_ballot
SPV_AMD_shader_early_and_late_fragment_tests
SPV_AMD_shader_explicit_vertex_parameter
SPV_AMD_shader_fragment_mask
SPV_AMD_shader_image_load_store_lod
SPV_AMD_shader_trinary_minmax
SPV_AMD_texture_gather_bias_lod
SPV_ARM_core_builtins
SPV_EXT_demote_to_helper_invocation
SPV_EXT_descriptor_indexing
SPV_EXT_fragment_fully_covered
SPV_EXT_fragment_invocation_density
SPV_EXT_fragment_shader_interlock
SPV_EXT_mesh_shader
SPV_EXT_opacity_micromap
SPV_EXT_physical_storage_buffer
SPV_EXT_shader_atomic_float16_add
SPV_EXT_shader_atomic_float_add
SPV_EXT_shader_atomic_float_min_max
SPV_EXT_shader_image_int64
SPV_EXT_shader_stencil_export
SPV_EXT_shader_tile_image
SPV_EXT_shader_viewport_index_layer
SPV_GOOGLE_decorate_string
SPV_GOOGLE_hlsl_functionality1
SPV_GOOGLE_user_type
SPV_INTEL_arbitrary_precision_fixed_point
SPV_INTEL_arbitrary_precision_floating_point
SPV_INTEL_arbitrary_precision_integers
SPV_INTEL_bfloat16_conversion
SPV_INTEL_blocking_pipes
SPV_INTEL_cache_controls
SPV_INTEL_debug_module
SPV_INTEL_device_side_avc_motion_estimation
SPV_INTEL_float_controls2
SPV_INTEL_fp_fast_math_mode
SPV_INTEL_fp_max_error
SPV_INTEL_fpga_argument_interfaces
SPV_INTEL_fpga_buffer_location
SPV_INTEL_fpga_cluster_attributes
SPV_INTEL_fpga_dsp_control
SPV_INTEL_fpga_invocation_pipelining_attributes
SPV_INTEL_fpga_latency_control
SPV_INTEL_fpga_loop_controls
SPV_INTEL_fpga_memory_accesses
SPV_INTEL_fpga_memory_attributes
SPV_INTEL_fpga_reg
SPV_INTEL_function_pointers
SPV_INTEL_global_variable_fpga_decorations
SPV_INTEL_global_variable_host_access
SPV_INTEL_inline_assembly
SPV_INTEL_io_pipes
SPV_INTEL_kernel_attributes
SPV_INTEL_long_composites
SPV_INTEL_loop_fuse
SPV_INTEL_masked_gather_scatter
SPV_INTEL_maximum_registers
SPV_INTEL_media_block_io
SPV_INTEL_memory_access_aliasing
SPV_INTEL_optnone
SPV_INTEL_runtime_aligned
SPV_INTEL_shader_integer_functions2
SPV_INTEL_split_barrier
SPV_INTEL_subgroups
SPV_INTEL_unstructured_loop_controls
SPV_INTEL_usm_storage_classes
SPV_INTEL_variable_length_array
SPV_INTEL_vector_compute
SPV_KHR_16bit_storage
SPV_KHR_8bit_storage
SPV_KHR_bit_instructions
SPV_KHR_cooperative_matrix
SPV_KHR_device_group
SPV_KHR_expect_assume
SPV_KHR_float_controls
SPV_KHR_float_controls2
SPV_KHR_fragment_shader_barycentric
SPV_KHR_fragment_shading_rate
SPV_KHR_integer_dot_product
SPV_KHR_linkonce_odr
SPV_KHR_maximal_reconvergence
SPV_KHR_multiview
SPV_KHR_no_integer_wrap_decoration
SPV_KHR_non_semantic_info
SPV_KHR_physical_storage_buffer
SPV_KHR_post_depth_coverage
SPV_KHR_quad_control
SPV_KHR_ray_cull_mask
SPV_KHR_ray_query
SPV_KHR_ray_tracing
SPV_KHR_ray_tracing_position_fetch
SPV_KHR_shader_atomic_counter_ops
SPV_KHR_shader_ballot
SPV_KHR_shader_clock
SPV_KHR_shader_draw_parameters
SPV_KHR_storage_buffer_storage_class
SPV_KHR_subgroup_rotate
SPV_KHR_subgroup_uniform_control_flow
SPV_KHR_subgroup_vote
SPV_KHR_terminate_invocation
SPV_KHR_uniform_group_instructions
SPV_KHR_variable_pointers
SPV_KHR_vulkan_memory_model
SPV_KHR_workgroup_memory_explicit_layout
SPV_NVX_multiview_per_view_attributes
SPV_NV_compute_shader_derivatives
SPV_NV_cooperative_matrix
SPV_NV_displacement_micromap
SPV_NV_fragment_shader_barycentric
SPV_NV_geometry_shader_passthrough
SPV_NV_mesh_shader
SPV_NV_raw_access_chains
SPV_NV_ray_tracing
SPV_NV_ray_tracing_motion_blur
SPV_NV_sample_mask_override_coverage
SPV_NV_shader_atomic_fp16_vector
SPV_NV_shader_image_footprint
SPV_NV_shader_invocation_reorder
SPV_NV_shader_sm_builtins
SPV_NV_shader_subgroup_partitioned
SPV_NV_shading_rate
SPV_NV_stereo_view_rendering
SPV_NV_viewport_array2
SPV_QCOM_image_processing
SPV_QCOM_image_processing2
SPV_VALIDATOR_ignore_type_decl_unique
SRem
SSign
SUBCOMMAND '
SUBCOMMANDS:\n\n
SUDot
SUDotAccSat
SUDotAccSatKHR
SUDotKHR
SYCL
Saarland University
Saarland University Shady
SampleId
SampleInterlockOrderedEXT
SampleInterlockUnorderedEXT
SampleMaskOverrideCoverageNV
SampleMaskPostDepthCoverage
SampleRateShading
Sampled Type must be OpTypeVoid in the OpenCL environment.
Sampled image type requires an image type with "Sampled" operand set to 0 or 1
Sampled must be 0 in the OpenCL environment.
Sampled must be 1 or 2 in the Vulkan environment.
Sampled1D
SampledBuffer
SampledCubeArray
SampledImageArrayDynamicIndexing
SampledImageArrayNonUniformIndexing
SampledImageArrayNonUniformIndexingEXT
SampledRect
SamplerImageAddressingModeNV
Sampling operation is invalid for multisample image
SatConvertSToU
SatConvertUToS
SaturatedConversion
SaturatingAccumulationKHR
SaveMemoryINTEL
Scalarized operation was expected
SchedulerTargetFmaxMhzINTEL
Scope Line
Scope ids must be OpConstant when Shader capability is 
Scope ids must be constant or specialization constant when 
Scope must be Subgroup or Device
SecondaryPositionNV
SecondaryViewportMaskNV
SecondaryViewportRelativeNV
Select
Selection must be structured
SelectionMerge
Selector type must be OpTypeInt
Sequence of components starting with 
SequentiallyConsistent memory semantics cannot be used with the VulkanKHR memory model.
Set log filename
SetMeshOutputsEXT
SetUserEventStatus
SetupRoutine
Sext
ShaderCallKHR
ShaderCallKHR Memory Scope requires a ray tracing execution model
ShaderClockKHR
ShaderEnqueueAMDX
ShaderIndexAMDX
ShaderInvocationReorderNV
ShaderNonUniform
ShaderNonUniformEXT
ShaderRecordBufferKHR
ShaderRecordBufferKHR Storage Class is limited to RayGenerationKHR, IntersectionKHR, AnyHitKHR, ClosestHitKHR, CallableKHR, and MissKHR execution model
ShaderRecordBufferKHR Storage Class variables are read only
ShaderSMBuiltinsNV
ShaderStereoViewNV
ShaderViewportIndexLayerEXT
ShaderViewportIndexLayerEXT or ShaderLayer
ShaderViewportIndexLayerEXT or ShaderViewportIndex
ShaderViewportIndexLayerNV
ShaderViewportMaskNV
ShadingRateInterlockOrderedEXT
ShadingRateInterlockUnorderedEXT
ShadingRateNV
SharedLocalMemorySizeINTEL
ShiftLeftLogical
ShiftRightArithmetic
ShiftRightLogical
Show available registers for register allocation
Show predecessors
Show successors
Shufflevector rematerialization
SideEffectsINTEL
SignBitSet
SignExtend
Signed
SignedChar
SignedInt16
SignedInt32
SignedInt8
SignedZeroInfNanPreserve
Simple
SimpleDualPortINTEL
SingleElementVectorINTEL
SinglepumpINTEL
Sinh
SirLynix
SirLynix Nazara ShaderLang Compiler
Size operand <id> 
SizeOf
Skip through unimplemented lowering code instead of aborting.
SkipAABBsKHR
SkipClosestHitShaderKHR
SkipTrianglesKHR
Slang
SmoothStep
SnormInt16
SnormInt8
Source memory access must not include MakePointerAvailableKHR
Source operand <id> 
SourceExtension
SpacingEqual
SpacingFractionalEven
SpacingFractionalOdd
SparseResidency
SpecConstant
SpecConstantComposite
SpecConstantCompositeContinuedINTEL
SpecConstantFalse
SpecConstantGlobalOffset
SpecConstantOp
SpecConstantSubgroupMaxSize
SpecConstantTrue
SpecConstantWorkDim
SpecConstantWorkgroupSize
SpecId
SpecId must be a 32-bit unsigned integer OpConstant
Specialization constant must be an integer or floating-point number.
Specialization constant operation 
SpecializationMapEntry
SpeculatedIterationsINTEL
SpirvProfilingReportDir
SpirvProfilingReportPeriodMs
Split Nodes for short circuit evaluation
SplitBarrierINTEL
SpvGenTwo community
SpvGenTwo community SpvGenTwo SPIR-V IR Tools
Sret
St11logic_error
St13runtime_error
St14overflow_error
St16invalid_argument
St8bad_cast
St9bad_alloc
St9exception
St9type_info
StableKernelArgumentINTEL
Stack Variable has a register assigned
Stack frame layout details
Stack size limit exceeded
StackCallINTEL
StackValue
StallEnableINTEL
StallFreeINTEL
StartCounter
Static Member Declaration
StaticNumWorkgroupsAMDX
StencilExportEXT
StencilRefGreaterBackAMD
StencilRefGreaterFrontAMD
StencilRefLessBackAMD
StencilRefLessFrontAMD
StencilRefReplacingEXT
StencilRefUnchangedBackAMD
StencilRefUnchangedFrontAMD
StopCounter
Storage Buffer
Storage Class
Storage buffer id '
Storage class cannot be Generic in OpenCL 1.2 environment
Storage class cannot be PhysicalStorageBuffer when raw access chain robustness is used.
Storage class in OpTypeForwardPointer does not match the 
StorageBuffer OpVariable <id> 
StorageBuffer id '
StorageBuffer pointer operand 
StorageBuffer, Uniform, or UniformConstant.
StorageBufferArrayDynamicIndexing
StorageBufferArrayNonUniformIndexing
StorageBufferArrayNonUniformIndexingEXT
StorageClass
StorageImageArrayDynamicIndexing
StorageImageArrayNonUniformIndexing
StorageImageArrayNonUniformIndexingEXT
StorageImageExtendedFormats
StorageImageMultisample
StorageImageReadWithoutFormat
StorageImageWriteWithoutFormat
StorageInputOutput16
StoragePushConstant16
StoragePushConstant8
StorageTexelBufferArrayDynamicIndexing
StorageTexelBufferArrayDynamicIndexingEXT
StorageTexelBufferArrayNonUniformIndexing
StorageTexelBufferArrayNonUniformIndexingEXT
StorageUniform16
StorageUniformBufferBlock16
Stream
StreamingINTEL
StreamingInterfaceINTEL
Stride must not be zero when per-element robustness is used.
Stride operand <id> 
StridesizeINTEL
String index not found: 
String pool (NumStrings=
Structure
Structure Nesting Depth may not be larger than 
Structure members may not be self references
Structures cannot contain a void type.
SubgroupAllEqualKHR
SubgroupAllKHR
SubgroupAnyKHR
SubgroupAvcBmeInitializeINTEL
SubgroupAvcFmeInitializeINTEL
SubgroupAvcImeAdjustRefOffsetINTEL
SubgroupAvcImeConvertToMcePayloadINTEL
SubgroupAvcImeConvertToMceResultINTEL
SubgroupAvcImeEvaluateWithDualReferenceINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL
SubgroupAvcImeEvaluateWithSingleReferenceINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL
SubgroupAvcImeGetBorderReachedINTEL
SubgroupAvcImeGetDualReferenceStreaminINTEL
SubgroupAvcImeGetSingleReferenceStreaminINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL
SubgroupAvcImeGetTruncatedSearchIndicationINTEL
SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL
SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL
SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL
SubgroupAvcImeInitializeINTEL
SubgroupAvcImeRefWindowSizeINTEL
SubgroupAvcImeSetDualReferenceINTEL
SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL
SubgroupAvcImeSetMaxMotionVectorCountINTEL
SubgroupAvcImeSetSingleReferenceINTEL
SubgroupAvcImeSetUnidirectionalMixDisableINTEL
SubgroupAvcImeSetWeightedSadINTEL
SubgroupAvcImeStripDualReferenceStreamoutINTEL
SubgroupAvcImeStripSingleReferenceStreamoutINTEL
SubgroupAvcMceConvertToImePayloadINTEL
SubgroupAvcMceConvertToImeResultINTEL
SubgroupAvcMceConvertToRefPayloadINTEL
SubgroupAvcMceConvertToRefResultINTEL
SubgroupAvcMceConvertToSicPayloadINTEL
SubgroupAvcMceConvertToSicResultINTEL
SubgroupAvcMceGetBestInterDistortionsINTEL
SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL
SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL
SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL
SubgroupAvcMceGetDefaultInterShapePenaltyINTEL
SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL
SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL
SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL
SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL
SubgroupAvcMceGetInterDirectionsINTEL
SubgroupAvcMceGetInterDistortionsINTEL
SubgroupAvcMceGetInterMajorShapeINTEL
SubgroupAvcMceGetInterMinorShapeINTEL
SubgroupAvcMceGetInterMotionVectorCountINTEL
SubgroupAvcMceGetInterReferenceIdsINTEL
SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL
SubgroupAvcMceGetMotionVectorsINTEL
SubgroupAvcMceSetAcOnlyHaarINTEL
SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL
SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL
SubgroupAvcMceSetInterDirectionPenaltyINTEL
SubgroupAvcMceSetInterShapePenaltyINTEL
SubgroupAvcMceSetMotionVectorCostFunctionINTEL
SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL
SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL
SubgroupAvcMotionEstimationChromaINTEL
SubgroupAvcMotionEstimationINTEL
SubgroupAvcMotionEstimationIntraINTEL
SubgroupAvcRefConvertToMcePayloadINTEL
SubgroupAvcRefConvertToMceResultINTEL
SubgroupAvcRefEvaluateWithDualReferenceINTEL
SubgroupAvcRefEvaluateWithMultiReferenceINTEL
SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL
SubgroupAvcRefEvaluateWithSingleReferenceINTEL
SubgroupAvcRefSetBidirectionalMixDisableINTEL
SubgroupAvcRefSetBilinearFilterEnableINTEL
SubgroupAvcSicConfigureIpeLumaChromaINTEL
SubgroupAvcSicConfigureIpeLumaINTEL
SubgroupAvcSicConfigureSkcINTEL
SubgroupAvcSicConvertToMcePayloadINTEL
SubgroupAvcSicConvertToMceResultINTEL
SubgroupAvcSicEvaluateIpeINTEL
SubgroupAvcSicEvaluateWithDualReferenceINTEL
SubgroupAvcSicEvaluateWithMultiReferenceINTEL
SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL
SubgroupAvcSicEvaluateWithSingleReferenceINTEL
SubgroupAvcSicGetBestIpeChromaDistortionINTEL
SubgroupAvcSicGetBestIpeLumaDistortionINTEL
SubgroupAvcSicGetInterRawSadsINTEL
SubgroupAvcSicGetIpeChromaModeINTEL
SubgroupAvcSicGetIpeLumaShapeINTEL
SubgroupAvcSicGetMotionVectorMaskINTEL
SubgroupAvcSicGetPackedIpeLumaModesINTEL
SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL
SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL
SubgroupAvcSicInitializeINTEL
SubgroupAvcSicSetBilinearFilterEnableINTEL
SubgroupAvcSicSetBlockBasedRawSkipSadINTEL
SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL
SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL
SubgroupAvcSicSetIntraLumaShapePenaltyINTEL
SubgroupAvcSicSetSkcForwardTransformEnableINTEL
SubgroupBallotKHR
SubgroupBlockReadINTEL
SubgroupBlockWriteINTEL
SubgroupBufferBlockIOINTEL
SubgroupDispatch
SubgroupEqMask
SubgroupEqMaskKHR
SubgroupFirstInvocationKHR
SubgroupGeMask
SubgroupGeMaskKHR
SubgroupGtMask
SubgroupGtMaskKHR
SubgroupId
SubgroupImageBlockIOINTEL
SubgroupImageBlockReadINTEL
SubgroupImageBlockWriteINTEL
SubgroupImageMediaBlockIOINTEL
SubgroupImageMediaBlockReadINTEL
SubgroupImageMediaBlockWriteINTEL
SubgroupLeMask
SubgroupLeMaskKHR
SubgroupLocalInvocationId
SubgroupLtMask
SubgroupLtMaskKHR
SubgroupMemory
SubgroupReadInvocationKHR
SubgroupShuffleDownINTEL
SubgroupShuffleINTEL
SubgroupShuffleUpINTEL
SubgroupShuffleXorINTEL
SubgroupSize
SubgroupUniformControlFlowKHR
SubgroupVoteKHR
SubgroupsPerWorkgroup
SubgroupsPerWorkgroupId
Subzero
Subzero_revision_unknown
Such variables must be identified with a Block decoration
Such variables must be identified with a Block or BufferBlock decoration
Such variables must be typed as OpTypeStruct
SwiftShader Device
SwiftShader driver
SwiftShader.Memory.%d
SwiftShader.Semaphore.%d
SwiftShader.ini
SwiftShaderUUID
Switch
Switch header 
SwizzleInvocationsAMD
SwizzleInvocationsMaskedAMD
Symbol external and defined: 
TRN_ZERO
Taichi Graphics
Taichi Graphics Taichi
Tanh
Target architecture attributes
Target architecture:
Target chooses baseline instruction set (default)
Target doesn't specify O0 lowering steps.
Target doesn't specify O1 lowering steps.
Target doesn't specify O2 lowering steps.
Target doesn't specify Om1 lowering steps.
Target memory access must not include MakePointerVisibleKHR
Target of Component decoration is invalid: must point to a Storage Class of Input(1) or Output(3). Found Storage Class 
Target of Component decoration must be a memory object declaration (a variable or a function parameter)
Target of NonWritable decoration is invalid: must point to a storage image, uniform block, 
Target of NonWritable decoration must be a memory object declaration (a variable or a function parameter)
Target operand <id> 
TaskCountNV
TaskEXT
TaskPayloadWorkgroupEXT Storage Class is limited to TaskEXT and MeshKHR execution model
Tellusim
Tellusim Clay Shader Compiler
TerminateInvocation
TerminateOnFirstHitKHR
TerminateRayKHR
TerminateRayNV
Tessellation
Tessellation execution model entry points can specify at most one of SpacingEqual, SpacingFractionalOdd or SpacingFractionalEven execution modes.
Tessellation execution model entry points can specify at most one of Triangles, Quads or Isolines execution modes.
Tessellation execution model entry points can specify at most one of VertexOrderCw or VertexOrderCcw execution modes.
TessellationControl
TessellationEvaluation
TessellationPointSize
Testing flag for -verbose=status
Text
TextureBlockMatch2QCOM
TextureBlockMatchQCOM
TextureBoxFilterQCOM
TextureSampleWeightedQCOM
The 
The 'False Label' operand for OpBranchConditional must be the ID of an OpLabel instruction
The 'True Label' operand for OpBranchConditional must be the ID of an OpLabel instruction
The <id> passed to 
The Base <id> 
The Component Type of Vector 1 must be the same as ResultType.
The Component Type of Vector 2 must be the same as ResultType.
The Fast Math Default operand is an invalid bitmask value
The Fast Math Default operand must be a non-specialization constant
The Fast Math Default operand must include AllowContract and AllowReassoc when AllowTransform is specified
The Fast Math Default operand must not include Fast
The LinkageAttributes Decoration (Linkage name: 
The Object type (Op
The Result Type must be the same as Composite type in Op
The Result Type of 
The Result Type of OpVectorShuffle must be
The Signedness in OpTypeInt must always be 0 when Kernel capability is used.
The Stride of 
The Structure's last member in 
The Structure's type in 
The Target Type operand must be a floating-point scalar type
The array member in 
The expected type is not a float type
The expected type is not a integer or float type
The expected type is not a integer type
The following forward referenced IDs have not been defined:\n
The function '
The given text is a nullptr
The high-order bits of a literal number in instruction <id> 
The integer width of 
The number of indexes in 
The number of indexes in Op
The result pointer storage class and base pointer storage class in 
The type in 
The type of 
The type of Stride of 
The type of Value must match the Result type
The type of Vector 1 must be OpTypeVector.
The type of Vector 2 must be OpTypeVector.
The types of Operand 1 and Operand 2 must match
There must be at most one object per Storage Class that can contain a structure type containing members decorated with BuiltIn, consumed per entry-point. Entry Point id 
There must be no more than one push constant block 
These variables must have DescriptorSet and Binding decorations specified
Thread<%.2d>
ThreadCount
TileImageColorReadAccessEXT
TileImageDepthReadAccessEXT
TileImageEXT
TileImageStencilReadAccessEXT
TimeAMD
Too many OpFunctionParameters for 
TornadoVM
TornadoVM Beehive SPIRV Toolkit
TraceMotionNV
TraceNV
TraceRayKHR
TrackFinishWritingAMDX
TransformFeedback
Translate only the given functions
Transpose
Triangles
Tried to hash unsupported operand type : 
TrueDualPortINTEL
Trunc
Type Id 
Type Qualifier
Type must be OpTypeHitObjectNV
Type of ExpectedValue operand of OpExpectKHR does not match the result type 
Type of Value operand of OpExpectKHR does not match the result type 
TypeAccelerationStructureNV
TypeAvcImeDualReferenceStreaminINTEL
TypeAvcImePayloadINTEL
TypeAvcImeResultDualReferenceStreamoutINTEL
TypeAvcImeResultINTEL
TypeAvcImeResultSingleReferenceStreamoutINTEL
TypeAvcImeSingleReferenceStreaminINTEL
TypeAvcMcePayloadINTEL
TypeAvcMceResultINTEL
TypeAvcRefPayloadINTEL
TypeAvcRefResultINTEL
TypeAvcSicPayloadINTEL
TypeAvcSicResultINTEL
TypeBufferSurfaceINTEL
TypeCooperativeMatrixKHR
TypeCooperativeMatrixNV
TypeDeviceEvent
TypeEvent
TypeFloat
TypeForwardPointer
TypeName must be an OpString
TypeOpaque
TypePipe
TypePipeStorage
TypeQualifier must be a 32-bit unsigned integer OpConstant
TypeQueue
TypeReserveId
TypeRuntimeArray
TypeStructContinuedINTEL
TypeVmeImageINTEL
UAddSatINTEL
UAverageINTEL
UAverageRoundedINTEL
UClamp
UConvert
UCountLeadingZerosINTEL
UCountTrailingZerosINTEL
UDiv
UGreaterThan
UGreaterThanEqual
ULessThan
ULessThanEqual
UMax3AMD
UMid3AMD
UMin3AMD
UMod
UMul32x16INTEL
UMulExtended
USAGE: 
USMStorageClassesINTEL
USubSatINTEL
UUUUUUUU
Unable to find a physical register for an infinite-weight live range (consider using -reg-reserve): 
UncachedINTEL
Underlying Types
Unexpected consumer type
Unexpected intrinsic
Unexpected memory ordering for AtomicCmpxchg
Unexpected memory ordering for AtomicFence
Unexpected memory ordering for AtomicLoad
Unexpected memory ordering for AtomicRMW
Unexpected memory ordering for AtomicStore
Unexpected operand type
Unexpected overflow in AssemblerBuffer::ExtendCapacity
Unexpected rematerializable register type
Unexpected size for LoadSubVector
Unexpected size for StoreSubVector
Unexpected vector type.
Unhandled inst type (opcode: %d) found outside function definition.
Unhandled operand kind in legalize()
Uniform OpVariable <id> 
Uniform and shader storage block variables must 
Uniform id '
UniformAndStorageBuffer16BitAccess
UniformAndStorageBuffer8BitAccess
UniformBufferArrayDynamicIndexing
UniformBufferArrayNonUniformIndexing
UniformBufferArrayNonUniformIndexingEXT
UniformConstant OpVariable <id> 
UniformConstant id '
UniformDecoration
UniformId
UniformMemory
UniformTexelBufferArrayDynamicIndexing
UniformTexelBufferArrayDynamicIndexingEXT
UniformTexelBufferArrayNonUniformIndexing
UniformTexelBufferArrayNonUniformIndexingEXT
Union
Universal
Unknown AtomicRMW operation
Unknown ExtInst
Unknown NonSemantic.ClspvReflection import version
Unknown SectionType
Unknown error %d
Unknown register.
Unordered
UnormInt101010
UnormInt101010_2
UnormInt16
UnormInt24
UnormInt8
UnormShort555
UnormShort565
UnpackDouble2x32
UnpackHalf2x16
UnpackSnorm2x16
UnpackSnorm4x8
UnpackUnorm2x16
UnpackUnorm4x8
Unreachable
Unrecognized use/exclude registers:
Unroll and DontUnroll loop controls must not both be specified
Unsigned
UnsignedChar
UnsignedInt16
UnsignedInt32
UnsignedInt8
UnsignedIntRaw10EXT
UnsignedIntRaw12EXT
Unspecified
UnstructuredLoopControlsINTEL
Unsupported 
Unsupported constant type: 
Unsupported target: 
Use all verbose options
Use all verbose options except 'regalloc,global_init'
Use of device scope with VulkanKHR memory model requires the 
UserSemantic
UserTypeGOOGLE
Using BuiltIn 
Using a 16-bit floating point 
Using a 16-bit integer type requires the Int16 capability, or an extension that explicitly enables 16-bit integers.
Using a 64-bit floating point 
Using a 64-bit integer type requires the Int64 capability.
Using an 8-bit integer type requires the Int8 capability, or an extension that explicitly enables 8-bit integers.
Using image/sampler with OpSelect requires capability 
Using pointers with OpPhi requires capability 
Using pointers with OpSelect requires capability 
VK_EXT_4444_formats
VK_EXT_blend_operation_advanced
VK_EXT_custom_border_color
VK_EXT_debug_utils
VK_EXT_depth_clip_control
VK_EXT_depth_clip_enable
VK_EXT_depth_range_unrestricted
VK_EXT_descriptor_indexing
VK_EXT_extended_dynamic_state
VK_EXT_external_memory_host
VK_EXT_graphics_pipeline_library
VK_EXT_headless_surface
VK_EXT_host_image_copy
VK_EXT_host_query_reset
VK_EXT_image_robustness
VK_EXT_inline_uniform_block
VK_EXT_line_rasterization
VK_EXT_load_store_op_none
VK_EXT_pipeline_creation_cache_control
VK_EXT_pipeline_creation_feedback
VK_EXT_pipeline_robustness
VK_EXT_primitive_topology_list_restart
VK_EXT_private_data
VK_EXT_provoking_vertex
VK_EXT_queue_family_foreign
VK_EXT_rasterization_order_attachment_access
VK_EXT_scalar_block_layout
VK_EXT_separate_stencil_usage
VK_EXT_shader_demote_to_helper_invocation
VK_EXT_shader_stencil_export
VK_EXT_subgroup_size_control
VK_EXT_surface_maintenance1
VK_EXT_swapchain_maintenance1
VK_EXT_tooling_info
VK_EXT_vertex_input_dynamic_state
VK_GOOGLE_decorate_string
VK_GOOGLE_hlsl_functionality1
VK_GOOGLE_user_type
VK_KHR_bind_memory2
VK_KHR_buffer_device_address
VK_KHR_copy_commands2
VK_KHR_create_renderpass2
VK_KHR_dedicated_allocation
VK_KHR_depth_stencil_resolve
VK_KHR_descriptor_update_template
VK_KHR_device_group
VK_KHR_device_group_creation
VK_KHR_draw_indirect_count
VK_KHR_driver_properties
VK_KHR_dynamic_rendering
VK_KHR_external_fence
VK_KHR_external_fence_capabilities
VK_KHR_external_memory
VK_KHR_external_memory_capabilities
VK_KHR_external_memory_fd
VK_KHR_external_semaphore
VK_KHR_external_semaphore_capabilities
VK_KHR_external_semaphore_fd
VK_KHR_format_feature_flags2
VK_KHR_get_memory_requirements2
VK_KHR_get_physical_device_properties2
VK_KHR_get_surface_capabilities2
VK_KHR_global_priority
VK_KHR_image_format_list
VK_KHR_imageless_framebuffer
VK_KHR_maintenance1
VK_KHR_maintenance2
VK_KHR_maintenance3
VK_KHR_maintenance4
VK_KHR_multiview
VK_KHR_pipeline_library
VK_KHR_relaxed_block_layout
VK_KHR_sampler_mirror_clamp_to_edge
VK_KHR_sampler_ycbcr_conversion
VK_KHR_separate_depth_stencil_layouts
VK_KHR_shader_float_controls
VK_KHR_shader_integer_dot_product
VK_KHR_shader_non_semantic_info
VK_KHR_shader_subgroup_extended_types
VK_KHR_shader_terminate_invocation
VK_KHR_spirv_1_4
VK_KHR_storage_buffer_storage_class
VK_KHR_surface
VK_KHR_swapchain
VK_KHR_swapchain_mutable_format
VK_KHR_synchronization2
VK_KHR_timeline_semaphore
VK_KHR_uniform_buffer_standard_layout
VK_KHR_vulkan_memory_model
VK_KHR_wayland_surface
VK_KHR_xcb_surface
VK_KHR_zero_initialize_workgroup_memory
Validation failed after pass 
Value Unknown
Value must be a 4-component unsigned integer vector
Value must be a scalar or vector of integer, floating-point, or boolean type
Value operand of OpAssumeTrueKHR must be a boolean scalar
Valve
Variable declarations that include initializers must have 
Variable decorated with Invariant must only be identified with the Input or Output storage class in Vulkan environment.
Variable must be decorated with a location
Variable struct member decorated with Invariant must only be identified with the Input or Output storage class in Vulkan environment.
VariableLengthArrayINTEL
VariablePointers
VariablePointers or VariablePointersStorageBuffer
Variables can not have a function[7] storage class outside of a function
Variables identified with the StorageBuffer storage class are used to access transparent buffer backed resources. Such variables must be typed as OpTypeStruct, or an array of this type
Variables identified with the Uniform storage class are 
Variables identified with the UniformConstant storage class 
Variables must have a function[7] storage class inside of a function
VecTypeHint
Vector Count
Vector Type
Vector access is out of bounds, vector size is 
Vector16
VectorAnyINTEL
VectorComputeCallableFunctionINTEL
VectorComputeFunctionINTEL
VectorComputeINTEL
VectorComputeVariableINTEL
VectorExtractDynamic
VectorInsertDynamic
VectorShuffle
VectorTimesMatrix
VectorTimesScalar
Verbose options (can be comma-separated):
Version 
Vertex Count must be a 32-bit unsigned int scalar
VertexId
VertexOrderCcw
VertexOrderCw
VertexRoutine_%0.8X
Vertical2Pixels
Vertical4Pixels
ViewIndex
ViewportMaskPerViewNV
Volatile
Volatile mask setting must match for Equal and Unequal memory semantics
VolatileTexel
VolatileTexelKHR
VolatileType
Vulkan
Vulkan spec allows BuiltIn 
Vulkan spec allows BuiltIn HelperInvocation to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn HelperInvocation to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn InvocationId to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn InvocationId to be used only with TessellationControl or Geometry execution models. 
Vulkan spec allows BuiltIn PatchVertices to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn PatchVertices to be used only with TessellationControl or TessellationEvaluation execution models. 
Vulkan spec allows BuiltIn PointCoord to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn PointCoord to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn PointSize to be only used for variables with Input or Output storage class. 
Vulkan spec allows BuiltIn PointSize to be used only with Vertex, TessellationControl, TessellationEvaluation or Geometry execution models. 
Vulkan spec allows BuiltIn Position to be only used for variables with Input or Output storage class. 
Vulkan spec allows BuiltIn Position to be used only with Vertex, TessellationControl, TessellationEvaluation or Geometry execution models. 
Vulkan spec allows BuiltIn PrimitiveId to be only used for variables with Input or Output storage class. 
Vulkan spec allows BuiltIn PrimitiveId to be used only with Fragment, TessellationControl, TessellationEvaluation, Geometry, MeshNV, MeshEXT, IntersectionKHR, AnyHitKHR, and ClosestHitKHR execution models. 
Vulkan spec allows BuiltIn SampleId to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn SampleId to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn SampleMask to be only used for variables with Input or Output storage class. 
Vulkan spec allows BuiltIn SampleMask to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn SamplePosition to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn SamplePosition to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn TessCoord to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn TessCoord to be used only with TessellationEvaluation execution model. 
Vulkan spec disallows OpAtomicLoad with Memory Semantics Release, AcquireRelease and SequentiallyConsistent
Vulkan spec disallows OpAtomicStore with Memory Semantics Acquire, AcquireRelease and SequentiallyConsistent
Vulkan spec does not allow BuiltIn 
Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be used for variables with Input storage class if execution model is MeshEXT.
Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be used for variables with Input storage class if execution model is MeshNV.
Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be used for variables with Input storage class if execution model is Vertex.
Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be used for variables with Output storage class if execution model is Fragment.
Vulkan spec doesn't allow BuiltIn Layer and ViewportIndex to be used for variables with Input storage class if execution model is Vertex, TessellationEvaluation, Geometry, MeshNV or MeshEXT.
Vulkan spec doesn't allow BuiltIn Layer and ViewportIndex to be used for variables with Output storage class if execution model is Fragment.
Vulkan spec doesn't allow BuiltIn PointSize to be used for variables with Input storage class if execution model is Vertex.
Vulkan spec doesn't allow BuiltIn Position to be used for variables with Input storage class if execution model is MeshEXT.
Vulkan spec doesn't allow BuiltIn Position to be used for variables with Input storage class if execution model is MeshNV.
Vulkan spec doesn't allow BuiltIn Position to be used for variables with Input storage class if execution model is Vertex.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is AnyHitKHR.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is ClosestHitKHR.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is Fragment.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is IntersectionKHR.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is TessellationControl.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is TessellationEvaluation.
Vulkan spec doesn't allow BuiltIn VertexId to be used.
Vulkan spec doesn't allow TessLevelOuter/TessLevelInner to be used for variables with Input storage class if execution model is TessellationControl.
Vulkan spec doesn't allow TessLevelOuter/TessLevelInner to be used for variables with Output storage class if execution model is TessellationEvaluation.
Vulkan spec requires BuiltIn WorkgroupSize to be a constant. 
VulkanKHR
VulkanMemoryModel
VulkanMemoryModelDeviceScope
VulkanMemoryModelDeviceScopeKHR
VulkanMemoryModelDeviceScopeKHR capability
VulkanMemoryModelKHR capability must only be specified if the VulkanKHR memory model is used.
W3C WebGPU Group
W3C WebGPU Group WHLSL Shader Translator
WGSL
WRAP
WaitKernel
WaitWorkGroup
WarpIDARM
WarpIDNV
WarpMaxIDARM
WarpsPerSMNV
WebAssembly builder
WeightTextureQCOM
When BuiltIn decoration is applied to a structure-type member, 
When declaring WorkgroupMemoryExplicitLayoutKHR, either all or none of the Workgroup Storage Class variables in the entry point interface must point to struct types decorated with Block.  Entry point id 
When declaring WorkgroupMemoryExplicitLayoutKHR, if more than one Workgroup Storage Class variable in the entry point interface point to a type decorated with Block, all of them must be decorated with Aliased. Entry point id 
Wine
Wine VKD3D Shader Compiler
WordsizeINTEL
Workgroup Memory Scope can't be used with TessellationControl using GLSL450 Memory Model
Workgroup Memory Scope is limited to MeshNV, TaskNV, MeshEXT, TaskEXT, TessellationControl, and GLCompute execution model
Workgroup Storage Class variables can't be decorated with Block unless declaring the WorkgroupMemoryExplicitLayoutKHR capability.
Workgroup and Subgroup
Workgroup storage class pointer requires VariablePointers capability to be specified
Workgroup, CrossWorkgroup, Generic, Image or StorageBuffer 
WorkgroupMemoryExplicitLayout16BitAccessKHR
WorkgroupMemoryExplicitLayout8BitAccessKHR
WorkgroupMemoryExplicitLayoutKHR
WriteBackINTEL
WriteInvocationAMD
WriteOnly
WritePackedPrimitiveIndices4x8NV
WritePipeBlockingINTEL
WriteThroughINTEL
X must be a 32-bit unsigned integer OpConstant
X-LEGEND
X-LEGEND Mesa-IR/SPIR-V Translator
Xderef
Xenia
Xenia Xenia Emulator Microcode Translator
XfbBuffer
XfbStride
Y must be a 32-bit unsigned integer OpConstant
Z must be a 32-bit unsigned integer OpConstant
ZeroExtend
Zext
Zig Software Foundation
Zig Software Foundation Zig Compiler
[0;1;30m
[0;1;31m
[0;1;32m
[0;1;33m
[0;1;34m
[0;1;35m
[0;1;36m
[0;1;37m
[0;1;40m
[0;1;41m
[0;1;42m
[0;1;43m
[0;1;44m
[0;1;45m
[0;1;46m
[0;1;47m
[0;30m
[0;31m
[0;32m
[0;33m
[0;34m
[0;35m
[0;36m
[0;37m
[0;40m
[0;41m
[0;42m
[0;43m
[0;44m
[0;45m
[0;46m
[0;47m
[VUID-BaryCoordKHR-BaryCoordKHR-04154] 
[VUID-BaryCoordKHR-BaryCoordKHR-04155] 
[VUID-BaryCoordKHR-BaryCoordKHR-04156] 
[VUID-BaryCoordNoPerspKHR-BaryCoordNoPerspKHR-04160] 
[VUID-BaryCoordNoPerspKHR-BaryCoordNoPerspKHR-04161] 
[VUID-BaryCoordNoPerspKHR-BaryCoordNoPerspKHR-04162] 
[VUID-BaseInstance-BaseInstance-04181] 
[VUID-BaseInstance-BaseInstance-04182] 
[VUID-BaseInstance-BaseInstance-04183] 
[VUID-BaseVertex-BaseVertex-04184] 
[VUID-BaseVertex-BaseVertex-04185] 
[VUID-BaseVertex-BaseVertex-04186] 
[VUID-ClipDistance-ClipDistance-04187] 
[VUID-ClipDistance-ClipDistance-04188] 
[VUID-ClipDistance-ClipDistance-04189] 
[VUID-ClipDistance-ClipDistance-04190] 
[VUID-ClipDistance-ClipDistance-04191] 
[VUID-CullDistance-CullDistance-04196] 
[VUID-CullDistance-CullDistance-04197] 
[VUID-CullDistance-CullDistance-04198] 
[VUID-CullDistance-CullDistance-04199] 
[VUID-CullDistance-CullDistance-04200] 
[VUID-CullMaskKHR-CullMaskKHR-06735] 
[VUID-CullMaskKHR-CullMaskKHR-06736] 
[VUID-CullMaskKHR-CullMaskKHR-06737] 
[VUID-DeviceIndex-DeviceIndex-04205] 
[VUID-DeviceIndex-DeviceIndex-04206] 
[VUID-DrawIndex-DrawIndex-04207] 
[VUID-DrawIndex-DrawIndex-04208] 
[VUID-DrawIndex-DrawIndex-04209] 
[VUID-FragCoord-FragCoord-04210] 
[VUID-FragCoord-FragCoord-04211] 
[VUID-FragCoord-FragCoord-04212] 
[VUID-FragDepth-FragDepth-04213] 
[VUID-FragDepth-FragDepth-04214] 
[VUID-FragDepth-FragDepth-04215] 
[VUID-FragDepth-FragDepth-04216] 
[VUID-FragInvocationCountEXT-FragInvocationCountEXT-04217] 
[VUID-FragInvocationCountEXT-FragInvocationCountEXT-04218] 
[VUID-FragInvocationCountEXT-FragInvocationCountEXT-04219] 
[VUID-FragSizeEXT-FragSizeEXT-04220] 
[VUID-FragSizeEXT-FragSizeEXT-04221] 
[VUID-FragSizeEXT-FragSizeEXT-04222] 
[VUID-FragStencilRefEXT-FragStencilRefEXT-04223] 
[VUID-FragStencilRefEXT-FragStencilRefEXT-04224] 
[VUID-FragStencilRefEXT-FragStencilRefEXT-04225] 
[VUID-FrontFacing-FrontFacing-04229] 
[VUID-FrontFacing-FrontFacing-04230] 
[VUID-FrontFacing-FrontFacing-04231] 
[VUID-FullyCoveredEXT-FullyCoveredEXT-04232] 
[VUID-FullyCoveredEXT-FullyCoveredEXT-04233] 
[VUID-FullyCoveredEXT-FullyCoveredEXT-04234] 
[VUID-GlobalInvocationId-GlobalInvocationId-04236] 
[VUID-GlobalInvocationId-GlobalInvocationId-04237] 
[VUID-GlobalInvocationId-GlobalInvocationId-04238] 
[VUID-HelperInvocation-HelperInvocation-04239] 
[VUID-HelperInvocation-HelperInvocation-04240] 
[VUID-HelperInvocation-HelperInvocation-04241] 
[VUID-HitKindKHR-HitKindKHR-04242] 
[VUID-HitKindKHR-HitKindKHR-04243] 
[VUID-HitKindKHR-HitKindKHR-04244] 
[VUID-HitTNV-HitTNV-04245] 
[VUID-HitTNV-HitTNV-04246] 
[VUID-HitTNV-HitTNV-04247] 
[VUID-IncomingRayFlagsKHR-IncomingRayFlagsKHR-04248] 
[VUID-IncomingRayFlagsKHR-IncomingRayFlagsKHR-04249] 
[VUID-IncomingRayFlagsKHR-IncomingRayFlagsKHR-04250] 
[VUID-InstanceCustomIndexKHR-InstanceCustomIndexKHR-04251] 
[VUID-InstanceCustomIndexKHR-InstanceCustomIndexKHR-04252] 
[VUID-InstanceCustomIndexKHR-InstanceCustomIndexKHR-04253] 
[VUID-InstanceId-InstanceId-04254] 
[VUID-InstanceId-InstanceId-04255] 
[VUID-InstanceId-InstanceId-04256] 
[VUID-InstanceIndex-InstanceIndex-04263] 
[VUID-InstanceIndex-InstanceIndex-04264] 
[VUID-InstanceIndex-InstanceIndex-04265] 
[VUID-InvocationId-InvocationId-04257] 
[VUID-InvocationId-InvocationId-04258] 
[VUID-InvocationId-InvocationId-04259] 
[VUID-LaunchIdKHR-LaunchIdKHR-04266] 
[VUID-LaunchIdKHR-LaunchIdKHR-04267] 
[VUID-LaunchIdKHR-LaunchIdKHR-04268] 
[VUID-LaunchSizeKHR-LaunchSizeKHR-04269] 
[VUID-LaunchSizeKHR-LaunchSizeKHR-04270] 
[VUID-LaunchSizeKHR-LaunchSizeKHR-04271] 
[VUID-Layer-Layer-04272] 
[VUID-Layer-Layer-04273] 
[VUID-Layer-Layer-04274] 
[VUID-Layer-Layer-04275] 
[VUID-Layer-Layer-04276] 
[VUID-LocalInvocationId-LocalInvocationId-04281] 
[VUID-LocalInvocationId-LocalInvocationId-04282] 
[VUID-LocalInvocationId-LocalInvocationId-04283] 
[VUID-NumSubgroups-NumSubgroups-04293] 
[VUID-NumSubgroups-NumSubgroups-04294] 
[VUID-NumSubgroups-NumSubgroups-04295] 
[VUID-NumWorkgroups-NumWorkgroups-04296] 
[VUID-NumWorkgroups-NumWorkgroups-04297] 
[VUID-NumWorkgroups-NumWorkgroups-04298] 
[VUID-ObjectRayDirectionKHR-ObjectRayDirectionKHR-04299] 
[VUID-ObjectRayDirectionKHR-ObjectRayDirectionKHR-04300] 
[VUID-ObjectRayDirectionKHR-ObjectRayDirectionKHR-04301] 
[VUID-ObjectRayOriginKHR-ObjectRayOriginKHR-04302] 
[VUID-ObjectRayOriginKHR-ObjectRayOriginKHR-04303] 
[VUID-ObjectRayOriginKHR-ObjectRayOriginKHR-04304] 
[VUID-ObjectToWorldKHR-ObjectToWorldKHR-04305] 
[VUID-ObjectToWorldKHR-ObjectToWorldKHR-04306] 
[VUID-ObjectToWorldKHR-ObjectToWorldKHR-04307] 
[VUID-PatchVertices-PatchVertices-04308] 
[VUID-PatchVertices-PatchVertices-04309] 
[VUID-PatchVertices-PatchVertices-04310] 
[VUID-PointCoord-PointCoord-04311] 
[VUID-PointCoord-PointCoord-04312] 
[VUID-PointCoord-PointCoord-04313] 
[VUID-PointSize-PointSize-04314] 
[VUID-PointSize-PointSize-04315] 
[VUID-PointSize-PointSize-04316] 
[VUID-PointSize-PointSize-04317] 
[VUID-Position-Position-04318] 
[VUID-Position-Position-04319] 
[VUID-Position-Position-04320] 
[VUID-Position-Position-04321] 
[VUID-PrimitiveId-PrimitiveId-04330] 
[VUID-PrimitiveId-PrimitiveId-04334] 
[VUID-PrimitiveId-PrimitiveId-04337] 
[VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07047] 
[VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07049] 
[VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07050] 
[VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07041] 
[VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07043] 
[VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07044] 
[VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04484] 
[VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04485] 
[VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04486] 
[VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07053] 
[VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07055] 
[VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07056] 
[VUID-RayGeometryIndexKHR-RayGeometryIndexKHR-04345] 
[VUID-RayGeometryIndexKHR-RayGeometryIndexKHR-04346] 
[VUID-RayGeometryIndexKHR-RayGeometryIndexKHR-04347] 
[VUID-RayTmaxKHR-RayTmaxKHR-04348] 
[VUID-RayTmaxKHR-RayTmaxKHR-04349] 
[VUID-RayTmaxKHR-RayTmaxKHR-04350] 
[VUID-RayTminKHR-RayTminKHR-04351] 
[VUID-RayTminKHR-RayTminKHR-04352] 
[VUID-RayTminKHR-RayTminKHR-04353] 
[VUID-SampleId-SampleId-04354] 
[VUID-SampleId-SampleId-04355] 
[VUID-SampleId-SampleId-04356] 
[VUID-SampleMask-SampleMask-04357] 
[VUID-SampleMask-SampleMask-04358] 
[VUID-SampleMask-SampleMask-04359] 
[VUID-SamplePosition-SamplePosition-04360] 
[VUID-SamplePosition-SamplePosition-04361] 
[VUID-SamplePosition-SamplePosition-04362] 
[VUID-ShadingRateKHR-ShadingRateKHR-04490] 
[VUID-ShadingRateKHR-ShadingRateKHR-04491] 
[VUID-ShadingRateKHR-ShadingRateKHR-04492] 
[VUID-StandaloneSpirv-Base-04781] 
[VUID-StandaloneSpirv-Base-07650] 
[VUID-StandaloneSpirv-Base-07651] 
[VUID-StandaloneSpirv-Base-07652] 
[VUID-StandaloneSpirv-CallableDataKHR-04704] 
[VUID-StandaloneSpirv-Component-04920] 
[VUID-StandaloneSpirv-Component-04921] 
[VUID-StandaloneSpirv-Component-04922] 
[VUID-StandaloneSpirv-Component-04923] 
[VUID-StandaloneSpirv-Component-04924] 
[VUID-StandaloneSpirv-Component-07703] 
[VUID-StandaloneSpirv-DescriptorSet-06491] 
[VUID-StandaloneSpirv-ExecutionModel-07320] 
[VUID-StandaloneSpirv-FPRoundingMode-04675] 
[VUID-StandaloneSpirv-Flat-04670] 
[VUID-StandaloneSpirv-Flat-04744] 
[VUID-StandaloneSpirv-Flat-06201] 
[VUID-StandaloneSpirv-Flat-06202] 
[VUID-StandaloneSpirv-GLSLShared-04669] 
[VUID-StandaloneSpirv-HitAttributeKHR-04701] 
[VUID-StandaloneSpirv-HitAttributeKHR-04702] 
[VUID-StandaloneSpirv-HitAttributeKHR-04703] 
[VUID-StandaloneSpirv-IncomingCallableDataKHR-04705] 
[VUID-StandaloneSpirv-IncomingCallableDataKHR-04706] 
[VUID-StandaloneSpirv-IncomingRayPayloadKHR-04699] 
[VUID-StandaloneSpirv-IncomingRayPayloadKHR-04700] 
[VUID-StandaloneSpirv-Input-06778] 
[VUID-StandaloneSpirv-Input-07290] 
[VUID-StandaloneSpirv-InputAttachmentIndex-06678] 
[VUID-StandaloneSpirv-Invariant-04677] 
[VUID-StandaloneSpirv-LocalSize-06426] 
[VUID-StandaloneSpirv-Location-04915] 
[VUID-StandaloneSpirv-Location-04916] 
[VUID-StandaloneSpirv-Location-04917] 
[VUID-StandaloneSpirv-Location-04918] 
[VUID-StandaloneSpirv-Location-04919] 
[VUID-StandaloneSpirv-Location-06672] 
[VUID-StandaloneSpirv-MeshEXT-07102] 
[VUID-StandaloneSpirv-None-04633] 
[VUID-StandaloneSpirv-None-04634] 
[VUID-StandaloneSpirv-None-04635] 
[VUID-StandaloneSpirv-None-04636] 
[VUID-StandaloneSpirv-None-04637] 
[VUID-StandaloneSpirv-None-04638] 
[VUID-StandaloneSpirv-None-04640] 
[VUID-StandaloneSpirv-None-04641] 
[VUID-StandaloneSpirv-None-04642] 
[VUID-StandaloneSpirv-None-04643] 
[VUID-StandaloneSpirv-None-04644] 
[VUID-StandaloneSpirv-None-04645] 
[VUID-StandaloneSpirv-None-04667] 
[VUID-StandaloneSpirv-None-04686] 
[VUID-StandaloneSpirv-None-07321] 
[VUID-StandaloneSpirv-Offset-04663] 
[VUID-StandaloneSpirv-OpAtomicLoad-04731] 
[VUID-StandaloneSpirv-OpAtomicStore-04730] 
[VUID-StandaloneSpirv-OpControlBarrier-04650] 
[VUID-StandaloneSpirv-OpControlBarrier-04682] 
[VUID-StandaloneSpirv-OpEntryPoint-06674] 
[VUID-StandaloneSpirv-OpEntryPoint-08721] 
[VUID-StandaloneSpirv-OpEntryPoint-08722] 
[VUID-StandaloneSpirv-OpGroupNonUniformBallotBitCount-04685] 
[VUID-StandaloneSpirv-OpImage-04777] 
[VUID-StandaloneSpirv-OpImageGather-04664] 
[VUID-StandaloneSpirv-OpImageQuerySizeLod-04659] 
[VUID-StandaloneSpirv-OpImageTexelPointer-04658] 
[VUID-StandaloneSpirv-OpMemoryBarrier-04732] 
[VUID-StandaloneSpirv-OpMemoryBarrier-04733] 
[VUID-StandaloneSpirv-OpReadClockKHR-04652] 
[VUID-StandaloneSpirv-OpTypeForwardPointer-04711] 
[VUID-StandaloneSpirv-OpTypeImage-04656] 
[VUID-StandaloneSpirv-OpTypeImage-04657] 
[VUID-StandaloneSpirv-OpTypeImage-06214] 
[VUID-StandaloneSpirv-OpTypeImage-09638] 
[VUID-StandaloneSpirv-OpTypeRuntimeArray-04680] 
[VUID-StandaloneSpirv-OpTypeSampledImage-06671] 
[VUID-StandaloneSpirv-OpVariable-04651] 
[VUID-StandaloneSpirv-OpVariable-04734] 
[VUID-StandaloneSpirv-OpVariable-06673] 
[VUID-StandaloneSpirv-OriginLowerLeft-04653] 
[VUID-StandaloneSpirv-PerVertexKHR-06777] 
[VUID-StandaloneSpirv-PhysicalStorageBuffer64-04708] 
[VUID-StandaloneSpirv-PhysicalStorageBuffer64-04710] 
[VUID-StandaloneSpirv-PixelCenterInteger-04654] 
[VUID-StandaloneSpirv-Pointer-08973] 
[VUID-StandaloneSpirv-PushConstant-06675] 
[VUID-StandaloneSpirv-PushConstant-06808] 
[VUID-StandaloneSpirv-RayPayloadKHR-04698] 
[VUID-StandaloneSpirv-Result-04780] 
[VUID-StandaloneSpirv-ShaderRecordBufferKHR-07119] 
[VUID-StandaloneSpirv-SubgroupVoteKHR-07951] 
[VUID-StandaloneSpirv-Uniform-06676] 
[VUID-StandaloneSpirv-Uniform-06807] 
[VUID-StandaloneSpirv-Uniform-06925] 
[VUID-StandaloneSpirv-UniformConstant-04655] 
[VUID-StandaloneSpirv-UniformConstant-06677] 
[VUID-SubgroupEqMask-SubgroupEqMask-04370] 
[VUID-SubgroupEqMask-SubgroupEqMask-04371] 
[VUID-SubgroupGeMask-SubgroupGeMask-04372] 
[VUID-SubgroupGeMask-SubgroupGeMask-04373] 
[VUID-SubgroupGtMask-SubgroupGtMask-04374] 
[VUID-SubgroupGtMask-SubgroupGtMask-04375] 
[VUID-SubgroupId-SubgroupId-04367] 
[VUID-SubgroupId-SubgroupId-04368] 
[VUID-SubgroupId-SubgroupId-04369] 
[VUID-SubgroupLeMask-SubgroupLeMask-04376] 
[VUID-SubgroupLeMask-SubgroupLeMask-04377] 
[VUID-SubgroupLocalInvocationId-SubgroupLocalInvocationId-04380] 
[VUID-SubgroupLocalInvocationId-SubgroupLocalInvocationId-04381] 
[VUID-SubgroupLtMask-SubgroupLtMask-04378] 
[VUID-SubgroupLtMask-SubgroupLtMask-04379] 
[VUID-SubgroupSize-SubgroupSize-04382] 
[VUID-SubgroupSize-SubgroupSize-04383] 
[VUID-TessCoord-TessCoord-04387] 
[VUID-TessCoord-TessCoord-04388] 
[VUID-TessCoord-TessCoord-04389] 
[VUID-TessLevelInner-TessLevelInner-04394] 
[VUID-TessLevelInner-TessLevelInner-04395] 
[VUID-TessLevelInner-TessLevelInner-04396] 
[VUID-TessLevelInner-TessLevelInner-04397] 
[VUID-TessLevelOuter-TessLevelOuter-04390] 
[VUID-TessLevelOuter-TessLevelOuter-04391] 
[VUID-TessLevelOuter-TessLevelOuter-04392] 
[VUID-TessLevelOuter-TessLevelOuter-04393] 
[VUID-VertexIndex-VertexIndex-04398] 
[VUID-VertexIndex-VertexIndex-04399] 
[VUID-VertexIndex-VertexIndex-04400] 
[VUID-ViewIndex-ViewIndex-04401] 
[VUID-ViewIndex-ViewIndex-04402] 
[VUID-ViewIndex-ViewIndex-04403] 
[VUID-ViewportIndex-ViewportIndex-04404] 
[VUID-ViewportIndex-ViewportIndex-04405] 
[VUID-ViewportIndex-ViewportIndex-04406] 
[VUID-ViewportIndex-ViewportIndex-04407] 
[VUID-ViewportIndex-ViewportIndex-04408] 
[VUID-WorkgroupId-WorkgroupId-04422] 
[VUID-WorkgroupId-WorkgroupId-04423] 
[VUID-WorkgroupId-WorkgroupId-04424] 
[VUID-WorkgroupSize-WorkgroupSize-04425] 
[VUID-WorkgroupSize-WorkgroupSize-04426] 
[VUID-WorkgroupSize-WorkgroupSize-04427] 
[VUID-WorldRayDirectionKHR-WorldRayDirectionKHR-04428] 
[VUID-WorldRayDirectionKHR-WorldRayDirectionKHR-04429] 
[VUID-WorldRayDirectionKHR-WorldRayDirectionKHR-04430] 
[VUID-WorldRayOriginKHR-WorldRayOriginKHR-04431] 
[VUID-WorldRayOriginKHR-WorldRayOriginKHR-04432] 
[VUID-WorldRayOriginKHR-WorldRayOriginKHR-04433] 
[VUID-WorldToObjectKHR-WorldToObjectKHR-04434] 
[VUID-WorldToObjectKHR-WorldToObjectKHR-04435] 
[VUID-WorldToObjectKHR-WorldToObjectKHR-04436] 
\nStarting computeAddressOpt for instruction:\n  
_GLOBAL_OFFSET_TABLE_
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
_Unwind_DeleteException
_Unwind_GetIP
_Unwind_GetLanguageSpecificData
_Unwind_GetRegionStart
_Unwind_RaiseException
_Unwind_Resume
_Unwind_SetGR
_Unwind_SetIP
__Sz_bitcast_16xi1_i16
__Sz_bitcast_8xi1_i8
__Sz_bitcast_i16_16xi1
__Sz_bitcast_i8_8xi1
__Sz_fptosi_f32_i64
__Sz_fptosi_f64_i64
__Sz_fptoui_4xi32_f32
__Sz_fptoui_f32_i32
__Sz_fptoui_f32_i64
__Sz_fptoui_f64_i32
__Sz_fptoui_f64_i64
__Sz_revision
__Sz_sitofp_i64_f32
__Sz_sitofp_i64_f64
__Sz_uitofp_4xi32_4xf32
__Sz_uitofp_i32_f32
__Sz_uitofp_i32_f64
__Sz_uitofp_i64_f32
__Sz_uitofp_i64_f64
__cont
__ctype_b_loc
__ctype_get_mb_cur_max
__ctype_tolower_loc
__ctype_toupper_loc
__cxa_atexit
__cxa_finalize
__cxa_guard_abort
__cxa_guard_acquire
__cxa_guard_acquire detected recursive initialization: do you have a function-local static variable whose initialization depends on that function?
__cxa_guard_release
__divdi3
__divsi3
__errno_location
__fxstat64
__gmon_start__
__isoc99_sscanf
__isoc99_vsscanf
__mbrlen
__moddi3
__modsi3
__nacl_read_tp
__next_prime overflow
__popcountdi2
__popcountsi2
__sched_cpucount
__stack_chk_fail
__thread_specific_ptr construction failed
__tls_get_addr
__udivdi3
__udivsi3
__umoddi3
__umodsi3
__xstat64
_arr_
_ptr_
_runtimearr_
_start
_struct_
a storage class of PhysicalStorageBuffer.
abcdef
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789
abort
accelerationStructureNV
acos
acosh
acospi
addressing model
addropt
aggressive-lea
aligned_alloc
all members of that structure type must also be decorated with 
allow-extern
allow-iaca-marks
allow-pnacl-reader-error-recovery
allow-uninitialized-globals
also be decorated with a *Binding*.
and OpImageFetch
appear as the final member of an OpTypeStruct, thus cannot 
are used only as handles to refer to opaque resources. Such 
arm32
arm32 (same as arm)
arm64
ashr
asin
asinf
asinh
asinpi
asm-verbose
atan
atan2
atan2pi
atanh
atanpi
await
bad_array_new_length was thrown in -fno-exceptions mode
bad_function_call was thrown in -fno-exceptions mode
base
basic_string
bcmp
be instantiated via OpVariable
be targeted by OpName, OpGroupDecorate, 
bitcode-as-text
bitcode-format
bits must be a 32-bit int scalar
bitselect
bitset test argument out of range
block <ID> 
bool
build-atts
build-on-read
built-in
but 
calloc
cannot allocate __cxa_eh_globals
cannot compose log message
cannot create thread specific key for __cxa_get_globals()
cannot zero out thread value for __cxa_get_globals()
case entry block
catching a class without an object?
catclose
catgets
catopen
cbrt
ceil
ceilf
cl::alias must have an cl::aliasopt(option) specified!
cl::alias must have argument name specified!
cl::alias must only have one cl::aliasopt(...) specified!
cl::location(x) specified more than once!
clock_gettime
clock_gettime(CLOCK_MONOTONIC) failed
clock_gettime(CLOCK_REALTIME) failed
close
combination.\n
combine-access-chains
combined (Vector1 + Vector2) size of 
components as the first member
composite
condition_variable timed_wait failed
condition_variable wait failed
condition_variable::timed wait: mutex not locked
condition_variable::wait: mutex not locked
containing OpTypeRuntimeArray must have storage class of 
contains an array with stride 
contains an array with stride 0
context-insensitive value
convert-local-access-chains
cooperative matrix layout
cooperative matrix operands
cooperative matrix use
copy-propagate-arrays
copysign
coroutine
corresponding member type of Result Type struct
cpool
createLoweredMove() unimplemented
cross
declarations)
default-function-prefix
default-global-prefix
degrees
device_event
dimensionality
disabled
dlerror
dlopen
dlsym
doMockBoundsCheck: Opnd contains index reg
does not strictly structurally dominate
does not structurally dominate
double
dump-strings
eliminate-dead-branches
eliminate-dead-code-aggressive
eliminate-dead-functions
eliminate-dead-inserts
eliminate-local-single-block
eliminate-local-single-store
emit-revision
emitFileHeader for non-ELF
enable-block-profile
enable-sc
enabled
er.DebugInfo.100
erfc
execute once failure in __cxa_get_globals_fast()
exit
exit-success
exp2
expected Data to be a 32 or 64-bit float scalar
expected Data to be a 32 or 64-bit float vector
expected Data to be an int or float vector
expected Data to have 2, 3, 4, 8 or 16 components
expected Format data type to be 8-bit int
expected Format storage class to be UniformConstant
expected Hi and Lo operands to have the same number of components as Result Type
expected Hi and Lo operands to have the same type
expected Interpolant data type to be equal to Result Type
expected Interpolant storage class to be Input
expected Interpolant to be a pointer
expected Intersection ID to be a constant 32-bit int scalar
expected Nancode to be an int scalar or vector type
expected Nancode to have the same bit width as Result Type
expected Nancode to have the same number of components as Result Type
expected Offset to be a vector of 2 32-bit floats
expected Ptr data type to be int or float scalar or vector
expected Result Type matrix to have a Column Count of 4
expected Result Type matrix to have a Column Type of 3-component 32-bit float vectors
expected Result Type matrix to have a Column Type of 3-component 32-bit float vectors: 
expected Result Type to be 32-bit float 2-component vector type
expected Result Type to be 32-bit float 3-component vector type
expected Result Type to be 32-bit float scalar type
expected Result Type to be 32-bit int scalar type
expected Result Type to be 64-bit float scalar type
expected Result Type to be a 16 or 32-bit scalar or vector float type
expected Result Type to be a 32-bit float scalar 
expected Result Type to be a 32-bit float vector of size 2
expected Result Type to be a 32-bit float vector of size 4
expected Result Type to be a 32-bit int scalar or vector type
expected Result Type to be a 32-bit int type
expected Result Type to be a 32-bit int vector of size 2
expected Result Type to be a float scalar or vector type
expected Result Type to be a float scalar type
expected Result Type to be a float vector type
expected Result Type to be a scalar or a vector with 2, 3, 4, 8 or 16 components
expected Result Type to be a scalar or vector float type
expected Result Type to be a square matrix
expected Result Type to be a struct with two identical 
expected Result Type to be a struct with two members, 
expected Result Type to be an int or float scalar or vector type
expected Result Type to be an int or float vector type
expected Result Type to be an int scalar or vector type
expected Result Type to have 2, 3, 4, 8 or 16 components
expected Result Type to have 2, 4, 8 or 16 components
expected Result Type to have 3 components
expected Result Type to have 3 or 4 components
expected Result Type to have no more than 4 components
expected Sample to be 32-bit integer
expected all operands to be int scalars or vectors
expected all operands to have the same bit width as 
expected all operands to have the same dimension as 
expected bit width of Result Type components to be 16, 32 or 64
expected bit width of components of Hi and Lo operands to be half of the bit width of components of Result Type
expected data type of the pointer to be a 32-bit int scalar or vector type
expected data type of the pointer to be equal to Result Type
expected data type of the pointer to have the same number of components as Result Type
expected index must be scalar integer
expected literal N to be equal to the number of components of Result Type
expected matrix type as Result Type
expected matrix type as Result Type: 
expected operand A type to be equal to Result Type
expected operand B type to be equal to Result Type
expected operand C to be an int scalar or vector
expected operand C to have the same bit width as Result Type
expected operand C to have the same number of components as Result Type
expected operand Child must be class or struct debug type
expected operand Eta to be a float scalar
expected operand Exp data type to be a 
expected operand Exp data type to have the same component 
expected operand Exp to be a 32-bit int scalar 
expected operand Exp to be a pointer
expected operand Exp to have the same component 
expected operand Format to be a pointer
expected operand I data type to be equal to Result Type
expected operand I to be a pointer
expected operand I to be of type equal to Result Type
expected operand Members 
expected operand N to be of type equal to Result Type
expected operand Num Elements to be of type size_t (
expected operand Offset to be of type size_t (
expected operand P component type to be equal to Result Type
expected operand P data type to be 16-bit float scalar
expected operand P data type to be equal to component type of Result Type
expected operand P data type to be equal to the type of operand Data components
expected operand P storage class to be Generic, CrossWorkgroup, Workgroup or Function
expected operand P storage class to be UniformConstant, Generic, CrossWorkgroup, Workgroup or Function
expected operand P to be a 32-bit int scalar
expected operand P to be a float scalar or vector
expected operand P to be a pointer
expected operand P to have no more than 4 components
expected operand P type to be equal to Result Type
expected operand P0 component type to be equal to 
expected operand P0 to be of float scalar or vector type
expected operand P0 to have no more than 4 components
expected operand P1 component type to be equal to 
expected operand P1 to be of float scalar or vector type
expected operand Parameters must be 
expected operand Parent must be class or struct debug type
expected operand Ptr storage class to be CrossWorkgroup
expected operand Ptr to be a pointer
expected operand Shuffle Mask components to have the same bit width as Result Type components
expected operand Shuffle Mask to be an int vector
expected operand Shuffle Mask to have the same number of components as Result Type
expected operand Target must be DebugTypeComposite 
expected operand V to be a 32-bit float vector of size 2
expected operand V to be a 32-bit float vector of size 4
expected operand V to be a 32-bit int vector of size 2
expected operand V to be a 64-bit float scalar
expected operand Variable must be a result id of OpVariable or OpConstant or DebugInfoNone
expected operand Variable must be a result id of OpVariable or OpFunctionParameter
expected operand X and Result Type to have equal component types
expected operand X component type to be equal to 
expected operand X component type to be equal to Result Type
expected operand X to be a float scalar or vector
expected operand X to be a square matrix
expected operand X to be an int or float vector
expected operand X to be of float scalar or vector type
expected operand X to have 2, 4, 8 or 16 components
expected operand X to have the same number of components as Result Type
expected operand X type to be equal to Result Type
expected operand X type to be equal to members of 
expected operand X type to be equal to the first member 
expected operand Y type to be equal to Result Type
expected operands P0 and P1 to be of the same type
expected operands P0 and P1 to have the same number of 
expected operands X and Y to be of the same type
expected result type must be a result id of 
expected storage class of the pointer to be Generic, CrossWorkgroup, Workgroup or Function
expected the exponent to be a 32-bit int scalar or vector
expected the exponent to have the same number of components as Result Type
expected the last operand to be a pointer
expected type of operand X to be equal to Result Type
expected type of operand Y to be equal to Result Type
expected types of all operands to be equal to Result Type
expm1
extension instruction number
externalize
fabs
fadd
fast_distance
fast_length
fast_normalize
fclamp
fclose
fcntl64
fdata-sections
fdim
fdiv
fflush
ffunction-sections
filetype
first member a float scalar or vector, second member a 
floating-point fast math mode
floating-point rounding mode
floor
fmax
fmax_common
fmem-intrin-opt
fmin
fmin_common
fmod
fmodf
fmul
fold
fopen64
force-O2
forward_pointer(
fputc
fputs
fputwc
frame
fread
free
freelocale
frem
frexp
frexpf
fsanitize-address
fseek
fseeko64
fsub
ftello64
ftruncate64
function control
function inside function
function parameter attribute
fwrite
generic
getc
getwc
gfx-rs community
gfx-rs community Naga
gl_BaseInstance
gl_ClipDistance
gl_CullDistance
gl_FragCoord
gl_FragDepth
gl_FrontFacing
gl_GlobalInvocationID
gl_HelperInvocation
gl_InstanceID
gl_InstanceIndex
gl_InvocationID
gl_Layer
gl_LocalInvocationID
gl_LocalInvocationIndex
gl_NumWorkGroups
gl_PatchVertices
gl_PointCoord
gl_PointSize
gl_Position
gl_PrimitiveID
gl_SampleID
gl_SampleMask
gl_SamplePosition
gl_TessCoord
gl_TessLevelInner
gl_TessLevelOuter
gl_VertexID
gl_VertexIndex
gl_ViewportIndex
gl_WorkGroupID
gl_WorkGroupSize
global variables) and section 10 (function 
global_init
group operation
half_cos
half_divide
half_exp
half_exp10
half_exp2
half_log
half_log10
half_log2
half_powr
half_recip
half_rsqrt
half_sin
half_sqrt
half_tan
has storage class StorageBuffer or PhysicalStorageBuffer.
help
help-hidden
help-list
help-list-hidden
heroseh
heroseh Hero C Compiler
hitObjectNV
host access qualifier
hwdiv-arm
hypot
i16to8
i32to8
i64to8
i8from
i8fromah
identical
if it has storage class Uniform.
if-conversion
ilogb
image channel data type
image channel order
image format
in Function or Private storage classes or as function parameters
in Vulkan environment, OpControlBarrier execution scope must be Subgroup for Fragment, Vertex, Geometry, TessellationEvaluation, RayGeneration, Intersection, AnyHit, ClosestHit, and Miss execution models
in Vulkan environment, Output Storage Class must not be used in GLCompute, RayGenerationKHR, IntersectionKHR, AnyHitKHR, ClosestHitKHR, MissKHR, or CallableKHR execution models
in Vulkan environment, Workgroup Storage Class is limited to MeshNV, TaskNV, and GLCompute execution model
in Vulkan environment, Workgroup execution scope is only for TaskNV, MeshNV, TaskEXT, MeshEXT, TessellationControl, and GLCompute execution models
inconsistency in registered CommandLine options
info-output-file
initForInfOnly: Liveness error
initialization mode qualifier
inline-entry-points-exhaustive
instnum
instruction in its block.
int scalar or vector with the same number of 
integer less than or equal to 4
integer scalar or vector: 
ios_base::clear
iostream
is a matrix with stride 
is an improperly straddling vector at offset 
is missing an Offset decoration
is not structurally post dominated by
isatty
isprint
isspace
keep-deleted-insts
kernel enqeue flags
kernel profiling info
last
lcse
lcse-max-iters
ld-linux-x86-64.so.2
ldexp
length_error was thrown in -fno-exceptions mode with message "%s"
lgamma
lgamma_r
libc++abi: 
libc.so.6
libdl.so.2
libgcc_s.so.1
libm.so.6
libpthread.so.0
libvk_swiftshader.so
libwayland-client.so.0
libxcb-shm.so.0
libxcb.so.1
licm
linkage type
literal string
live
llvm
load cache control
locale not supported
log1p
log2
longjmp
loop
loop control
loop-unroll
lseek64
lshr
malloc
map::at:  key not found
matrix: 
mattr
max-nops-per-instruction
maxmag
may only occur zero or one times!
mbrtowc
mbsnrtowcs
mbsrtowcs
mbtowc
memchr
memcmp
memcpy
memmove
memory access
memory model
memory semantics ID
memset
merge-blocks
merge-return
minmag
mips
mips32
mips32 (same as mips)
mkstemp64
mmap64
mock-bounds-check
money_get error
most
mprotect
munmap
must appear between section 9 (types, constants, 
must be DebugTypeMember, DebugFunction, or DebugTypeInheritance
must be a constant for WorkgroupSize
must be a pointer type
must be a scalar specialization constant
must be a structure type
must be a variable
must be an array or pointer type
must be decorated with Block or BufferBlock.
must be in the Output storage class
must be in the StorageBuffer, Uniform, or UniformConstant storage class
must be in the UniformConstant storage class
must occur exactly one time!
named maximum number of registers
named_barrier
native_cos
native_divide
native_exp
native_exp10
native_exp2
native_log
native_log10
native_log2
native_powr
native_recip
native_rsqrt
native_sin
native_sqrt
native_tan
neon
newlocale
nextafter
no-assume-ssa
no-hybrid-asm
no-ssa
non-OpPhi instructions 
non-built-in variables within a single structure). Structure id 
nop-insertion-percentage
notranslate
ntic.DebugPrintf
num_threads
number as Result Type
of debug info extension must appear in a function 
of right matrix to be equal: 
of the left operand: 
one of the following storage classes: Output, Private, 
opaque('
opcodes or together with Image Operand Grad
open64
operand of the result type.
or 0 for an integer type with Signedness of 0, 
or DebugFunction
or an array of one of these types.
or scalar type: 
or scalar: 
or sign extended when Signedness is 1
or storage buffer
orig
out_of_range was thrown in -fno-exceptions mode with message "%s"
overflow mode
packed vector format
parse-parallel
payload must be a OpVariable of storage class RayPayloadKHR or IncomingRayPayloadKHR
phi-edge-split
pipe(
pipe_storage
pnacl
pointer definition.
popcount
positive integer
possibly multi-word literal integer
possibly multi-word literal number
powf
pown
pred
prefetch
print-all-options
print-options
printf
private-to-local
pthread_cond_broadcast
pthread_cond_destroy
pthread_cond_init
pthread_cond_signal
pthread_cond_timedwait
pthread_cond_wait
pthread_condattr_destroy
pthread_condattr_init
pthread_condattr_setpshared
pthread_create
pthread_getaffinity_np
pthread_getspecific
pthread_join
pthread_key_create
pthread_key_delete
pthread_mutex_destroy
pthread_mutex_init
pthread_mutex_lock
pthread_mutex_trylock
pthread_mutex_unlock
pthread_mutexattr_destroy
pthread_mutexattr_init
pthread_mutexattr_setpshared
pthread_mutexattr_settype
pthread_once
pthread_self
pthread_setaffinity_np
pthread_setname_np
pthread_setspecific
qsort
quantization mode
r10b
r10d
r10w
r11b
r11d
r11w
r12b
r12d
r12w
r13b
r13d
r13w
r14b
r14d
r14w
r15b
r15d
r15w
radians
raw access chain operands
ray flags
ray query candidate intersection type
ray query committed intersection type
ray query intersection
rayQueryKHR
read storage image
realloc
recursive_mutex constructor failed
recursive_mutex lock failed
reduce-load-size
redundancy-elimination
reg-exclude
reg-reserve
reg-use
regalloc-repeat
relaxed 
remainder
remove-dont-inline
remquo
reserve_id
result ID
rootn
round
roundf
rules: A Block or BufferBlock cannot be nested within another Block or BufferBlock. 
s Type must be a scalar or vector type.
s array element type.
s array length.
s callgraph contains function <id> 
s component type.
s function parameter count is not zero.
s function return type is not void.
s layout does not match Object <id> 
s layout.
s matrix column component type.
s matrix column count.
s matrix column type.
s member count.
s member type.
s parameter type.
s struct member count.
s type does not match Function <id> 
s type does not match Object <id> 
s type does not match OpFunction's return type.
s type does not match Result Type <id> 
s type does not match Source <id> 
s type is void.
s type.
s vector component count.
s vector element type.
sBGRA
sRGB
sRGBA
sRGBx
s_abs
s_abs_diff
s_add_sat
s_clamp
s_hadd
s_mad24
s_mad_hi
s_mad_sat
s_max
s_min
s_mul24
s_mul_hi
s_rhadd
s_sub_sat
s_upsample
sampled_image(
sampler
sampler addressing mode
sampler filter mode
scalar or vector float type members
scalar-replacement=%u
sched_yield
scope ID
selection control
selection header
set-spec-const-default-value
setbuf
setjmp
shading rate
shmat
shmctl
shmdt
shmget
shuffle
shuffle2
shufvec
sigfillset
sigprocmask
simplify-instructions
sincos
skip-unimplemented
smoothstep
snprintf
source language
split-global-vars
split-inst
split-local-vars
spv::Op::OpCooperativeMatrixLoadKHR
spv::Op::OpCooperativeMatrixLoadKHR Result Type <id> 
spv::Op::OpCooperativeMatrixLoadNV
spv::Op::OpCooperativeMatrixLoadNV Result Type <id> 
spv::Op::OpCooperativeMatrixStoreKHR
spv::Op::OpCooperativeMatrixStoreKHR Object type <id> 
spv::Op::OpCooperativeMatrixStoreNV
spv::Op::OpCooperativeMatrixStoreNV Object type <id> 
sqrt
ssa-rewrite
sse2
sse4.1
standard 
statically used per shader entry point.
std::__libcpp_tls_set failure in __cxa_get_globals()
std::bad_alloc
std::bad_cast
stderr
stdin
stdout
storage buffer, or variable in Private or Function storage class
storage class must be Input
storage class must be Input or Output
storage classes
storage classes.
store cache control
stoul
strcmp
strcpy
strerror
strerror_r
strftime_l
strlen
strncmp
strncpy
strstr
strtod_l
strtof_l
strtold_l
strtoll_l
strtoul
strtoull_l
structure 
structure may not be contained as a member of another 
succ
swiftshader_jit
syscall
sysconf
system
szstats
target is not defined
terminate_handler unexpectedly returned
terminate_handler unexpectedly threw an exception
terminator instruction outside basic block
terminator instruction outside function
test-stack-extra
test-status
tgamma
that allocate pointers must be in Function or Private 
this instruction is currently limited to 32-bit width 
thread constructor failed
thread-local initialization routine for rr::Variable::unmaterializedVariables
thread::join failed
timing
timing-focus
timing-funcs
to be the reverse of those of Result Type
to storage image
to the number of columns of Result Type matrix
to the number of elements of Result Type array
to the number of members of Result Type struct
to the size of Result Type vector
toString() called when hasStdString() is false
tolower
track-memory
translate-only
true
trunc
type ID
type Result Type array
type Result Type matrix
type is OpConstant with an integer scalar type
type of the matrix operand: 
type of the vector operand: 
type requires the Float16 or Float16Buffer capability, or an extension that explicitly enables 16-bit floating point.
type requires the Float64 capability.
type. Structure <id> 
u_abs
u_abs_diff
u_add_sat
u_clamp
u_hadd
u_mad24
u_mad_hi
u_mad_sat
u_max
u_min
u_mul24
u_mul_hi
u_rhadd
u_sub_sat
u_upsample
uint
undef value encountered by emitter.
unexpected type
ungetc
ungetwc
uniform buffer
unique_lock::lock: already locked
unique_lock::lock: references null mutex
unique_lock::unlock: not locked
unlink
unordered_map::at: key not found
unsigned
unspecified generic_category error
unspecified iostream_category error
unspecified system_category error
unsupported locale for standard input
used to access transparent buffer backed resources. Such 
uselocale
v16i1
v16i8
v4f32
v4i1
v4i32
v8i1
v8i16
variables must be typed as OpTypeImage, OpTypeSampler, 
variables must be typed as OpTypeStruct, or an array of 
vasprintf
vector operand size: 
vector size of the right operand: 
vector-dce
verbose-focus
verbose-llvm-parse-errors
vfprintf
vkAcquireNextImage2KHR
vkAcquireNextImageKHR
vkAllocateCommandBuffers
vkAllocateDescriptorSets
vkAllocateMemory
vkBeginCommandBuffer
vkBindBufferMemory
vkBindBufferMemory2
vkBindBufferMemory2KHR
vkBindImageMemory
vkBindImageMemory2
vkBindImageMemory2KHR
vkCmdBeginDebugUtilsLabelEXT
vkCmdBeginQuery
vkCmdBeginQuery()
vkCmdBeginRenderPass
vkCmdBeginRenderPass()
vkCmdBeginRenderPass2
vkCmdBeginRenderPass2KHR
vkCmdBeginRendering
vkCmdBeginRendering()
vkCmdBeginRenderingKHR
vkCmdBindDescriptorSets
vkCmdBindDescriptorSets()
vkCmdBindIndexBuffer
vkCmdBindPipeline
vkCmdBindVertexBuffers
vkCmdBindVertexBuffers2
vkCmdBindVertexBuffers2EXT
vkCmdBlitImage
vkCmdBlitImage()
vkCmdBlitImage2
vkCmdBlitImage2KHR
vkCmdClearAttachment()
vkCmdClearAttachments
vkCmdClearColorImage
vkCmdClearColorImage()
vkCmdClearDepthStencilImage
vkCmdClearDepthStencilImage()
vkCmdCopyBuffer
vkCmdCopyBuffer()
vkCmdCopyBuffer2
vkCmdCopyBuffer2KHR
vkCmdCopyBufferToImage
vkCmdCopyBufferToImage()
vkCmdCopyBufferToImage2
vkCmdCopyBufferToImage2KHR
vkCmdCopyImage
vkCmdCopyImage()
vkCmdCopyImage2
vkCmdCopyImage2KHR
vkCmdCopyImageToBuffer
vkCmdCopyImageToBuffer()
vkCmdCopyImageToBuffer2
vkCmdCopyImageToBuffer2KHR
vkCmdCopyQueryPoolResults
vkCmdCopyQueryPoolResults()
vkCmdDispatch
vkCmdDispatch()
vkCmdDispatchBase
vkCmdDispatchBaseKHR
vkCmdDispatchIndirect
vkCmdDispatchIndirect()
vkCmdDraw
vkCmdDraw()
vkCmdDrawIndexed
vkCmdDrawIndexed()
vkCmdDrawIndexedIndirect
vkCmdDrawIndexedIndirect()
vkCmdDrawIndexedIndirectCount
vkCmdDrawIndexedIndirectCountKHR
vkCmdDrawIndirect
vkCmdDrawIndirect()
vkCmdDrawIndirectCount
vkCmdDrawIndirectCountKHR
vkCmdEndDebugUtilsLabelEXT
vkCmdEndQuery
vkCmdEndQuery()
vkCmdEndRenderPass
vkCmdEndRenderPass()
vkCmdEndRenderPass2
vkCmdEndRenderPass2KHR
vkCmdEndRendering
vkCmdEndRendering()
vkCmdEndRenderingKHR
vkCmdExecuteCommands
vkCmdExecuteCommands()
vkCmdFillBuffer
vkCmdFillBuffer()
vkCmdIndexBufferBind()
vkCmdInsertDebugUtilsLabelEXT
vkCmdNextSubpass
vkCmdNextSubpass()
vkCmdNextSubpass2
vkCmdNextSubpass2KHR
vkCmdPipelineBarrier
vkCmdPipelineBarrier()
vkCmdPipelineBarrier2
vkCmdPipelineBarrier2KHR
vkCmdPipelineBind()
vkCmdPushConstants
vkCmdResetEvent
vkCmdResetEvent()
vkCmdResetEvent2
vkCmdResetEvent2KHR
vkCmdResetQueryPool
vkCmdResetQueryPool()
vkCmdResolveImage
vkCmdResolveImage2
vkCmdResolveImage2KHR
vkCmdSetBlendConstants
vkCmdSetBlendConstants()
vkCmdSetCullMode
vkCmdSetCullModeEXT
vkCmdSetCullModeEXT()
vkCmdSetDepthBias
vkCmdSetDepthBias()
vkCmdSetDepthBiasEnable
vkCmdSetDepthBiasEnable()
vkCmdSetDepthBounds
vkCmdSetDepthBounds()
vkCmdSetDepthBoundsTestEnable
vkCmdSetDepthBoundsTestEnableEXT
vkCmdSetDepthBoundsTestEnableEXT()
vkCmdSetDepthCompareOp
vkCmdSetDepthCompareOpEXT
vkCmdSetDepthCompareOpEXT()
vkCmdSetDepthTestEnable
vkCmdSetDepthTestEnableEXT
vkCmdSetDepthTestEnableEXT()
vkCmdSetDepthWriteEnable
vkCmdSetDepthWriteEnableEXT
vkCmdSetDepthWriteEnableEXT()
vkCmdSetDeviceMask
vkCmdSetDeviceMaskKHR
vkCmdSetEvent
vkCmdSetEvent2
vkCmdSetEvent2KHR
vkCmdSetFrontFace
vkCmdSetFrontFaceEXT
vkCmdSetFrontFaceEXT()
vkCmdSetLineStippleEXT
vkCmdSetLineWidth
vkCmdSetLineWidth()
vkCmdSetPrimitiveRestartEnable
vkCmdSetPrimitiveRestartEnable()
vkCmdSetPrimitiveTopology
vkCmdSetPrimitiveTopologyEXT
vkCmdSetPrimitiveTopologyEXT()
vkCmdSetPushConstants()
vkCmdSetRasterizerDiscardEnable
vkCmdSetRasterizerDiscardEnable()
vkCmdSetScissor
vkCmdSetScissor()
vkCmdSetScissorWithCount
vkCmdSetScissorWithCountEXT
vkCmdSetScissorWithCountEXT()
vkCmdSetStencilCompareMask
vkCmdSetStencilCompareMask()
vkCmdSetStencilOp
vkCmdSetStencilOpEXT
vkCmdSetStencilOpEXT()
vkCmdSetStencilReference
vkCmdSetStencilReference()
vkCmdSetStencilTestEnable
vkCmdSetStencilTestEnableEXT
vkCmdSetStencilTestEnableEXT()
vkCmdSetStencilWriteMask
vkCmdSetStencilWriteMask()
vkCmdSetVertexInputEXT
vkCmdSetVertexInputEXT()
vkCmdSetViewport
vkCmdSetViewport()
vkCmdSetViewportWithCount
vkCmdSetViewportWithCountEXT
vkCmdSetViewportWithCountEXT()
vkCmdSignalEvent()
vkCmdUpdateBuffer
vkCmdUpdateBuffer()
vkCmdVertexBufferBind()
vkCmdWaitEvent()
vkCmdWaitEvents
vkCmdWaitEvents2
vkCmdWaitEvents2KHR
vkCmdWriteTimeStamp()
vkCmdWriteTimestamp
vkCmdWriteTimestamp2
vkCmdWriteTimestamp2KHR
vkCopyImageToImageEXT
vkCopyImageToMemoryEXT
vkCopyMemoryToImageEXT
vkCreateBuffer
vkCreateBufferView
vkCreateCommandPool
vkCreateComputePipelines
vkCreateDebugUtilsMessengerEXT
vkCreateDescriptorPool
vkCreateDescriptorSetLayout
vkCreateDescriptorUpdateTemplate
vkCreateDescriptorUpdateTemplateKHR
vkCreateDevice
vkCreateEvent
vkCreateFence
vkCreateFramebuffer
vkCreateGraphicsPipelines
vkCreateHeadlessSurfaceEXT
vkCreateImage
vkCreateImageView
vkCreateInstance
vkCreatePipelineCache
vkCreatePipelineLayout
vkCreatePrivateDataSlot
vkCreatePrivateDataSlotEXT
vkCreateQueryPool
vkCreateRenderPass
vkCreateRenderPass2
vkCreateRenderPass2KHR
vkCreateSampler
vkCreateSamplerYcbcrConversion
vkCreateSamplerYcbcrConversionKHR
vkCreateSemaphore
vkCreateShaderModule
vkCreateSwapchainKHR
vkCreateWaylandSurfaceKHR
vkCreateXcbSurfaceKHR
vkDestroyBuffer
vkDestroyBufferView
vkDestroyCommandPool
vkDestroyDebugUtilsMessengerEXT
vkDestroyDescriptorPool
vkDestroyDescriptorSetLayout
vkDestroyDescriptorUpdateTemplate
vkDestroyDescriptorUpdateTemplateKHR
vkDestroyDevice
vkDestroyEvent
vkDestroyFence
vkDestroyFramebuffer
vkDestroyImage
vkDestroyImageView
vkDestroyInstance
vkDestroyPipeline
vkDestroyPipelineCache
vkDestroyPipelineLayout
vkDestroyPrivateDataSlot
vkDestroyPrivateDataSlotEXT
vkDestroyQueryPool
vkDestroyRenderPass
vkDestroySampler
vkDestroySamplerYcbcrConversion
vkDestroySamplerYcbcrConversionKHR
vkDestroySemaphore
vkDestroyShaderModule
vkDestroySurfaceKHR
vkDestroySwapchainKHR
vkDeviceWaitIdle
vkEndCommandBuffer
vkEnumerateDeviceExtensionProperties
vkEnumerateDeviceLayerProperties
vkEnumerateInstanceExtensionProperties
vkEnumerateInstanceLayerProperties
vkEnumerateInstanceVersion
vkEnumeratePhysicalDeviceGroups
vkEnumeratePhysicalDeviceGroupsKHR
vkEnumeratePhysicalDevices
vkFlushMappedMemoryRanges
vkFreeCommandBuffers
vkFreeDescriptorSets
vkFreeMemory
vkGetBufferDeviceAddress
vkGetBufferDeviceAddressKHR
vkGetBufferMemoryRequirements
vkGetBufferMemoryRequirements2
vkGetBufferMemoryRequirements2KHR
vkGetBufferOpaqueCaptureAddress
vkGetBufferOpaqueCaptureAddressKHR
vkGetDescriptorSetLayoutSupport
vkGetDescriptorSetLayoutSupportKHR
vkGetDeviceBufferMemoryRequirements
vkGetDeviceBufferMemoryRequirementsKHR
vkGetDeviceGroupPeerMemoryFeatures
vkGetDeviceGroupPeerMemoryFeaturesKHR
vkGetDeviceGroupPresentCapabilitiesKHR
vkGetDeviceGroupSurfacePresentModesKHR
vkGetDeviceImageMemoryRequirements
vkGetDeviceImageMemoryRequirementsKHR
vkGetDeviceImageSparseMemoryRequirements
vkGetDeviceImageSparseMemoryRequirementsKHR
vkGetDeviceMemoryCommitment
vkGetDeviceMemoryOpaqueCaptureAddress
vkGetDeviceMemoryOpaqueCaptureAddressKHR
vkGetDeviceProcAddr
vkGetDeviceQueue
vkGetDeviceQueue2
vkGetEventStatus
vkGetFenceStatus
vkGetImageMemoryRequirements
vkGetImageMemoryRequirements2
vkGetImageMemoryRequirements2KHR
vkGetImageSparseMemoryRequirements
vkGetImageSparseMemoryRequirements2
vkGetImageSparseMemoryRequirements2KHR
vkGetImageSubresourceLayout
vkGetImageSubresourceLayout2EXT
vkGetInstanceProcAddr
vkGetMemoryFdKHR
vkGetMemoryFdPropertiesKHR
vkGetMemoryHostPointerPropertiesEXT
vkGetPhysicalDeviceExternalBufferProperties
vkGetPhysicalDeviceExternalBufferPropertiesKHR
vkGetPhysicalDeviceExternalFenceProperties
vkGetPhysicalDeviceExternalFencePropertiesKHR
vkGetPhysicalDeviceExternalSemaphoreProperties
vkGetPhysicalDeviceExternalSemaphorePropertiesKHR
vkGetPhysicalDeviceFeatures
vkGetPhysicalDeviceFeatures2
vkGetPhysicalDeviceFeatures2KHR
vkGetPhysicalDeviceFormatProperties
vkGetPhysicalDeviceFormatProperties2
vkGetPhysicalDeviceFormatProperties2KHR
vkGetPhysicalDeviceImageFormatProperties
vkGetPhysicalDeviceImageFormatProperties2
vkGetPhysicalDeviceImageFormatProperties2KHR
vkGetPhysicalDeviceMemoryProperties
vkGetPhysicalDeviceMemoryProperties2
vkGetPhysicalDeviceMemoryProperties2KHR
vkGetPhysicalDevicePresentRectanglesKHR
vkGetPhysicalDeviceProperties
vkGetPhysicalDeviceProperties2
vkGetPhysicalDeviceProperties2KHR
vkGetPhysicalDeviceQueueFamilyProperties
vkGetPhysicalDeviceQueueFamilyProperties2
vkGetPhysicalDeviceQueueFamilyProperties2KHR
vkGetPhysicalDeviceSparseImageFormatProperties
vkGetPhysicalDeviceSparseImageFormatProperties2
vkGetPhysicalDeviceSparseImageFormatProperties2KHR
vkGetPhysicalDeviceSurfaceCapabilities2KHR
vkGetPhysicalDeviceSurfaceCapabilitiesKHR
vkGetPhysicalDeviceSurfaceFormats2KHR
vkGetPhysicalDeviceSurfaceFormatsKHR
vkGetPhysicalDeviceSurfacePresentModesKHR
vkGetPhysicalDeviceSurfaceSupportKHR
vkGetPhysicalDeviceToolProperties
vkGetPhysicalDeviceToolPropertiesEXT
vkGetPhysicalDeviceWaylandPresentationSupportKHR
vkGetPhysicalDeviceXcbPresentationSupportKHR
vkGetPipelineCacheData
vkGetPrivateData
vkGetPrivateDataEXT
vkGetQueryPoolResults
vkGetRenderAreaGranularity
vkGetSemaphoreCounterValue
vkGetSemaphoreCounterValueKHR
vkGetSemaphoreFdKHR
vkGetSwapchainImagesKHR
vkImportSemaphoreFdKHR
vkInvalidateMappedMemoryRanges
vkMapMemory
vkMergePipelineCaches
vkQueueBeginDebugUtilsLabelEXT
vkQueueBindSparse
vkQueueEndDebugUtilsLabelEXT
vkQueueInsertDebugUtilsLabelEXT
vkQueuePresentKHR
vkQueueSubmit
vkQueueSubmit2
vkQueueSubmit2KHR
vkQueueWaitIdle
vkReleaseSwapchainImagesEXT
vkResetCommandBuffer
vkResetCommandPool
vkResetDescriptorPool
vkResetEvent
vkResetFences
vkResetQueryPool
vkResetQueryPoolEXT
vkSetDebugUtilsObjectNameEXT
vkSetDebugUtilsObjectTagEXT
vkSetEvent
vkSetPrivateData
vkSetPrivateDataEXT
vkSignalSemaphore
vkSignalSemaphoreKHR
vkSubmitDebugUtilsMessageEXT
vkTransitionImageLayoutEXT
vkTrimCommandPool
vkTrimCommandPoolKHR
vkUnmapMemory
vkUpdateDescriptorSetWithTemplate
vkUpdateDescriptorSetWithTemplateKHR
vkUpdateDescriptorSets
vkWaitForFences
vkWaitSemaphores
vkWaitSemaphoresKHR
vk_icdGetInstanceProcAddr
vk_icdGetPhysicalDeviceProcAddr
vk_icdNegotiateLoaderICDInterfaceVersion
vload_half
vload_halfn
vloada_halfn
vloadn
vsnprintf
vstore_half
vstore_half_r
vstore_halfn
vstore_halfn_r
vstorea_halfn
vstorea_halfn_r
vstoren
wasm
wasm-bounds-check
wcrtomb
wcslen
wcsnrtombs
when Dim is either 1D or 2D.
with ExplicitLod
wl_buffer_destroy
wl_display_dispatch
wl_display_get_registry
wl_display_roundtrip
wl_display_sync
wl_registry_add_listener
wl_registry_bind
wl_shm
wl_shm_create_pool
wl_shm_interface
wl_shm_pool_create_buffer
wl_shm_pool_destroy
wl_surface_attach
wl_surface_commit
wl_surface_damage
wmemchr
wrap-opkill
write
x86-32
x86-32 (same as x8632)
x86-64
x86-64 (same as x8664)
x8632
x8664
x86_32
x86_64
xcb_connection_has_error
xcb_copy_area
xcb_create_gc
xcb_flush
xcb_free_gc
xcb_free_pixmap
xcb_generate_id
xcb_get_extension_data
xcb_get_geometry
xcb_get_geometry_reply
xcb_get_maximum_request_length
xcb_put_image
xcb_shm_attach
xcb_shm_create_pixmap
xcb_shm_detach
xcb_shm_id
xcb_shm_query_version
xcb_shm_query_version_reply
xmm0
xmm1
xmm10
xmm11
xmm12
xmm13
xmm14
xmm15
xmm2
xmm3
xmm4
xmm5
xmm6
xmm7
xmm8
xmm9
~Nt1
