__gmon_start__
_fini
_ITM_deregisterTMCloneTable
_ITM_registerTMCloneTable
__cxa_finalize
_Jv_RegisterClasses
BinaryProperties_GetValue
Plat_DebugPrint
__cxa_atexit
LOG_GENERAL
LoggingSystem_IsChannelEnabled
LoggingSystem_Log(int, LoggingSeverity_t, LeafCodeInfo_t const&, char const*, ...)
Plat_ShouldCollectMiniDumpsForFatalErrors
Plat_ExitProcess
vtable for __cxxabiv1::__class_type_info
pthread_mutex_destroy
operator delete(void*)
g_pMemAlloc
pthread_mutex_lock
pthread_mutex_unlock
ThreadGetCurrentId
__cxa_guard_acquire
pthread_mutexattr_init
pthread_mutexattr_settype
pthread_mutex_init
__cxa_guard_release
vtable for __cxxabiv1::__si_class_type_info
operator new[](unsigned long)
memcpy
operator delete[](void*)
_V_strnicmp_fast
DevWarning(char const*, ...)
Plat_IsInDebugSession
CThreadFastMutex::Lock(char const*, int, unsigned long long, unsigned int) volatile
CThreadRWLock_FastRead::UnlockReadAccounting(char const*, int, unsigned int)
operator new(unsigned long)
Plat_GetThreadIndex
vtable for __cxxabiv1::__vmi_class_type_info
__cxa_pure_virtual
__stack_chk_fail
CommandLine
memset
CThreadSyncObject::Wait(unsigned int)
Plat_GetCPUFrequency
ThreadYield
CBufferString::AppendFormat(char const*, ...)
V_PrettifyNum
CBufferString::Purge(int)
Plat_ReconfigureWindow
CThreadRWLock_FastRead::HandleFirstWriteLockTransition()
CThreadEvent::Set()
CThreadSemaphore::Release(int, int*)
LoggingSystem_Log
memcmp
CThreadSpinRWLock::LockForRead(char const*, int)
CThreadSpinRWLock::UnlockRead(char const*, int)
CThreadSpinRWLock::SpinLockForWrite(char const*, int, unsigned long long)
CThreadSpinRWLock::UnlockWrite(char const*, int)
Plat_OsSpecificHandleToPlatWindow
Plat_WindowToOsSpecificHandle
CThreadEvent::CThreadEvent(bool)
CThreadRWLock_FastRead::CThreadRWLock_FastRead()
Plat_GetClockStart
g_pThreadPool
V_stricmp_fast
CThreadRWLock_FastRead::WaitForReadLockTransition(unsigned int, char const*, int)
Plat_GetWindowMonitorIndex
Plat_GetDesktopResolution
Plat_GetDefaultMonitorIndex
Plat_FloatTime
CThreadSyncObject::~CThreadSyncObject()
memmove
CThreadSemaphore::~CThreadSemaphore()
typeinfo for CThreadSyncObject
CThreadSyncObject::WaitImpl(unsigned int)
_V_strncpy
AssertMsg_ConditionFailed
Plat_MessageBox
V_strtoi64
V_stristr_fast(char const*, char const*)
GetCPUInformation
Plat_GlobalMemoryStatus
LoggingSystem_RegisterLoggingChannel
V_vsnprintf
ThreadJoin
V_logf
floorf
CreateNewThreadPool
ReturnJobManualEventToPool
CBufferString::Insert(int, char const*, int, bool)
Plat_NeedsLowFragmentation
SeriousWarning
V_qsort
LoggingSystem_Log(int, LoggingSeverity_t, Color, char const*, ...)
V_powf
ceilf
CThreadRWLock_FastRead::UnlockRead_LockForWrite()
CThreadRWLock_FastRead::UnlockWrite_LockForRead()
CThreadMultiWaitEvent::Set()
std::_Hashtable<unsigned long, unsigned long, std::allocator<unsigned long>, std::__detail::_Identity, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true>>::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node<unsigned long, false>*)
std::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const
std::__throw_bad_alloc()
std::pair<std::__detail::_Node_iterator<unsigned long, true, false>, bool> std::_Hashtable<unsigned long, unsigned long, std::allocator<unsigned long>, std::__detail::_Identity, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, true, true>>::_M_insert<unsigned long const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<unsigned long, false>>>>(unsigned long const&, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<unsigned long, false>>> const&, std::integral_constant<bool, true>)
COneTimeEvent::Allocate()
std::ctype<char>::do_widen(char) const
Plat_RequireSDL
strcmp
ReleaseThreadHandle
CreateSimpleThread
std::string::_Rep::_S_empty_rep_storage
std::string::_Rep::_M_destroy(std::allocator<char> const&)
std::basic_string<char, std::char_traits<char>, std::allocator<char>>::basic_string(char const*, std::allocator<char> const&)
std::basic_string<char, std::char_traits<char>, std::allocator<char>>::basic_string(std::string const&)
Plat_GetEnv
strlen
V_strlower_fast
std::__detail::_List_node_base::_M_hook(std::__detail::_List_node_base*)
vtable for std::basic_istringstream<char, std::char_traits<char>, std::allocator<char>>
vtable for std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char>>
vtable for std::basic_streambuf<char, std::char_traits<char>>
std::locale::~locale()
vtable for std::basic_ios<char, std::char_traits<char>>
std::ios_base::~ios_base()
std::ios_base::ios_base()
VTT for std::basic_istringstream<char, std::char_traits<char>, std::allocator<char>>
std::basic_ios<char, std::char_traits<char>>::init(std::basic_streambuf<char, std::char_traits<char>>*)
std::locale::locale()
std::basic_string<char, std::char_traits<char>, std::allocator<char>>::basic_string(char const*, unsigned long, std::allocator<char> const&)
std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char>>::_M_sync(char*, unsigned long, unsigned long)
std::basic_istream<char, std::char_traits<char>>& std::getline<char, std::char_traits<char>, std::allocator<char>>(std::basic_istream<char, std::char_traits<char>>&, std::basic_string<char, std::char_traits<char>, std::allocator<char>>&, char)
std::string::find(char const*, unsigned long, unsigned long) const
std::string::_M_leak_hard()
std::ctype<char>::_M_widen_init() const
std::basic_string<char, std::char_traits<char>, std::allocator<char>>::basic_string(std::string const&, unsigned long, unsigned long)
strtol
std::__throw_bad_cast()
std::__throw_out_of_range_fmt(char const*, ...)
UnregisterHibernationListener
RegisterHibernationListener
xcb_connect
Plat_GetWindowContentsScale
Plat_GetWindowClientSize
Plat_IsWindowMinimized
__pthread_key_create
Plat_GetMonitorResolution
Plat_TicksAfterSecsF
Plat_RelativeTicks
CMemAllocSystemInitialize
HangWatchdogInternal_BeginScope
HangWatchdogInternal_EndScope
dlopen
dlsym
EarlyInit_Tier0
operator new[](unsigned long, std::nothrow_t const&)
operator new(unsigned long, std::nothrow_t const&)
V_snprintf
_V_strncat
strchr
V_atoi
V_sscanf
V_atofloat64
ConMsg(char const*, ...)
V_atof
CreateInterface
KeyValuesSystem
DevMsg
LoggingSystem_LogDirect
V_strtoui64
V_UTF32ToUTF8
V_UnicodeLength(char const*)
V_UTF8CharsToUTF16
V_wcstoi64
V_swscanf
V_wcstod
wcslen
V_UTF8ToUTF32
V_snwprintf_cch
wcscmp
MemAlloc_AllocFunc
MemAlloc_FreeFunc
V_vsnprintfWarnTrunc
V_SetErrno
V_strtod
V_GetErrno
V_UTF16ToUTF8
DevMsg(char const*, ...)
_V_StringAfterPrefix
Plat_VirtualAlloc
Plat_VirtualFree
strcpy
_V_strncmp
_V_strnistr_fast
V_strnchr
CBufferString::Relinquish(CBufferString::EAllocationOption_t)
V_strupper_fast
V_UnicodeCaseConvert(char const*, char*, int, int, EStringConvertErrorPolicy)
V_vsnprintfSize
V_FixSlashes
V_RemoveDotSlashes
V_FixDoubleSlashes
_V_MakeAbsolutePath
V_UnqualifiedFileName
_V_StripLastDir
V_StripTrailingSlash
_V_StripExtension
_V_FileBase
_V_ExtractFileExtension
_V_ComposeFileName
V_strnlen
V_StrTrim
V_tier0_strstr
V_localeconv
g_Tier1_CRC32Table
g_Tier1_CRC64Table
Plat_GetOSType
Plat_IsHighDPI
V_qsort_s
V_CopyMemory3D
__memcpy_chk
V_expf
g_Mathlib_GammaToLinearByteTable
V_pow
sqrtf
V_sinf
free
malloc
realloc
fopen64
fseek
ftell
fread
fclose
std::vector<unsigned char, std::allocator<unsigned char>>::vector(unsigned long, std::allocator<unsigned char> const&)
std::vector<unsigned char, std::allocator<unsigned char>>::vector(unsigned long, std::allocator<unsigned char> const&)
std::vector<unsigned short, std::allocator<unsigned short>>::vector(unsigned long, std::allocator<unsigned short> const&)
std::vector<unsigned short, std::allocator<unsigned short>>::vector(unsigned long, std::allocator<unsigned short> const&)
std::vector<unsigned char, std::allocator<unsigned char>>::_M_default_append(unsigned long)
std::__throw_length_error(char const*)
std::string::swap(std::string&)
std::string::compare(char const*) const
void std::vector<unsigned char, std::allocator<unsigned char>>::_M_emplace_back_aux<unsigned char const&>(unsigned char const&)
void std::vector<unsigned char, std::allocator<unsigned char>>::_M_emplace_back_aux<unsigned char const&>(unsigned char const&)
void std::vector<std::vector<unsigned long, std::allocator<unsigned long>>, std::allocator<std::vector<unsigned long, std::allocator<unsigned long>>>>::_M_emplace_back_aux<std::vector<unsigned long, std::allocator<unsigned long>> const&>(std::vector<unsigned long, std::allocator<unsigned long>> const&)
void std::vector<std::vector<unsigned long, std::allocator<unsigned long>>, std::allocator<std::vector<unsigned long, std::allocator<unsigned long>>>>::_M_emplace_back_aux<std::vector<unsigned long, std::allocator<unsigned long>> const&>(std::vector<unsigned long, std::allocator<unsigned long>> const&)
std::vector<float, std::allocator<float>>::_M_default_append(unsigned long)
void std::vector<unsigned char, std::allocator<unsigned char>>::_M_range_insert<unsigned char const*>(__gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>, unsigned char const*, unsigned char const*, std::forward_iterator_tag)
void std::vector<unsigned char, std::allocator<unsigned char>>::_M_range_insert<char*>(__gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>, char*, char*, std::forward_iterator_tag)
void std::vector<unsigned char, std::allocator<unsigned char>>::_M_range_insert<__gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>>(__gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>, __gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>, __gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>, std::forward_iterator_tag)
__gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>> std::vector<unsigned char, std::allocator<unsigned char>>::insert<__gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>, void>(__gnu_cxx::__normal_iterator<unsigned char const*, std::vector<unsigned char, std::allocator<unsigned char>>>, __gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>, __gnu_cxx::__normal_iterator<unsigned char*, std::vector<unsigned char, std::allocator<unsigned char>>>)
strdup
fwrite
char* std::string::_S_construct<char*>(char*, char*, std::allocator<char> const&, std::forward_iterator_tag)
std::__throw_logic_error(char const*)
std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&)
VTT for std::basic_stringstream<char, std::char_traits<char>, std::allocator<char>>
vtable for std::basic_stringstream<char, std::char_traits<char>, std::allocator<char>>
std::basic_ostream<char, std::char_traits<char>>& std::__ostream_insert<char, std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>>&, char const*, long)
std::ostream::operator<<(int)
std::ostream::put(char)
std::ostream::flush()
std::string::assign(std::string const&)
std::string::assign(char const*, unsigned long)
std::string::append(char const*, unsigned long)
std::string::append(std::string const&)
std::string::insert(unsigned long, char const*, unsigned long)
calloc
std::string::operator+=(char const*)
__longjmp_chk
_setjmp
V_acosf
V_sincosf
RandomFloat
V_atan2f
floor
V_frexpf
V_cosf
V_asinf
V_fmodf
V_tanf
V_atanf
RandomSeed
ThreadSleep
V_strtok
V_PathContainsPath
CBufferString::MakeRelativePath(char const*, char const*)
CBufferString::RemoveFirstDir(CBufferString*)
CBufferString::ComposeFileName(char const*, char const*, char)
CBufferString::FixSlashes(char)
CBufferString::Swap(CBufferString&)
CBufferString::SetPtr(char*, int, int, bool, bool)
CBufferString::StripTrailingSlash()
CBufferString::RemoveDotSlashes(char)
CBufferString::ToLowerFast(int)
CBufferString::ExtendPath(char const*, char)
V_IsAbsolutePath
CBufferString::FixupPathName()
CBufferString::ExtractFilePath(char const*)
CBufferString::AppendConcat(int, char const* const*, int const*, bool)
V_GetFileExtension
Plat_GetModuleFilename
CBufferString::ShortenPath()
CBufferString::MakeAbsolutePath(char const*, char const*)
InstallSchemaBindings
GetResourceManifestCount
GetResourceManifests
CBufferString::Format(char const*, ...)
CBufferString::RemoveAt(int, int)
CBufferString::Concat(char const*, char const*, ...)
CBufferString::SetExtension(char const*)
CBufferString::AppendFormatV(char const*, __va_list_tag*)
_V_SetExtension
V_atoi64
V_atoui64
V_fpclassify
V_isnan
V_atofloat32
Plat_UUIDFromString
RegisterStringToken
GetCStringCharConversion
Plat_UUIDToString
_V_strcspn
V_strspn
std::__throw_bad_function_call()
CBufferString::StripExtension()
CBufferString::ExtractFirstDir(char const*)
__strcpy_chk
LoggingSystem_IsChannelEnabled(int, LoggingVerbosity_t)
V_log2f
V_log10f
V_exp2f
stderr
__fprintf_chk
fputc
__ctype_b_loc
__ctype_toupper_loc
__sprintf_chk
__vsnprintf_chk
std::string::reserve(unsigned long)
std::_Hash_bytes(void const*, unsigned long, unsigned long)
std::string::_M_mutate(unsigned long, unsigned long, unsigned long)
std::_Rb_tree_decrement(std::_Rb_tree_node_base*)
std::_Rb_tree_increment(std::_Rb_tree_node_base*)
std::_Rb_tree_insert_and_rebalance(bool, std::_Rb_tree_node_base*, std::_Rb_tree_node_base*, std::_Rb_tree_node_base&)
std::ios_base::Init::Init()
std::ios_base::Init::~Init()
__printf_chk
__snprintf_chk
std::basic_string<char, std::char_traits<char>, std::allocator<char>>::basic_string(unsigned long, char, std::allocator<char> const&)
std::string::find(char, unsigned long) const
std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string()
std::_Rb_tree_increment(std::_Rb_tree_node_base const*)
memchr
std::__detail::_List_node_base::_M_transfer(std::__detail::_List_node_base*, std::__detail::_List_node_base*)
std::__detail::_List_node_base::_M_unhook()
std::string::compare(std::string const&) const
std::locale::classic()
std::basic_ios<char, std::char_traits<char>>::imbue(std::locale const&)
std::basic_ios<char, std::char_traits<char>>::clear(std::_Ios_Iostate)
std::istream& std::istream::_M_extract<double>(double&)
stdout
std::string::append(unsigned long, char)
tolower
log2
VTT for std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>
vtable for std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>
std::ostream& std::ostream::_M_insert<bool>(bool)
std::__throw_out_of_range(char const*)
strtoul
stpcpy
abort
ceil
atan
acos
asin
sqrt
atan2
pthread_setcancelstate
__sigsetjmp
__pthread_register_cancel
pthread_setcanceltype
__pthread_unregister_cancel
__pthread_unwind_next
pthread_setspecific
pthread_getspecific
pthread_key_delete
VTT for std::basic_ofstream<char, std::char_traits<char>>
vtable for std::basic_ofstream<char, std::char_traits<char>>
std::basic_filebuf<char, std::char_traits<char>>::basic_filebuf()
std::basic_filebuf<char, std::char_traits<char>>::open(char const*, std::_Ios_Openmode)
std::ostream::write(char const*, long)
std::basic_filebuf<char, std::char_traits<char>>::close()
vtable for std::basic_filebuf<char, std::char_traits<char>>
std::__basic_file<char>::~__basic_file()
std::ostream& std::ostream::_M_insert<unsigned long>(unsigned long)
std::_Rb_tree_rebalance_for_erase(std::_Rb_tree_node_base*, std::_Rb_tree_node_base&)
std::cout
std::cerr
toupper
isalpha
std::string::replace(unsigned long, unsigned long, char const*, unsigned long)
std::ostream::operator<<(short)
std::ostream& std::ostream::_M_insert<long>(long)
std::ostream& std::ostream::_M_insert<double>(double)
std::string::_M_replace_aux(unsigned long, unsigned long, unsigned long, char)
isalnum
strtoll
strtoull
std::istream& std::istream::_M_extract<unsigned int>(unsigned int&)
std::basic_ostream<char, std::char_traits<char>>& std::operator<< <std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>>&, char const*)
std::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const
std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char>>::str() const
std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::basic_ostringstream(std::_Ios_Openmode)
std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::~basic_ostringstream()
std::placeholders::_1
std::nothrow
operator delete(void*, std::nothrow_t const&)
std::istream& std::istream::_M_extract<long>(long&)
std::istream& std::istream::_M_extract<unsigned long>(unsigned long&)
std::istream::peek()
std::istream::get()
isxdigit
isspace
std::istream& std::istream::_M_extract<float>(float&)
std::istream::unget()
__strcat_chk
std::string::find_first_not_of(char const*, unsigned long, unsigned long) const
pthread_create
std::thread::_M_start_thread(std::shared_ptr<std::thread::_Impl_base>, void (*)())
std::terminate()
std::__throw_system_error(int)
std::condition_variable::condition_variable()
std::condition_variable::notify_one()
std::thread::join()
std::condition_variable::~condition_variable()
std::chrono::_V2::system_clock::now()
std::condition_variable::wait(std::unique_lock<std::mutex>&)
pthread_cond_timedwait
std::__once_callable
__tls_get_addr
std::__once_call
__once_proxy
std::__future_base::_Result_base::~_Result_base()
std::__atomic_futex_unsigned_base::_M_futex_notify_all(unsigned int*)
std::__throw_future_error(int)
std::__atomic_futex_unsigned_base::_M_futex_wait_until(unsigned int*, unsigned int, bool, std::chrono::duration<long, std::ratio<1l, 1l>>, std::chrono::duration<long, std::ratio<1l, 1000000000l>>)
std::__future_base::_Result_base::_Result_base()
rewind
typeinfo for std::__future_base::_Result_base
pthread_once
fflush
opendir
readdir64
closedir
std::string::find_last_not_of(char const*, unsigned long, unsigned long) const
std::string::rfind(char, unsigned long) const
getpid
readlink
std::string::find_first_of(char const*, unsigned long, unsigned long) const
std::string::resize(unsigned long, char)
__memset_chk
localtime
ftello64
fseeko64
mktime
freopen64
__xstat64
remove
utime
g_Tier1_BitWriteMasks
g_Tier1_ExtraMasks
ThreadMultiWait
CThreadMultiWaitEvent::CThreadMultiWaitEvent(bool)
CThreadMultiWaitEvent::~CThreadMultiWaitEvent()
CThreadRWLock::WaitForRead()
_V_ExtractFilePath
CThreadRWLock::LockForWrite(char const*, int)
CThreadRWLock::UnlockWrite(char const*, int)
trunc
frexp
fprintf
longjmp
getenv
__gxx_personality_v0
__cxa_begin_catch
__cxa_rethrow
__cxa_end_catch
std::__future_base::_State_base::~_State_base()
std::current_exception()
std::__exception_ptr::exception_ptr::swap(std::__exception_ptr::exception_ptr&)
std::__exception_ptr::exception_ptr::~exception_ptr()
__assert_fail
std::condition_variable::notify_all()
vtable for std::__future_base::_State_base
std::thread::_M_start_thread(std::shared_ptr<std::thread::_Impl_base>)
std::chrono::_V2::steady_clock::now()
std::__exception_ptr::operator==(std::__exception_ptr::exception_ptr const&, std::__exception_ptr::exception_ptr const&)
roundf
std::__exception_ptr::exception_ptr::exception_ptr(std::__exception_ptr::exception_ptr const&)
std::rethrow_exception(std::__exception_ptr::exception_ptr)
typeinfo for std::__future_base::_State_base
vtable for __cxxabiv1::__pointer_type_info
__isnanf
libm.so.6
libdl.so.2
libstdc++.so.6
libpthread.so.0
ld-linux-x86-64.so.2
libxcb.so.1
libtier0.so
libvstdlib.so
dl_iterate_phdr
libc.so.6
_edata
__bss_start
_end
librendersystemvulkan.so
$ORIGIN
GLIBC_2.2.5
GLIBC_2.3
GLIBC_2.3.2
GLIBC_2.3.3
GLIBCXX_3.4.20
GLIBCXX_3.4.21
GLIBCXX_3.4.18
GLIBCXX_3.4.9
GLIBCXX_3.4.11
CXXABI_1.3
CXXABI_1.3.3
GLIBCXX_3.4.14
CXXABI_1.3.5
GLIBCXX_3.4.15
GLIBCXX_3.4.19
GLIBCXX_3.4
GLIBC_2.4
GLIBC_2.14
GLIBC_2.11
GLIBC_2.3.4
Intentionally vague touch behavior for %p\n
../public/ordered_constructor.h
Ordered constructor wrapped type has no default constructor.\n\tYou must construct it with ORDERED_CONSTRUCT macro in the dependency resolution function.\n
rendersystemvulkan
AddRef
16CColorFormatBase
text
binary
binary_bc
binary_lz4
binary_auto
TestFormatA
TestFormatB
TestFormatC
TestFormatD
TestFormatE
5t~BC
\r<unknown>
15CRenderResource
16CIndexBufferBase
blocking issue in occlusion queries!!\n
../public/tier1/utlfixedmemory.h
../public/tier1/utllinkedlist.h
CUtlLinkedList overflow! (exhausted memory allocator)\n
CUtlLinkedList overflow! (exhausted index range)\n
occlusionquerymgr.cpp
CUtlFixedMemory overflow!\n
AllocInternal
Grow
rendercontextbase.cpp
Invalid thread index (%d) given\n
Too many threads (%d) accessing the render device, need to increase -r_max_device_threads (%d)\n
CCommandBufferChunk CUtlMemoryPoolMT
CMediumCommandBufferChunk CUtlMemoryPoolMT
CLargeCommandBufferChunk CUtlMemoryPoolMT
SetAssociatedThreadIndex
14IRenderContext
22IStreamBuilderCallbackI14CCommandStreamE
18CRenderContextBase
ORENDER_MULTISAMPLE_INVALID
<unknown multisample type
-shaderstats
renderstatehelper.h
  VB: %d buffers, %.2f MB\n
  IB: %d buffers, %.2f MB\n
  CB: %u buffers, %.2f MB\n
  TEX: %u textures, %.2f MB\n
  TOTAL: %.2f MB\n
Texture Streaming:\n
  %s / %s MB\n
../public/tier1/utltshash.h
Display GPU memory usage.
r_gpu_mem_stats
-r_max_device_threads
-rendersystem_thread_mode
single
queued
renderdevicebase.cpp
../public/tier1/memstack.h
r_texturefilteringquality
r_fullscreen_gamma
r_wait_on_present
RENDER_MULTISAMPLE_NONE
RENDER_MULTISAMPLE_2X
RENDER_MULTISAMPLE_4X
RENDER_MULTISAMPLE_6X
RENDER_MULTISAMPLE_8X
RENDER_MULTISAMPLE_16X
Maximum device access threads: %u\n
Checked pending presents %s times; waited %s times; abandoned %s times\n
Texture memory: %s / %s MB; in %s textures (%s MB non-evictable)\n
Textures created overall: %s; textures evicted: %s\n
Command stream pools: %s bytes in base, %s bytes in medium, %s bytes in large (%s extra data fallbacks)\n
FindOrCreateTexture: Texture usage is unspecified!\n
FindOrCreateTexture: Texture scope is unspecified!\n
FindOrCreateTexture: Only dynamic textures can have non-global scope!\n
FindOrCreateTexture: Cannot create static textures with no data!\n
WARNING: Trying to create a CRenderContextPtr without a valid context.\n
FindOrCreateTexture: Cannot load multiple mipmaps into cubemap texture: %s\n
CRenderDeviceBase::FindOrCreateTexture: Trying to load multiple mipmaps into 3d or array texture: %s\n
rendersystem (%s) tracked resources:\n
  %s / %s MB (non-evictable: %s MB)\n
Overall System GPU memory use:\n
Warning: have oustanding per-frame memory stack with %d allocations\n
Warning: have %d in use and %d free per-frame memory stacks outstanding. The oldest stack was created at present %d, and we're now on present %d\n
Hitch alert: Present was waiting for %d iterations and %.1f seconds.\n
CSwapChainBase::QueuePresentAndWait() looped for %d iterations without a present event.\n
 Can't specify initial state of dynamic constant buffers at creation time!\n
CRenderDeviceBase::InitPerFrameMemoryStack
0: Bilinear, 1: Trilinear, 2: Aniso 2x, 3: Aniso 4x, 4: Aniso 8x, 5: Aniso 16x
Screen Gamma (only in fullscreen modes)
AllocInternal
Grow
12CThreadEvent
16ICommandCallback
26ICommandCompletionCallback
13IRenderDevice
12CDeviceFence
16CDeviceFenceBase
14CSwapChainBase
25CConCommandMemberAccessorI17CRenderDeviceBaseE
17CRenderDeviceBase
15CRenderPassDesc
5cfg/moddefaults.txt
video.cfg
VendorID
min megahertz
max megahertz
Intel
MinDeviceID
MaxDeviceID
min megabytes
max megabytes
min megatexels
max megatexels
-ignoredxsupportcfg
EXECUTABLE_PATH
dxsupport.cfg
setting.MaxDXLevel
setting.MinDXLevel
setting.DXLevel
setting.CentroidHack
setting.PreferZPrepass
setting.PreferHardwareSync
setting.Unsupported
-debugdxsupport
setting.fullscreen
setting.coop_fullscreen
setting.nowindowborder
setting.mat_vsync
setting.defaultres
setting.defaultresheight
setting.shaderquality
setting.high_dpi
cfg/videodefaults.txt
setting.
(%s): Setting %s to %s\n
(%s): ADD %s = %s\n
makemelast
Video Card %s (%04x : %04x)\n
min_processor_count
max_processor_count
setting.maxdxlevel
FileKeys
setting.knowndevice
setting.recommendedwidth
setting.recommendedheight
setting.refreshrate_numerator
setting.resettodefaults
cfg/video.txt
cfg/video_%02d.txt
_tools.txt
video_version
cfg/video_version.txt
-autoconfig
-autoconfig_level
RenderDevice003
RenderHardwareConfig002
RenderSystem
filesystem_stdio
VNewAsyncFileSystem001
resourcesystem
ResourceSystem013
vstdlib
ConfigurationSystem_001
localize
Localize_001
EventSystem001
renderdevicemgrbase.cpp
false
#RenderSystem_UnableToStartGame
#RenderSystem_CannotCreateDevice
Failed to create device. Modules loaded: %s\n
setting.DisableShaderOptimizations
setting.SuppressPixelShaderCentroidHackFixup
setting.PreferTexturesInHWMemory
setting.HasBrokenPipelineStats
setting.fullscreen_min_on_focus_loss
Can't detect memory size on this platform!\n
setting.refreshrate_denominator
Saved video settings config to '%s'\n
Failed to save video settings config to '%s'\n
Loaded video settings config from '%s'\n
Graphics Device changed, resetting video config\n
Video config version number changed ( '%s' is version %i, current version is %i ). Resetting video config.\n
10IAppSystem
16IRenderDeviceMgr
14CBaseAppSystemI16IRenderDeviceMgrE
15CTier0AppSystemI16IRenderDeviceMgrE
15CTier1AppSystemI16IRenderDeviceMgrLi0EE
15CTier2AppSystemI16IRenderDeviceMgrLi0EE
20CRenderDeviceMgrBase
-force_recommend_gl
-adapter
-disallowhwmorph
-maxdxlevel
DX11
OpenGL
Xbox 360
Empty
Mantle
Vulkan
Invalid rendersystem %d
Direct3D 9
Direct3D 11
<none>
-dx9
-dx11
<x360>
-empty
-mantle
-vulkan
<invalid %d>
Trying to set dxlevel (%d) which is lower than the card can support (%d)!\n
Trying to set dxlevel (%d) which is higher than the card can support (%d)!\n
21IRenderHardwareConfig
21CRenderHardwareConfig
Timed out waiting for thread to exit? hung?
Unsatisfied dependency at present time = death!
CTSQueue corruption
r_frame_sync_enable
../public/tier0/tslist.h
nTries < 10000000
Push
17CRenderThreadBase
RenderUtils_001
12IRenderUtils
14CBaseAppSystemI12IRenderUtilsE
15CTier0AppSystemI12IRenderUtilsE
15CTier1AppSystemI12IRenderUtilsLi0EE
15CTier2AppSystemI12IRenderUtilsLi0EE
12CRenderUtils
sheetcache.cpp
sheetcachetexture_.vtex
Overflow of the sheet cache texture. Releasing and starting over. This is ok in asset browser, not so ok if the game is triggering this!\n
Overflow of the sheet cache texture: Try increasing SheetCacheTextureRows in gameinfo.gi (current value %d)!\n
Rendersystem/SheetCacheTextureRows
Rendersystem/SheetCacheTextureCols
AllocateAndUploadSequenceData
AJob
RESOURCE_TYPE_TEXTURE
-dontEvictTextures
-maxtextureres
-deferTextureLoads
-preloadtextures
AsyncTextureHookup
Evict all resident texture.
r_textures_evict_all
-shadowTargetSize
texturebase.cpp
Streaming Validation: %s 
WAITING_FOR_IO 
WAITING_FOR_HOOKUP_JOB 
OUTSTANDING_HOOKUP_REQUEST 
TEXMAN: Deleting %d textures\n
AsyncHookUpTextureBits
png/jpg
immediate
TEXMAN: Abandoning job in %s\n
Bad VTEX data for '%s'\n
1600
r_texture_pool_size
r_texture_stream_mip_bias
r_max_texture_pool_size
r_texture_nonstreaming_load
r_validate_texture_streaming
RenderSystem/AllowSampleableDepthInVr
RenderSystem/AlwaysPreloadTexturesInGame
TEXMAN: Outstanding stream count %d -> %d (%s)\n
 -shadowTargetSize forcing nPoolSizeInMb size to %d from %d, bLarge %d, avail %lld\n
PERF WARNING: Texture pool size set to more than 80%% of total GPU memory.\n
GPU reports %dMB available memory which is too low, using %d MB\n
Texture memory discrepancy! %llu != %llu\n
Texture streaming validation OK (%d texture loads in flight).\n
Found %d streaming textures in array, but in-flight count is %d\n
CTextureManagerBase::MarkAsyncUpdatedThisFrame - Invalid texture handle.\n
CTextureManagerBase::WasAsyncUpdatedThisFrame - Invalid texture handle.\n
Texture manager out of space! Can't allocate new texture!\n
texturebase.cpp(2740):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2761):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2772):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2783):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2794):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2815):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2826):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2837):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
texturebase.cpp(2848):ResourceHandleToData( %s ) failed! Falling back to error texture!\n
TEXMAN: Adding %s, %llx to abandoned hookup jobs\n
TEXMAN: %s MarkTextureBitsLoaded (%s)\n
TEXMAN: DeferTextureLoads %s MarkTextureBitsLoaded (%s)\n
Discarding abandoned streaming texture load for %s\n
texturebase.cpp(1803):Error loading texture: %s\n
Deleting texture with outstanding streaming request (%s)\n
TEXMAN: Abandoning streaming request early in %s\n
Unable to stream in resource file "%s" (Error: %s)\n
Can't clear TEXTURE_WAITING_FOR_IO flag because of streaming request mismatch: %d in handle, %d in request\n
Clearing TEXTURE_WAITING_FOR_IO flag because it's has no streaming request id anymore\n
Can't clear TEXTURE_WAITING_FOR_IO flag because pTexture is NULL\n
TEXMAN: Abandoning streaming request in %s\n
TEXMAN: %s loaded %s %i/%i mips (%ix%i / %ix%i) of %s (%i bytes)\n
Compressed texture decoded in %.2f ms\n
Decompressed %i texture mips in %.2f ms (%.1fmb/s)\n
Unexpected resource version '%d' for '%s'\n
Failed AllocateTexture for '%s'\n
Total size of the texture pool in MB
Biases the mip level the texture streaming system choses to stream for each texture.
Upper limit on texture pool size.
Allow immediately loading mips of textures (when possible) when their headers are loaded, saving IO & reducing latency.
Only immediately load textures which have a fullmipchain.
r_texture_nonstreaming_only_fullmipchain
Async Texture hookup uses its own threadpool instead of the global pool.
r_texture_hookup_uses_threadpool
AllocTextureSlot
MN_BuildRequestedResourcesList
MN_OnResourceLoadCompleted
MN_OnResourceLoadFailed
AsyncHookUpTextureBits
MN_OnResourceFileLoaded
PreloadTextureBits
RemoveTextureFromAnyQueues
20IResourceTypeManager
22IToolsResourceListener
11IRefCounted
20CRefCountServiceBaseILb1E6CRefMTE
8CFunctor
12CTextureBase
21CTextureInfoChunkBase
25CConCommandMemberAccessorI19CTextureManagerBaseE
19CTextureManagerBase
12CRefCounted1I11IRefCounted20CRefCountServiceBaseILb1E6CRefMTEE
12CThreadedJob
11CFunctorJob
12CRefCounted1I8CFunctor20CRefCountServiceBaseILb1E6CRefMTEE
15CMemberFunctor5IP19CTextureManagerBaseMS0_FvP25IAsyncResourceDataRequest11CWeakHandleI31InfoForResourceTypeCTextureBaseEP12CTextureBase22TextureSpecification_tiES3_S6_S8_S9_i12CRefCounted1I8CFunctor20CRefCountServiceBaseILb1E6CRefMTEE18CFuncMemPolicyNoneE
15CMemberFunctor9IP19CTextureManagerBaseMS0_FvP12CTextureBase11CWeakHandleI31InfoForResourceTypeCTextureBaseE12ResourceId_tPvj22TextureSpecification_tS9_i23TextureBitsMemoryType_tES3_S6_S7_S8_iS9_S9_iSA_12CRefCounted1I8CFunctor20CRefCountServiceBaseILb1E6CRefMTEE18CFuncMemPolicyNoneE
@TEXTURESTREAMING: Extremely low memory: Available mem: %.2f MB, Required: %.2f MB.\n
GPU memory available (%d MB of %d MB used). Reducing texture pool size %d MB -> %d MB\n
GPU memory available (%d MB of %d MB used). Increasing texture pool size %d MB -> %d MB.\n
r_texture_stream_throttle_amount
r_texture_stream_throttle_count
After hitting throttling limits for streamout, allow it to continue up to this number of milliseconds.
r_texture_streamout_unthrottle_ms
r_texture_streaming_timesliced
Dynamically adjust texture streaming budget based on GPU memory usage.
Time (in seconds) between updating texture memory budget.
r_texture_budget_update_period
Reduce texture memory pool size when this percentage of the budget is full.
Reduce texture memory pool size by this many MB / s when over budget.
Increase texture memory pool size by this many MB / s when under budget.
TEX read request: %d KB; %s\n
r_texture_eager_eviction
r_texture_budget_dynamic
0.90
r_texture_budget_threshold
256.0
r_texture_pool_reduce_rate
64.0
r_texture_pool_increase_rate
LoadExplicitlyRequestedTextures
23CTextureStreamingHelper
vb_created_input_layout
17CVertexBufferBase
a[_\`
SMQNR
FJGK
18CColorFormatVulkan
vulkan_buffer_update_mode
0: Use classic mode. 1: Use per-thread persistently mapped buffers.
21CConstantBufferVulkan
Texture manager doesn't know about texture "%s" - returning error texture in  CTextureManagerVK::GetImageView\n
Asking for 2d Texture Array with Cube map as input and no compatible view found - returning error texture in CTextureManagerVK::GetImageView\n
Bad texture dimension type for texture "%s" - returning error texture in  CTextureManagerVK::GetImageView\n
Texture missing shader resource view - returning error texture in  CTextureManagerVK::GetImageView\n
Texture manager doesn't know about texture "%s" - returning error texture in CTextureManagerVulkan::GetResourceView\n
Bad texture dimension type for texture "%s" - returning error texture in CTextureManagerVulkan::GetResourceView\n
Texture missing shader resource view - returning error texture in CTextureManagerVulkan::GetResourceView\n
CDescriptorSetVulkan::Rebake - could not allocate descriptor in new pool.\n
20CDescriptorSetVulkan
Vulkan Framebuffer Manager Stats:\n
\tRenderpass Count Count ( %d ): \n
VK_ERROR_INITIALIZATION_FAILED
VK_ERROR_EXTENSION_NOT_PRESENT
VK_ERROR_INVALID_EXTERNAL_HANDLE
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
VK_ERROR_INCOMPATIBLE_DISPLAY_KHR
VK_ERROR_VALIDATION_FAILED_EXT
Prints out stats for the Vulkan Framebuffer manager
Vulkan framebuffers: %s; renderpasses: %s\n
vkCreateFramebuffer( m_pDeviceVulkan, &framebufferCreateInfo, NULL, &pFramebufferVulkan )
ERROR! VK call failed! result = %s ( %s )\n
vulkan/framebuffermgrvulkan.cpp
vkCreateRenderPass( m_pDeviceVulkan, &renderPassCreateInfo, NULL, &pRenderPass )
\tFramebuffer Count ( %d ): \n
VK_SUCCESS
VK_NOT_READY
VK_TIMEOUT
VK_EVENT_SET
VK_EVENT_RESET
VK_INCOMPLETE
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
VK_ERROR_MEMORY_MAP_FAILED
VK_ERROR_LAYER_NOT_PRESENT
VK_ERROR_INCOMPATIBLE_DRIVER
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_FORMAT_NOT_SUPPORTED
VK_ERROR_FRAGMENTED_POOL
VK_ERROR_OUT_OF_POOL_MEMORY
VK_ERROR_SURFACE_LOST_KHR
VK_SUBOPTIMAL_KHR
VK_ERROR_OUT_OF_DATE_KHR
VK_ERROR_INVALID_SHADER_NV
VK_ERROR_NOT_PERMITTED_EXT
Unknown VkResult value
vulkan_framebuffermgr_print
25CConCommandMemberAccessorI21CFramebufferMgrVulkanE
21CFramebufferMgrVulkan
*** IB "%s": Wrote a non integral number of indices!\n
*** IB "%s": Tried to lock a non integral number of indices!\n
*** IB "%s": Tried to lock twice without an unlock!\n
*** IB "%s": Tried to lock too much memory (%d>%d)!\n
*** IB "%s": Tried to lock a GPU-only buffer!\n
*** IB "%s": Tried to lock a static buffer twice!\n
*** IB "%s": Tried to lock too much memory for subregion (%d>%d)!\n
*** VB "%s": Failed to lock!\n
18CIndexBufferVulkan
psize
blendweight
blendindices
texcoord
binormal
positiont
tangents
tangentt
specular
wrinkle
11CRefCountedI20CRefCountServiceBaseILb1E6CRefMTEE
12CVulkanImage
Pool: %s (Free: %0.2f MB)\n
vulkan_memgr_print
RenderTarget
-vulkan_cmd_buffer_pool_size
RenderSystem/VulkanPoolSize%s
vkAllocateMemory
vulkan/memorymgrvulkan.cpp
%s allocation count overflow
Pool Type ( %s ): \n
Total PMB ( %llu MB ) \n
Total Dynamic ( %llu MB ) \n
Total Static ( %llu MB ) \n
Total Combined ( %llu MB ) \n
Vulkan Command Buffers:\n
\tTotal Command Buffers (%d)\n
DynamicPoolPMB_%s
StaticPool_%s
StaticPoolMemory_%s
../public/tier1/utlrbtree.h
DynamicPool_%s
\t FreeBlock Start: %s End: %s\n
Attempted to update an image layout for an image that was not transitioned in this command buffer.\n
Prints out stats for the Vulkan memory manager
Prints out detailed memory fragmentation stats for the Vulkan memory manager
vulkan_memgr_fragmentation_print
Vulkan Command Buffer Pool Threshold(%d)\n
-vulkan_disable_device_coherent_allocations
Override default %s Vulkan GPU memory pool size: %d MB (default: %d MB)\n
Requested memory properties that are not supported for this allocation. Requested (%x).\n
Invalid parameters to AllocateForObject( ... ).\n
Failed to find adequate memory type for buffer.\n
vkAllocateMemory failed for DEVICE_LOCAL memory indicating video memory is full, trying again in system memory as a fallback.\n
No Vulkan heaps support system memory allocation for this resource.\n
Previous allocation with memoryRequirements.memoryTypeBits=0x%x was from heap %d (propertyFlags: 0x%x) with requested propertyFlags 0x%x, trying in heap %d (propertyFlags: 0x%x) with requested propertyFlags 0x%x.\n
vkAllocateMemory failed fallback system memory allocation.  Fatal error: out of video and system memory.\n
vkAllocateMemory failed to allocate GPU memory.  Fatal error: out of GPU video memory and no fallback heap available.\n
vkCreateBuffer( m_pDeviceVulkan, &bufferCreateInfo, NULL, ppVKBufferOut )
Failed to allocate GPU memory for object.\n
%s allocation count overflow( %llu >= %llu )\n
../public/tier1/utlleanvector.h
vkResetCommandBuffer( pCmdBuffer, 0 )
vkBeginCommandBuffer( pCmdBuffer, &beginInfo )
CMemoryRefTracker::BuildStateTransitions (%s)
vkEndCommandBuffer( pCmdBuffer )
Rebalancing command buffer pools. Largest has %d command buffers, rebalancing to size %d command buffers\n
Vulkan static mem: %s; PMB mem: %s; command buffers: %s\n
Vulkan Dynamic Memory Manager Stats:\n
\tInUse Count ( %d ) ( %llu MB ) \n
\tAvail Count ( %d ) ( %llu MB ) \n
Vulkan Static Memory Manager Stats:\n
\tStatic Type ( %s ): Count ( %d ) ( %llu MB ) ( Free: %llu MB, Largest Free Block %llu MB )\n
Vulkan PMB Memory Manager Stats:\n
\tPMB Type ( %s ): Count ( %d ) ( %llu MB ) \n
\tThread (%llu) Command Buffers (%d)\n
vkCreateBuffer( m_pDeviceVulkan, &bufferCreateInfo, NULL, &pNewMemoryPool->m_pVulkanBuffer )
Allocation falling back to non-device local heap failed.\n
vkMapMemory( m_pDeviceVulkan, pNewMemoryPool->m_pGPUMemory, 0, pNewMemoryPool->m_nPoolSize, 0, (void**)&pNewMemoryPool->m_pMappedBuffer )
vkCreateBuffer( m_pDeviceVulkan, &bufferCreateInfo, NULL, &newMemoryPool.m_pVulkanBuffer )
Attempting fallback GPU allocation in system memory.\n
Failed fallback GPU allocation in system memory.\n
No memory type supports the requested properties. \n
CUtlRBTree overflow with %u elements!\n
vkFlushMappedMemoryRanges( m_pDeviceVulkan, 1, &mappedMemoryRange )
vkMapMemory( m_pDeviceVulkan, pDynamicMemoryPool->m_pGPUMemory, 0, pDynamicMemoryPool->m_nPoolSize, 0, &pMappedBuffer )
CMemoryManagerVulkan::AllocatePerFrameDynamicPooled: failed to find memory type index for memory properties\n
vkCreateBuffer( m_pDeviceVulkan, &bufferCreateInfo, NULL, pBufferOut )
vkMapMemory( m_pDeviceVulkan, newMemoryPool.m_pGPUMemory, 0, newMemoryPool.m_nPoolSize, 0, &pMappedBuffer )
Attempting to purge m_fencedResourceList.Count() = %d, m_pendingFencedResourceQueue.Count() = %d, nCurrentCmdBuffersAvailable = %d, nAllocatedCommandBuffers = %d\n
NewNode
Push
AllocInternal
AllocInternal
Push
AllocInternal
AllocInternal
Push
NewNode
NewNode
AllocInternal
Grow
AddToTailGetPtr
AllocInternal
AllocInternal
17CMemoryRefTracker
25CConCommandMemberAccessorI20CMemoryManagerVulkanE
20CMemoryManagerVulkan
29CMemoryReferenceManagerVulkan
Source2
FossilizePipelineCreation
Found matching VkApplicationInfo.pApplicationName: '%s' VkApplicationInfo.pEngineName: '%s'\n
Skipping pipeline layout creation, encountered null descriptor set layout.\n
Renderpass with too many attachment.  Max: %d Has: %d.  Rejecting.\n
Renderpass with invalid attachment reference.  Attachment #%d  Max: %d Has: %d.  Rejecting.\n
vkCreateRenderPass( VulkanDevice(), pRenderPassCreateInfo, nullptr, &pFossilizeRenderPass->m_pExplicitRenderPass )
Error creating renderpass from Vulkan Steam Shader Source pre-cache.\n
vulkan/pipelinecachemgrvulkan.cpp
Failed to read fossilize database: '%s'\n
Failed to prepare fossilize database: '%s'\n
Failed to get size of resource hashes.\n
Failed to get list of resource hashes.\n
Failed to get size of blob from cache.\n
Fossilize::StateReplayer failed to parse (tag: %d, hash: 0x%llx)\n
Loaded fossilize database in %0.2f seconds total (serial: %0.2fs parallel: %0.2fs)\n
AllocInternal
NewNode
NewNode
NewNode
NewNode
NewNode
NewNode
AllocInternal
NewNode
AllocInternal
NewNode
27CPipelineCacheManagerVulkan
N9Fossilize21StateCreatorInterfaceE
22CFossilizeStateCreator
15CMemberFunctor1IP26CParallelProcessorAbstractI18CParallelProcessorIN22CFossilizeStateCreator18PipelineWorkItem_tE27CMemberFuncJobItemProcessorIS3_S2_S2_ELi1EEEMS7_FviEi12CRefCounted1I8CFunctor20CRefCountServiceBaseILb1E6CRefMTEE18CFuncMemPolicyNoneE
>Vulkan Pipeline Manager Stats:\n
Prints out stats for the Vulkan Pipeline manager
-vulkan_disable_pipeline_cache
pExt->vkCreateDescriptorUpdateTemplateKHR( m_pDeviceVulkan, &descriptorUpdateTemplateCreateInfo, NULL, &pPipelineOut->m_pDescriptorUpdateTemplate )
Vulkan pipelines: %s; pipeline layouts: %s\n
vkGetPipelineCacheData( m_pDeviceVulkan, m_pPipelineCache, &nCacheSize, NULL )
vkGetPipelineCacheSize failed, unable to store pipeline cache to disk.\n
vkGetPipelineCacheData failed, unable to store pipeline cache to disk.\n
Unable to write to pipeline cache file "%s".  Error: %s
m_nFrontStencilDepthFailOp: %d\n
m_nBackStencilDepthFailOp: %d\n
m_nViewportAndScissorCount: %d\n
m_nRenderPassSubPassCount: %d\n
m_bIsComputeShaderDispatch: %d\n
m_nStaticDescriptorSetHashes[ %d ] = %llu\n
m_cbAttachmentState[ %d ].m_bBlendEnable = %d\n
m_cbAttachmentState[ %d ].m_nSrcBlendColor = %d\n
m_cbAttachmentState[ %d ].m_nDestBlendColor = %d\n
m_cbAttachmentState[ %d ].m_nBlendOpColor = %d\n
m_cbAttachmentState[ %d ].m_nSrcBlendAlpha = %d\n
m_cbAttachmentState[ %d ].m_nDestBlendAlpha = %d\n
m_cbAttachmentState[ %d ].m_nBlendOpAlpha = %d\n
m_cbAttachmentState[ %d ].m_nChannelWriteMask = %d\n
m_nColorRendertargetFormat[ %d ] = %d\n
m_bindingDescriptions[ %d ].m_nBinding = %d\n
m_bindingDescriptions[ %d ].m_nStrideInBytes = %d\n
m_bindingDescriptions[ %d ].m_nInputRate = %d\n
m_attributeDescriptions[ %d ].m_nLocation = %d\n
m_attributeDescriptions[ %d ].m_nBinding = %d\n
m_attributeDescriptions[ %d ].m_nFormat = %d\n
m_attributeDescriptions[ %d ].m_nOffsetInBytes = %d\n
Total pipeline count: %d This frame pre-warmed: %d Draw-time compiled: %d (Total time this frame: %0.2f ms Driver time this frame: %0.2f ms)\n
Unable to open Vulkan pipeline cache %s file - might not exist yet.\n
Unable to parse Vulkan pipeline cache %s file.  Error: %s\n
Vulkan shader pipeline cache file version is %d instead of %d for %s. Deleting.\n
Pipeline cache data not found.  Deleting %s.\n
Header size does not contain enough data in pipeline cache file %s.  Deleting.\n
VkPipelineCacheHeaderVersion mismatch in pipeline cache file (Got: %d Expected: %d).  Deleting %s in order to regenerate it.\n
Vendor ID mismatch in pipeline cache file (Got: %x Expected: %x).  Deleting %s in order to regenerate it.\n
Device ID mismatch in pipeline cache file (Got: %x Expected: %x).  Deleting %s in order to regenerate it.\n
UUID mismatch in pipeline cache file.  Deleting %s in order to regenerate it.\n
Failed to create Vulkan pipeline cache from file %s  - deleting so it can be regenerated.\n
( ( uint32 ) pLayoutBindingsBlob->GetBinaryBlobSize() ) == ( pipelineLayoutHash.m_pNumLayoutBindingsPerSet[ nDescriptorSet ] * sizeof( VkDescriptorSetLayoutBinding ) )
Assertion Failed in function %s():\n%s
( ( uint32 ) pPushConstantRangesBlob->GetBinaryBlobSize() ) == ( pipelineLayoutHash.m_nNumPushConstantRanges * sizeof( VkPushConstantRange ) )
( ( uint32 ) pImmutableSamplersBlob->GetBinaryBlobSize() ) == ( pipelineLayoutHash.m_nNumImmutableSamplers * sizeof( PipelineLayoutImmutableSampler_t ) )
vkCreateDescriptorSetLayout( m_pDeviceVulkan, &descriptorSetLayoutCreateInfo, NULL, &pipelineLayout.m_ppDescriptorSetLayouts[ nDescriptorSet ] )
vkCreatePipelineLayout( m_pDeviceVulkan, &pipelineLayoutCreateInfo, NULL, &pipelineLayout.m_pPipelineLayout )
vkCreatePipelineCache( m_pDeviceVulkan, &pipelineCacheCreateInfo, NULL, &m_pPerThreadPipelineCache[ nThread ] )
vkCreatePipelineCache( m_pDeviceVulkan, &pipelineCacheCreateInfo, NULL, &m_pPipelineCache )
vkCreateDescriptorSetLayout( m_pDeviceVulkan, &descriptorSetLayoutCreateInfo, NULL, &pPipelineLayoutOut->m_ppDescriptorSetLayouts[ nDescriptorSet ] )
vkCreatePipelineLayout( m_pDeviceVulkan, &pipelineLayoutCreateInfo, NULL, &pPipelineLayoutOut->m_pPipelineLayout )
Shader '%s' has more than the maximum number of samplers per stage (has: %d MAX: %d)\n
Shader '%s' has more than the maximum number of uniform blocks per stage (has: %d MAX: %d)\n
Shader '%s' has more than the maximum number of textures per stage (has: %d MAX: %d)\n
vkGetPipelineCacheData( m_pDeviceVulkan, pPipelineCache, &nCurrentPipelineSize, NULL )
Attempting to create a Vulkan pipeline with too many descriptors, aborting pipeline creation.\n
Attempting to create a Vulkan pipeline without a vertex shader bound, aborting pipeline creation.\n
vkCreateGraphicsPipelines( m_pDeviceVulkan, pPipelineCache, 1, &pipelineCreateInfo, NULL, &pPipelineOut->m_pPipeline )
Error creating graphics pipeline containing shader: %s\n
vkCreateComputePipelines( m_pDeviceVulkan, pPipelineCache, 1, &computePipelineCreateInfo, NULL, &pPipelineOut->m_pPipeline )
Error creating compute pipeline containing shader: %s\n
Failed to create Vulkan pipeline object.\n
Failed to pre-warm pipeline object.\n
vulkan_pipeline_compile_spew_threshold
\tPSO Count ( %d ) \n
\tLayout Count( %d ) \n
shadercache/vulkan
vulkan_pipelinemgr_print
-vulkan_force_sm30
cacheData
pipelineLayoutTable
descriptorSetTable
numPushConstantRanges
numLayoutBindings
layoutBindings
pushConstantRanges
numImmutableSamplers
immutableSamplers
vulkan/pipelinemgrvulkan.cpp
Pipeline Dump\n
=============\n
Hash: %llu\n
m_nVertexBindingCount: %d\n
m_nVertexAttributeCount: %d\n
m_nPrimitiveTopology: %d\n
m_bDepthClipEnable: %d\n
m_nFillMode: %d\n
m_nCullMode: %d\n
m_nFrontFace: %d\n
m_bAlphaToCoverageEnable: %d\n
m_nAttachmentCount: %d\n
m_bDepthTestEnable: %d\n
m_bDepthWriteEnable: %d\n
m_nDepthCompareOp: %d\n
m_bStencilTestEnable: %d\n
m_nFrontStencilFailOp: %d\n
m_nFrontStencilPassOp: %d\n
m_nFrontStencilCompareOp: %d\n
m_nBackStencilFailOp: %d\n
m_nBackStencilPassOp: %d\n
m_nBackStencilCompareOp: %d\n
m_nRasterSamples: %d\n
m_nPatchControlPoints: %d\n
m_nDepthStencilFormat: %d\n
m_nRenderPassSubPass: %d\n
m_nSampleMask: %d\n
m_nShaderHash[ %d ] = %llu\n
shaders.cache
%s/%s
vulkan_async_descriptors
vulkan_pipeline_compile_spew
gshs
LoadPipelineCache
AllocInternal
Grow
AllocInternal
AllocInternal
15CPipelineVulkan
25CConCommandMemberAccessorI22CPipelineManagerVulkanE
22CPipelineManagerVulkan
MbP?LockDynamicTexture not currently implemented in rendersystemvulkan\n
vkDeviceWaitIdle( m_pDeviceVulkan )
vulkan/rendercontextvulkan.cpp
vkResetCommandBuffer( (*ppCommandBuffer)->m_pCmdBuffer, 0 )
vkBeginCommandBuffer( (*ppCommandBuffer)->m_pCmdBuffer, &beginInfo )
Too many threads (%d) accessing the render device, need to increase -r_max_device_threads\n
vulkan/rendercontextvulkan.cpp(499): 
vulkan/rendercontextvulkan.cpp(512): 
returning error texture in CTextureManagerVulkan::GetTextureResource\n
CRenderContextVulkan::SemaphoreWaitAtBegin - already set semaphore to wait on, can't set another one.\n
CopyGPUBufferHiddenStructureCount failed - invalid source buffer.\n
CopyGPUBufferHiddenStructureCount failed - invalid destination buffer.\n
vkMapMemory( m_pDeviceVulkan, pGPUMemory, 0, nDataSize, 0, &pMappedBuffer )
CRenderContextVulkan::CopyTexture failed to get resource.\n
CRenderContextVulkan::CopyTexture - Trying to copy from a rect that is outside of the src texture\n
-vulkan_disable_occlusion_queries
CRenderContextVulkan::EndQuery - Issued on an in-progress query!\n
CRenderContextVulkan::SetSteamVrCompositorTexture failed because no Vulkan image was found.\n
CRenderContextVulkan::ClearUnorderedAccessViewUint could not get CVulkanImage for texture %s.
UAVBarrier - requested barrier for more mip levels than are in the texture. Requested baseLevel: %d levelCount: %d (Actual levels: %d).  Clamping to actual number of levels.\n
DispatchComputeShaderIndirect failed - invalid dispatch buffer.\n
Incorrect primitive topology for bound shader. Shader expects RENDER_PRIM_%d_CONTROL_POINT_PATCHLIST. Rendering will be corrupt.\n
CRenderContextVulkan:: Trying to resolve from a rect that is outside of the src rendertarget\n
%s called on an immutable constant buffer\n
vkMapMemory( m_pDeviceVulkan, pGPUStagingMemory, 0, nDataSize + nPossibleAlignmentPadding, 0, ( void** ) &pStagingMemory )
CRenderContextVulkan::BeginQuery - Issued a Begin on a non-occlusion query\n
Failed to get a Vulkan memory pool for query object\n
CRenderContextVulkan::BeginQuery - Issued on an in-progress query!\n
vr_vulkan_wait_fence_between_eyes
vkEndCommandBuffer( pCommandBuffer->m_pCmdBuffer )
Attempted to begin renderpass on invalid renderpass handle.\n
resolve
clear
TextureStaging
SetConstantBufferDataInternal
AllocInternal
AllocInternal
Grow
MarkIssuesCommands
20CRenderContextVulkan
vulkan/renderdevicevulkan.cpp
./renderresource.h
Render Device Empty\n
-nogammaramp
invalid handle
-vulkanrenderthreadstack
VKRenderThread
-vulkan_enable_validation
AMD RADV
vs_4_0
ps_4_0
-vulkan_no_image_transitions
-vktrace
-glsl_to_spirv
-vulkan_metal_validation
./inputlayoutbase.h
concatenated_input_layout
ClearLayout
ResolveLayout
#define SHADER_MODEL_4 1\n
-vulkan_dump_shaders
basic_string::substr
r_multigpu_num_gpus_found
r_multigpu_num_gpus_used
Vulkan Physical Device: %s\n
-sgpu
-nomultigpu
VK_EXT_debug_marker
VK_NV_dedicated_allocation
VK_KHR_bind_memory2
VK_KHR_device_group
VK_KHR_image_format_list
VK_KHR_maintenance1
VK_KHR_maintenance2
VK_EXT_separate_stencil_usage
VK_EXT_memory_budget
VK_GOOGLE_display_timing
VK_EXT_validation_cache
-vulkan_disable_async_compute
Vulkan extension enabled: %s\n
vkCmdDebugMarkerBeginEXT
vkCmdDebugMarkerEndEXT
vkDebugMarkerSetObjectTagEXT
vkDebugMarkerSetObjectNameEXT
vkCmdDebugMarkerInsertEXT
vkCmdSetDeviceMaskKHR
vkAcquireNextImage2KHR
vkCmdDispatchBaseKHR
vkBindBufferMemory2KHR
vkBindImageMemory2KHR
vkCmdSetCheckpointNV
vkGetQueueCheckpointDataNV
vkCreateValidationCacheEXT
vkDestroyValidationCacheEXT
vkMergeValidationCachesEXT
vkGetValidationCacheDataEXT
vkTrimCommandPoolNVX
-oldtexturestreaming
-newtexturestreaming
-multigpu
vkCreateSwapchainKHR
vkDestroySwapchainKHR
vkGetSwapchainImagesKHR
vkAcquireNextImageKHR
vkQueuePresentKHR
DefaultVB
CRenderDeviceVulkan::SetHardwareGammaRamp failed to get swap chain.\n
SDL failed to set window gamma ramp: %s\n
vkGetPhysicalDeviceImageFormatProperties failed checking for MSAA support, assuming MSAA can't be supported\n
Failed to setup frame pacing, renderthread is not available.\n
Vulkan driver version Major = %d, Minor = %d, Patch = %d\n
-vulkan_nv_disable_kepler_workaround
-vulkan_amd_disable_bind_vertex_buffers_workaround
-vulkan_disable_mipgen_compute_shader
RenderSystem/VulkanSteamShaderCache
-vulkan_disable_steam_shader_cache
STEAM_FOSSILIZE_DUMP_PATH_READ_ONLY
Attempting to load Steam Shader Pre-Cache database from %s\n
Unable to load Steam Shader Pre-cache database %s\n
Successfully loaded Steam Shader Pre-cache database %s\n
struct VS_INPUT\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat3 vProjPos\t\t\t\t\t: POSITION0;\t\n\tfloat4 vColor\t\t\t\t\t: COLOR0;\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nstruct VS_OUTPUT\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 vColor\t\t\t\t\t: COLOR;\t\t\n\tfloat4 vProjPos\t\t\t\t\t: SV_Position;\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nVS_OUTPUT main( const VS_INPUT v )\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tVS_OUTPUT o = ( VS_OUTPUT )0;\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\to.vProjPos.xyz = v.vProjPos;\t\t\t\t\t\n\to.vProjPos.w = 1.0;\t\t\t\t\t\t\t\t\n\to.vColor = v.vColor;\t\t\t\t\t\t\t\n\treturn o;\t\t\t\t\t\t\t\t\t\t\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\n
Error creating the clearing vertex shader!\n
struct PS_INPUT\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 vColor\t\t\t\t\t: COLOR;\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nfloat4 main( const PS_INPUT i )\t: SV_TARGET0\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\treturn i.vColor;                                \n}\t\t\t\t\t\t\t\t\t\t\t\t\t\n
Error creating the clearing pixel shader!\n
struct VS_INPUT\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat3 vProjPos\t\t\t\t\t: POSITION0;\t\n\tfloat4 vTexCoordScaleOffset\t\t: COLOR0;\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nstruct VS_OUTPUT\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 vTexCoordScaleOffset\t\t: COLOR;\t\t\n\tfloat4 vProjPos\t\t\t\t\t: SV_Position;\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nVS_OUTPUT main( const VS_INPUT v )\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tVS_OUTPUT o = ( VS_OUTPUT )0;\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\to.vProjPos.xyz = v.vProjPos;\t\t\t\t\t\n\to.vProjPos.w = 1.0;\t\t\t\t\t\t\t\t\n\to.vTexCoordScaleOffset = v.vTexCoordScaleOffset;\n\treturn o;\t\t\t\t\t\t\t\t\t\t\n}\t\t\t\t\t\t\t\t\t\t\t\t\t
Error creating the resolve vertex shader!\n
struct PS_INPUT\t\t\t\t\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 vTexCoordScaleOffset\t\t: COLOR;\t\t\t\t\t\t\n\tfloat4 vProjPos\t\t\t\t\t: SV_Position;\t\t\t\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nTexture2D<float4> g_tSrctexture : register( t0 );\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nfloat4 main( const PS_INPUT i )\t: SV_TARGET0\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tint2 vSamplePos = ( i.vProjPos.xy + i.vTexCoordScaleOffset.zw );\n\treturn g_tSrctexture.Load( int3( vSamplePos, 0 ) );\t\t\t\t\n }
Error creating the resolve pixel shader!\n
struct PS_INPUT\t\t\t\t\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 vTexCoordScaleOffset\t\t: COLOR;\t\t\t\t\t\t\n\tfloat4 vProjPos\t\t\t\t\t: SV_Position;\t\t\t\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nTexture2DMS<float4> g_tMSAASrctexture : register( t0 );\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nfloat4 main( const PS_INPUT i )\t: SV_TARGET0\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tint2 vSamplePos = ( i.vProjPos.xy + i.vTexCoordScaleOffset.zw );\n\treturn g_tMSAASrctexture.Load( vSamplePos, 0 );\t\t\t\t\t\n}
Error creating the resolve MSAA pixel shader!\n
struct PS_INPUT\t\t\t\t\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat4 vTexCoordScaleOffset\t\t: COLOR;\t\t\t\t\t\t\n\tfloat4 vProjPos\t\t\t\t\t: SV_Position\t\t;\t\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nTexture2DMS<float4> g_tMSAASrctexture : register( t0 );\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nfloat main( const PS_INPUT i )\t: SV_DEPTH\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tint2 vSamplePos = ( i.vProjPos.xy + i.vTexCoordScaleOffset.zw );\n\treturn g_tMSAASrctexture.Load( vSamplePos, 0 ).x;\t\t\t\t\n}
Error creating the resolve depth MSAA pixel shader!\n
struct VS_INPUT\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat3 vProjPos\t\t\t\t\t: POSITION0;\t\n\tfloat2 vTexCoord\t\t\t\t: TEXCOORD0;\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nstruct VS_OUTPUT\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat2 vTexCoord\t\t\t\t: TEXCOORD0;\t\n\tfloat4 vProjPos\t\t\t\t\t: SV_Position;\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nVS_OUTPUT main( const VS_INPUT v )\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tVS_OUTPUT o = ( VS_OUTPUT )0;\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\to.vProjPos.xyz = v.vProjPos;\t\t\t\t\t\n\to.vProjPos.w = 1.0;\t\t\t\t\t\t\t\t\n\to.vTexCoord = v.vTexCoord;\t\t\t\t\t\t\n\treturn o;\t\t\t\t\t\t\t\t\t\t\n}\t\t\t\t\t\t\t\t\t\t\t\t\t
Error creating the resolve rotated vertex shader!\n
struct PS_INPUT\t\t\t\t\t\t\t\t\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat2 vTexCoord\t\t\t\t: TEXCOORD0;\t\t\t\t\t\n};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nTexture2D<float4> g_tSrctexture : register( t0 );\t\t\t\t\t\nSamplerState g_sSrcSampler : register( s0 );\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nfloat4 main( const PS_INPUT i )\t: SV_TARGET0\t\t\t\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\treturn g_tSrctexture.SampleLevel( g_sSrcSampler, i.vTexCoord.xy, 0 );\n}
Error creating the resolve rotated pixel shader!\n
Skipping vkDestroySwapchainKHR to avoid bug in Android vulkan loader with VK_GOOGLE_display_timing requiring a valid ANativeWindow.\n
Skipping vkDestroySurfaceKHR because it can't be called without first doing vkDestroySwapchainKHR.\n
vkCreateQueryPool( m_pDeviceVulkan, &queryPoolCreateInfo, NULL, &newQueryPool.m_pOcclusionQueryPool )
Ran out of occlusion query slots.\n
Border color not supported by VK (%x), defaulting to white.\n
vkCreateSampler( VulkanDevice(), &samplerCreateInfo, NULL, &pSampler )
vkCreateDescriptorPool( m_pDeviceVulkan, &descriptorPoolCreateInfo, NULL, &pDescriptorPool )
TEXTURESTREAMING: Filled %d fallback textures in %.3f ms\n
vkQueueWaitIdle( m_pQueueVulkan )
RenderSystem/SwapChainSampleableDepth
Failed to create depth stencil image with VK.\n
vkBindImageMemory( pDeviceVulkan, m_pDepthStencilImage->m_pImage, m_pDepthStencilImage->m_pGPUMemory, 0 )
vkCreateImage() - failed to create cooperative fullscreen image.\n
vkBindImageMemory( pDeviceVulkan, m_pIntermediateSwapChainImage->m_pImage, m_pIntermediateSwapChainImage->m_pGPUMemory, 0 )
vkCreateSemaphore( m_pDeviceVulkan, &semaphoreCreateInfo, nullptr, &pVulkanSemaphore->m_pSemaphore )
Rasterizer state is VK_POLYGON_MODE_LINE but VkPhysicalDeviceFeatures.fillModeNonSolid is not supported.  Forcing to VK_POLYGON_MODE_FILL.  May result in incorrect rendering.\n
-vulkan_descriptor_sets_per_pool
Attempted to update invalid descriptor set.\n
CRenderDeviceVulkan::UpdateDescriptorSet: Failed to update descriptor set.\n
Descriptor pool allocation failed, reducing descriptors to attempt allocating in pool to %d\n
vkAllocateDescriptorSets( m_pDeviceVulkan, &allocInfo, &pCurrentDescriptorSetPool->m_ppDescriptorSets[ pCurrentDescriptorSetPool->m_nCurrentDescriptorSet - 1 ] )
Vulkan failed to create descriptor pool.\n
CRenderDeviceVulkan::CreateDescriptorSet: Failed to create descriptor set.\n
Attempting to release an invalid semaphore handle.\n
*** IL "%s": Unable to create input layout; layout has %d fields, which is more than %d!\n
%s: Can't concatenate input layouts with more than %d fields total!\n
vkCreateCommandPool( m_pDeviceVulkan, &cmdPoolCreateInfo, NULL, &cmdPool )
vkAllocateCommandBuffers( m_pDeviceVulkan, &cmdBufferCreateinfo, &pCmdBuffer )
CRenderDeviceVulkan::GetDeviceSpecificTexture() failed to get texture data.\n
Link failed; no code produced.  Log string from glslang %s\n
Compilation failed.  Log string from glslang %s\n
Failed to create VK shader module.\n
%s: __pos (which is %zu) > this->size() (which is %zu)
VR: Creating Device on Adapter (%d) connected to HMD, ignoring passed in Adapter (%d).\n
RenderSystem/VulkanUseStreamingTextureManager
Less than 1GB of texture memory detected, force streaming texture manager.\n
Initializing new streaming texture manager.\n
Initializing texture manager.\n
-vulkan_disable_nv_dedicated_allocation
-vulkan_disable_khr_descriptor_update_template
-vulkan_disable_khr_image_format_list
-vulkan_disable_khr_maintenance1
-vulkan_disable_khr_maintenance2
-vulkan_disable_ext_separate_stencil_usage
-vulkan_disable_khr_swapchain_mutable_format
-vulkan_disable_ext_memory_budget
-vulkan_disable_ext_memory_priority
-vulkan_disable_amd_memory_overallocation_behavior
-vulkan_diagnostic_checkpoints
InitDevice: vkEnumerateDeviceExtensionProperties( ... , NULL ) failed.\n
CRenderDeviceVulkan::InitDevice: vkEnumerateDeviceExtensionProperties( ... ) failed.\n
VK_KHR_descriptor_update_template
VK_KHR_swapchain_mutable_format
VK_NV_device_diagnostic_checkpoints
VK_AMD_memory_overallocation_behavior
-vulkan_disable_ext_validation_cache
VK_LAYER_LUNARG_standard_validation
'%s' not supported, vkAllocateDescriptorSets validation errors may be reported.\n
CRenderDeviceVulkan::InitDevice: failed to get queue properties\n
CRenderDeviceVulkan::InitDevice: no graphics queue found\n
Vulkan MultiGPU Rendering - Enabled!\n
Vulkan MultiGPU Rendering - using %d GPUs\n
Vulkan device does not support precise occlusion queries, this may result in incorrect rendering that relies on accurate occlusion queries (such as tonemapping).\n
-vulkan_enable_robust_buffer_access
vkCreateDevice failed, unable to create Vulkan device.\n
unable to populate vk_ext_khr_device_swapchain entrypoints.\n
Unable to populate vk_debug_marker_lunarg entrypoints.\n
Unable to populate %s entrypoints.\n
vkGetDeviceGroupPeerMemoryFeaturesKHR
vkGetDeviceGroupPresentCapabilitiesKHR
vkGetDeviceGroupSurfacePresentModesKHR
vkGetPhysicalDevicePresentRectanglesKHR
-vulkan_enable_nvx_trim_command_pool
Unable to populate VK_NVX_trim_command_pool entrypoints.\n
Failed to initialize Vulkan memory manager.\n
Using VK_GOOGLE_display_timing for frame pacing.\n
Vulkan driver version: %d.%d.%d.%d\n
RenderSystem/VulkanMutableSwapchain
RenderSystem/VulkanUseExternalSubpassDependency
-vulkan_disable_external_subpass_dependency
Vulkan using external subpass dependencies for all renderpasses.\n
RenderSystem/VulkanLazilyAllocateRenderTargets
Vulkan lazily allocating render targets.\n
vkCreateDescriptorUpdateTemplateKHR
vkDestroyDescriptorUpdateTemplateKHR
vkUpdateDescriptorSetWithTemplateKHR
Failed to create VkSurfaceKHR.\n
Call to vkGetPhysicalDeviceSurfaceSupportKHR returned an error.\n
The selected graphics queue does not support presenting a swapchain image.\n
Unable to query size of supported swapchain formats.\n
Unable to query supported swapchain formats.\n
No displayable format found for swapchain that supports the requested display mode.\n
VulkanKhrSurface()->vkGetPhysicalDeviceSurfaceCapabilitiesKHR( pPhysicalDeviceVulkan, m_pSurfaceKHR, &surfaceCaps )
VulkanKhrSurface()->vkGetPhysicalDeviceSurfacePresentModesKHR( pPhysicalDeviceVulkan, m_pSurfaceKHR, &nPresentModeCount, NULL )
VulkanKhrSurface()->vkGetPhysicalDeviceSurfacePresentModesKHR( pPhysicalDeviceVulkan, m_pSurfaceKHR, &nPresentModeCount, pPresentModes )
Swapchain extent(s) are 0, skipping swapchain creation\n
Vulkan swapchain does not support VK_IMAGE_USAGE_TRANSFER_SRC_BIT. Screenshots not supported.\n
Vulkan swapchain does not support VK_IMAGE_USAGE_TRANSFER_DST_BIT. Upscaling desktop friendly fullscreen not supported.\n
-vulkan_disable_swapchain_sampling
Call to vkCreateSwapchainWSI returned an error.\n
VulkanKhrSwapchain()->vkGetSwapchainImagesKHR( m_pDeviceVulkan, m_pSwapChainKHR, &m_nSwapQueueImageCount, NULL )
VulkanKhrSwapchain()->vkGetSwapchainImagesKHR( m_pDeviceVulkan, m_pSwapChainKHR, &m_nSwapQueueImageCount, pSwapChainImages )
vkQueueWaitIdle( VulkanQueue() )
vkCreateSemaphore( m_pDeviceVulkan, &acquireNextImageSemaphoreCreateInfo, NULL, &pAcquireNextImageSemaphore )
CSwapChainVulkan::SwapBuffers(): the main thread is more than %d frames ahead which means no swap queue images are available.  Waiting for outstanding frames...\n
CSwapChainVulkan::SwapBuffers(): waited for %0.2f seconds\n
Vulkan swapchain out-of-date, suboptimal, or surface lost - recreating.  Result: (%s)\n
Vulkan swapchain recreated succesfully.  Attempting to acquire next image...
vkAcquireNextImageKHR returned %s\n
GetVfxShaderFile: Failed to unserialize CVfxShaderFile.  Is your shadercache out-of-date?  Try deleting it.\n
GetVfxShaderFile: Failed to unserialize CVfxShaderFileVulkan.  Is your shadercache out-of-date?  Try deleting it.\n
AllocInternal
NewNode
AllocInternal
UpdateDescriptorSetPool
AllocInternal
AllocInternal
AllocInternal
AllocInternal
ConcatentateInputLayouts
Push
Push
AllocInternal
AllocInternal
NewNode
GetDeviceSpecificTexture
CreateSwapChain
NewNode
CreateDefaultShaders
Grow
Grow
Grow
Grow
Grow
Grow
Grow
19IRenderShaderBuffer
25ITextureResidencyListener
20IHibernationListener
13CVulkanObjectIP11VkSampler_TXadL_Z16vkDestroySamplerEEE
16CSwapChainVulkan
17CShaderVulkanBase
19CVertexShaderVulkan
16CInputLayoutDictI18CInputLayoutVulkanE
19CRenderDeviceVulkan
N7glslang7TShader8IncluderE
32CVfxShaderFileRenderShaderBuffer
16CGlslangIncluder
ps_4_0
vs_4_0
ps_5_0
vs_5_0
?VK ERROR %s %llu:%d: %s\n
VK WARNING %s %llu:%d: %s\n
VK PERF %s %llu:%d: %s\n
VK INFO %s %llu:%d: %s\n
VK DEBUG %s %llu:%d: %s\n
no message
none
VK_OBJECT_TYPE_BUFFER
VK_OBJECT_TYPE_BUFFER_VIEW
VK_OBJECT_TYPE_COMMAND_BUFFER
VK_OBJECT_TYPE_COMMAND_POOL
VK_OBJECT_TYPE_DESCRIPTOR_SET
VK_OBJECT_TYPE_DEVICE
VK_OBJECT_TYPE_DEVICE_MEMORY
VK_OBJECT_TYPE_DISPLAY_KHR
VK_OBJECT_TYPE_EVENT
VK_OBJECT_TYPE_FENCE
VK_OBJECT_TYPE_FRAMEBUFFER
VK_OBJECT_TYPE_IMAGE
VK_OBJECT_TYPE_IMAGE_VIEW
VK_OBJECT_TYPE_INSTANCE
VK_OBJECT_TYPE_PIPELINE
VK_OBJECT_TYPE_PIPELINE_CACHE
VK_OBJECT_TYPE_QUERY_POOL
VK_OBJECT_TYPE_QUEUE
VK_OBJECT_TYPE_RENDER_PASS
VK_OBJECT_TYPE_SAMPLER
VK_OBJECT_TYPE_SEMAPHORE
VK_OBJECT_TYPE_SHADER_MODULE
VK_OBJECT_TYPE_SURFACE_KHR
VK_OBJECT_TYPE_SWAPCHAIN_KHR
VK_OBJECT_TYPE_UNKNOWN
Unhandled VkObjectType
VERBOSE : 
INFO : 
WARNING : 
ERROR : 
GENERAL
VALIDATION
\n\tObjects - %d\n
\t\tObject[%d] - %s, Handle %p\n
\n\tCommand Buffer Labels - %d\n
PERFORMANCE
#Vulkan_InitializationFailure
#Vulkan_DisableInstructions
RenderSystem/VulkanOnly
Prefer shader loop unrolling.
r_prefer_loop_unrolling
r_mipgen_compute_shader
RenderDeviceMgr001
VK_LAYER_GOOGLE_threading
libvulkan.so.1
-vulkan_minimal_validation
VK_EXT_debug_utils
VK_EXT_debug_report
-vulkan_enable_gpu_validation
Enabling GPU validation.\n
-vulkan_alloc_callbacks
vkCmdBeginDebugUtilsLabelEXT
vkCmdEndDebugUtilsLabelEXT
vkCmdInsertDebugUtilsLabelEXT
vkQueueEndDebugUtilsLabelEXT
vkSetDebugUtilsObjectNameEXT
vkSetDebugUtilsObjectTagEXT
vkSubmitDebugUtilsMessageEXT
vkDebugReportMessageEXT
VK_KHR_device_group_creation
-vulkan_scene_system_job_cost
vkDestroySurfaceKHR
-vulkan_validation_warnings
VK_LAYER_LUNARG_image
VK_LAYER_LUNARG_swapchain
Error from SDL_GetDisplayMode( %d, %d ) = %s\n
Error from SDL_GetCurrentDisplayMode( %d ) = %s\n
VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
VK_OBJECT_TYPE_DESCRIPTOR_POOL
VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT
VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
VK_OBJECT_TYPE_DISPLAY_MODE_KHR
VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX
VK_OBJECT_TYPE_OBJECT_TABLE_NVX
VK_OBJECT_TYPE_PHYSICAL_DEVICE
VK_OBJECT_TYPE_PIPELINE_LAYOUT
VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
VK %s - Message Id Number: %d | Message Id Name: %s\n\t%s\n
\t\tObject[%d] - %s, Handle %p, Name "%s"\n
\t\tLabel[%d] - %s { %f, %f, %f, %f}\n
Required Vulkan extension "%s" is not supported. Please update your Vulkan driver.\n
#Vulkan_RequiredExtensionMissing
Use compute shader for mipgen.
-vulkan_disable_validation_shaders
VK_VALIDATION_FEATURE_DISABLE_ALL_EXT
VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT
VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT
VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT
VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT
VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT
VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT
Unhandled VkValidationFeatureDisableEXT
Vulkan initialization failed, '%s' likely failed to load.\n
vkEnumerateInstanceLayerProperties( ... , NULL ) failed.\n
vkEnumerateInstanceLayerProperties( ... ) failed.\n
Enabling validation layer: %s.\n
vkEnumerateInstanceExtensionProperties( layerName, ... , NULL ) failed.\n
vkEnumerateInstanceExtensionProperties( layerName, ... ) failed.\n
vkEnumerateInstanceExtensionProperties( NULL, ... , NULL ) failed.\n
vkEnumerateInstanceExtensionProperties( NULL, ... ) failed.\n
Vulkan missing requested extension '%s'.\n
Enabling instance extension: %s.\n
Using '%s' for Vulkan validation reporting.\n
Failed to find instance extension for validation.  '%s' and '%s' not supported.\n
Disabling validation feature: %s\n
vkCreateInstance failed, unable to create instance.\n
Unable to populate vk_ext_khr_swapchain entrypoints.\n
vkCreateDebugUtilsMessengerEXT
vkDestroyDebugUtilsMessengerEXT
vkQueueBeginDebugUtilsLabelEXT
vkQueueInsertDebugUtilsLabelEXT
Unable to populate VK_EXT_debug_utils entrypoints.\n
m_VkEXTDebugUtilsExtension.vkCreateDebugUtilsMessengerEXT( m_InstanceVulkan, &debugUtilsMessengerCreateInfo, nullptr, &m_pDebugUtilsMessengerVulkan )
vkCreateDebugReportCallbackEXT
vkDestroyDebugReportCallbackEXT
Unable to populate VK_EXT_debug_report entrypoints.\n
vkCreateDebugReportCallbackEXT was unsuccessful.\n
VK_KHR_get_physical_device_properties2
Missing entrypoints for instance extension '%s', disabling.\n
vkEnumeratePhysicalDevices failed, unable to init and enumerate GPUs with Vulkan.\n
vkEnumeratePhysicalDeviceGroupsKHR: no physical device groups supported.  Using single GPU.\n
vkEnumeratePhysicalDevices failed, unable to enumerate GPUs with Vulkan.\n
Unable to determine texture heap size, assuming %llu MB.\n
Using VK_EXT_memory_budget set texture memory budget to %llu MB.\n
RenderSystem/VulkanUseTransformConstantBuffer
Vulkan physical device (%d): using transform constant buffer: %s\n
Vulkan physical device (%d): supports shader clip distance: %s\n
RenderSystem/VulkanSceneSystemJobCost
RenderSystem/VulkanUseSecondaryCommandBuffers
-vulkan_disable_secondary_command_buffers
Vulkan physical device (%d): using secondary command buffers: %s\n
vkGetPhysicalDeviceSurfaceSupportKHR
vkGetPhysicalDeviceSurfaceCapabilitiesKHR
vkGetPhysicalDeviceSurfaceFormatsKHR
vkGetPhysicalDeviceSurfacePresentModesKHR
vkGetPhysicalDeviceFeatures2KHR
vkGetPhysicalDeviceProperties2KHR
vkGetPhysicalDeviceFormatProperties2KHR
vkGetPhysicalDeviceImageFormatProperties2KHR
vkGetPhysicalDeviceQueueFamilyProperties2KHR
vkGetPhysicalDeviceMemoryProperties2KHR
vkGetPhysicalDeviceSparseImageFormatProperties2KHR
vkEnumeratePhysicalDeviceGroupsKHR
-vulkan_disable_validation_thread_safety
-vulkan_disable_validation_api_parameters
-vulkan_disable_validation_object_lifetimes
-vulkan_disable_validation_core_checks
-vulkan_disable_validation_unique_handles
VK_LAYER_LUNARG_parameter_validation
VK_LAYER_LUNARG_core_validation
22CRenderDeviceMgrVulkan
vulkan/renderpassvulkan.cpp
Failed to create renderpass.\n
Subpass %d color attachment %d not found in renderpass attachment list.
Subpass %d input attachment %d not found in renderpass attachment list.
Subpass %d preserve attachment %d not found in renderpass attachment list.
vkCreateFramebuffer( m_pDeviceVulkan, &framebufferCreateInfo, NULL, &pFramebuffer )
Failed to get swapchain from texture, renderpass will be missing swapchain per-color texture info.\n
vkCreateFramebuffer( m_pDeviceVulkan, &framebufferCreateInfo, NULL, &pSwapChainFramebuffer )
NewNode
17CRenderPassVulkan
24CRenderPassManagerVulkan
Present
vkMapMemory( m_pDeviceVulkan, pQuery->m_pQueryPool->m_pResultsMem, nResultOffset, nResultSize, 0, &pMappedBuffer )
vulkan/renderpipelinestatsvulkan.cpp
vkCreateQueryPool( m_pDeviceVulkan, &queryPoolCreateInfo, NULL, &pQueryPoolVulkan )
Failed to allocate buffer memory for query results to be written to.\n
Experimental: Set to 1 to enable full GPU pipeline flushing after each present.
r_pipeline_stats_present_flush
Experimental: Set to 1 to enable full GPU pipeline flushing after each command list.
r_pipeline_stats_command_flush
Workaround AMD bug where vkCmdPipelineBarrier is needed prior to vkCmdResetQueryPool.
vulkan_amd_timestamp_workaround
Found %d checkpoints.\n
-lunarg_no_present_fence
vulkan/renderthreadvulkan.cpp
vr_explicit_timing_mode
vulkan_additional_semaphores
rs_submit_twice
vulkan_batch_submits
vulkan_batch_size
vr_multigpu_skip_transfers
vr_multigpu_skip_semaphores
readpixels_staging_mem
vulkan_peer2peer_mgpu.vtex
Checking for VK_NV_device_diagnostic_checkpoints indicating queue failure...\n
VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
Checkpoint data: '%s' at pipeline stage %s\n
vkCreateQueryPool( VulkanDevice(), &queryPoolCreateInfo, NULL, &m_pVrTimestampQueryPool )
vkResetCommandBuffer( pCommandBuffer, 0 )
vkBeginCommandBuffer( pCommandBuffer, &beginInfo )
vkEndCommandBuffer( pCommandBuffer )
vkCreateSemaphore( VulkanDevice(), &semaphoreCreateInfo, NULL, &pSemaphore )
FrameSync() - bailing out of vkWaitForFences( fenceCount = %d ) after %f seconds, error = %s\n
vkResetCommandBuffer( pResetQueriesCommandBuffer, 0 )
vkBeginCommandBuffer( pResetQueriesCommandBuffer, &beginInfo )
vkEndCommandBuffer( pResetQueriesCommandBuffer )
Bailing out of OnBlockForQuery after %.3f seconds\n
VR explicit timing mode for Vulkan
vulkan/renderthreadvulkan.cpp(194): Error! NULL texture pointer sent to OnReadPixels()!\n
Aboring OnReadPixels because of GPU memory allocation failure.\n
vkResetCommandBuffer( m_pCmdBuffer, 0 )
vkBeginCommandBuffer( m_pCmdBuffer, &beginInfo )
vulkan_readpixels_resolve.vtex
CRenderThreadVulkan::OnReadPixels not supported for MSAA depth.  Requires shader-based MSAA depth resolve to be implemented.\n
vkEndCommandBuffer( m_pCmdBuffer )
vkQueueSubmit( VulkanQueue(), 1, &submitInfo, VK_NULL_HANDLE )
vkMapMemory( VulkanDevice(), pStagingMemory, 0, nStagingMemSize, 0, &pLockedData )
vkCreateFence( VulkanDevice(), &fenceCreateInfo, NULL, pFence->GetPtr() )
Waited for left eye command buffers to finish for 250ms, trying again.  Likely a GPU hang.\n
vkQueueSubmit( pQueue, 1, &submitInfo, pFence->Get() )
vkCreateFence( VulkanDevice(), &fenceCreateInfo, NULL, &presentFence.m_pFence )
vkQueuePresentKHR failed with error %d\n
vkQueueSubmit( VulkanQueue(), 1, &submitInfo, presentFence.m_pFence )
vkCreateFence( VulkanDevice(), &fenceCreateInfo, NULL, &m_pWaitForLeftEyeFenceAMD )
vkQueueSubmit( VulkanQueue(), 1, &submitInfo, m_pWaitForLeftEyeFenceAMD )
OnMultiGpuTransferTexture: No texture specification for destination texture, skipping transfer.\n
vkCreateSemaphore( VulkanDevice(), &semaphoreCreateInfo, NULL, &m_pMultiGpuTransferSemaphores[ nTransfer ] )
Reject swapchain blit request to swapchain that is no longer valid.\n
AllocInternal
AllocInternal
AllocInternal
19CRenderThreadVulkan
13CVulkanObjectIP9VkFence_TXadL_Z14vkDestroyFenceEEE
(knN
zd?Total Shader Stored: %.2fMB\n
validation.cache
vulkan_shader_table_print
vulkan/shadertablevulkan.cpp
Total Shader Requested: %.2fMB\n
Total Shader Modules Stored: %.2fMB\n
Total Shader Modules Requested: %.2fMB\n
Unable to write validation shader cache %s file.\n
Prints out stats for the Vulkan shader table
Failed to open validation shader cache %s, might not exit yet.\n
vkCreateValidationCacheEXT returned error %s.\n
vkCreateShaderModule( VulkanDevice(), pShaderModuleCreateInfo, nullptr, &pShaderModule )
AcquireVfxShaderFile: Failed to unserialize CVfxShaderFile.  Is your shadercache out-of-date?  Try deleting it.\n
AcquireVfxShaderFile: Failed to unserialize CVfxShaderFileVulkan.  Is your shadercache out-of-date?  Try deleting it.\n
AllocInternal
AllocInternal
25CConCommandMemberAccessorI18CShaderTableVulkanE
18CShaderTableVulkan
TEXTURESTREAMING: Resource view ptr or texture resources are still NULL after waiting.\n
TEXMAN: %s LoadStreamingData (%s)\n
Vulkan texture manager frame update
TEXMAN: CTextureManagerVulkan::LoadStreamingData MarkTextureBitsLoadRequired (%s)\n
vkCreateImageView( VulkanDevice(), &imageViewCreateInfo, NULL, m_ImageViews.m_ppPerMipLevelImageView[ i ]->GetPtr() )
vkCreateImageView( VulkanDevice(), &imageViewCreateInfoSrgb, NULL, m_ImageViews.m_ppPerMipLevelImageViewSrgb[ i ]->GetPtr())
vkCreateImageView( VulkanDevice(), &imageViewCreateInfo, NULL, m_ImageViews.m_pImageView->GetPtr() )
vkCreateImageView( VulkanDevice(), &cubeAsArrayImageViewCreateInfo, NULL, m_ImageViews.m_pCubeAsArrayImageView->GetPtr() )
vkCreateImageView( VulkanDevice(), &imageViewCreateInfoSrgb, NULL, m_ImageViews.m_pImageViewSrgb->GetPtr() )
vkCreateImageView( VulkanDevice(), &cubeAsArrayImageViewCreateInfoSrgb, NULL, m_ImageViews.m_pCubeAsArrayImageViewSrgb->GetPtr() )
vkCreateImageView( VulkanDevice(), &dsViewCreateInfo, NULL, m_ImageViews.m_pDepthStencilView->GetPtr() )
vkCreateImageView( VulkanDevice(), &dsViewCreateInfo, NULL, m_ImageViews.m_ppPerArraySliceDepthStencilView[i]->GetPtr() )
vkCreateImageView( VulkanDevice(), &colorTargetViewCreateInfo, NULL, m_ImageViews.m_ppColorTargetView[ i ]->GetPtr() )
vkCreateImageView( VulkanDevice(), &colorTargetViewCreateInfo, NULL, m_ImageViews.m_ppPerArraySliceColorTargetView[ i ]->GetPtr() )
vkCreateImageView( VulkanDevice(), &colorTargetViewCreateInfo, NULL, m_ImageViews.m_ppColorTargetViewSrgb[ i ]->GetPtr() )
vkCreateImageView( VulkanDevice(), &colorTargetViewCreateInfo, NULL, m_ImageViews.m_ppPerArraySliceColorTargetViewSrgb[ i ]->GetPtr() )
vkBindImageMemory( VulkanDevice(), pVulkanImage->m_pImage, pVulkanImage->m_pGPUMemory, pVulkanImage->m_nOffset )
VulkanKhrBindMemory2Extension()->vkBindImageMemory2KHR( VulkanDevice(), 1, &bindImageMemoryInfo )
vkCreateImage( VulkanDevice(), &imageCreateInfo, NULL, &m_pVulkanImage->m_pImage )
vkBindImageMemory( VulkanDevice(), m_pVulkanImage->m_pImage, m_pVulkanImage->m_pGPUMemory, m_pVulkanImage->m_nOffset )
vkCreateImageView( VulkanDevice(), &imageViewCreateInfo, NULL, m_pImageView->GetPtr() )
vkCreateImageView( VulkanDevice(), &imageViewCreateInfo, NULL, m_pImageViewSrgb->GetPtr() )
CTextureManagerVulkan::ComputeTextureObject: Tried to create a depth-stencil texture which is *not* a render target!\n
vkCreateImage( VulkanDevice(), &imageCreateInfo, NULL, &pVulkanImage->m_pImage )
vulkan/texturevulkan.cpp(1443): 
UpdateExternalTexture called on unknown external texture '%s'\n
Trying to create a render target with invalid image format %s\n
CRenderDeviceVulkan::RebakeStaticDescriptorSetsReferencingTexture - could not allocate descriptor in new pool.\n
Size (in KBs) above which textures should be allocated in dedicated memory (NV-only).
vulkan_dedicated_allocation_threshold
-vulkan_depth_texture_as_r32f
-vulkan_disable_pool_textures
SwapChainTexture.vtex
LoadStreamingData
NewNode
14CTextureVulkan
21CTextureManagerVulkan
13CVulkanObjectIP13VkImageView_TXadL_Z18vkDestroyImageViewEEE
24CTextureManagerVulkanNew
vkCreateBufferView( m_pDeviceVulkan, &bufferViewCreateInfo, NULL, &m_pTexelBufferView )
*** VB "%s": Tried to lock twice without an unlock!\n
*** VB "%s": Tried to lock too much memory (%d>%d)!\n
*** VB "%s": Tried to lock a GPU-only buffer!\n
*** VB "%s": Tried to lock a static buffer twice!\n
*** VB "%s": Tried to lock too much memory for subregion (%d>%d)!\n
19CVertexBufferVulkan
vkAllocateCommandBuffers
vkAllocateDescriptorSets
vkBeginCommandBuffer
vkBindBufferMemory
vkBindImageMemory
vkCmdBeginQuery
vkCmdBeginRenderPass
vkCmdBindDescriptorSets
vkCmdBindIndexBuffer
vkCmdBindPipeline
vkCmdBindVertexBuffers
vkCmdBlitImage
vkCmdClearAttachments
vkCmdClearColorImage
vkCmdClearDepthStencilImage
vkCmdCopyBuffer
vkCmdCopyBufferToImage
vkCmdCopyImage
vkCmdCopyImageToBuffer
vkCmdCopyQueryPoolResults
vkCmdDispatch
vkCmdDispatchIndirect
vkCmdDraw
vkCmdDrawIndexed
vkCmdDrawIndexedIndirect
vkCmdDrawIndirect
vkCmdEndQuery
vkCmdEndRenderPass
vkCmdExecuteCommands
vkCmdFillBuffer
vkCmdNextSubpass
vkCmdPipelineBarrier
vkCmdPushConstants
vkCmdResetEvent
vkCmdResetQueryPool
vkCmdResolveImage
vkCmdSetBlendConstants
vkCmdSetDepthBias
vkCmdSetDepthBounds
vkCmdSetEvent
vkCmdSetLineWidth
vkCmdSetScissor
vkCmdSetStencilCompareMask
vkCmdSetStencilReference
vkCmdSetStencilWriteMask
vkCmdSetViewport
vkCmdUpdateBuffer
vkCmdWaitEvents
vkCmdWriteTimestamp
vkCreateBuffer
vkCreateBufferView
vkCreateCommandPool
vkCreateComputePipelines
vkCreateDescriptorPool
vkCreateDescriptorSetLayout
vkCreateEvent
vkCreateFence
vkCreateFramebuffer
vkCreateGraphicsPipelines
vkCreateImage
vkCreateImageView
vkCreatePipelineCache
vkCreatePipelineLayout
vkCreateQueryPool
vkCreateRenderPass
vkCreateSampler
vkCreateSemaphore
vkCreateShaderModule
vkDestroyBuffer
vkDestroyBufferView
vkDestroyCommandPool
vkDestroyDescriptorPool
vkDestroyDescriptorSetLayout
vkDestroyDevice
vkDestroyEvent
vkDestroyFence
vkDestroyFramebuffer
vkDestroyImage
vkDestroyImageView
vkDestroyPipeline
vkDestroyPipelineCache
vkDestroyPipelineLayout
vkDestroyQueryPool
vkDestroyRenderPass
vkDestroySampler
vkDestroySemaphore
vkDestroyShaderModule
vkDeviceWaitIdle
vkEndCommandBuffer
vkFlushMappedMemoryRanges
vkFreeCommandBuffers
vkFreeDescriptorSets
vkFreeMemory
vkGetBufferMemoryRequirements
vkGetDeviceMemoryCommitment
vkGetDeviceQueue
vkGetEventStatus
vkGetFenceStatus
vkGetImageMemoryRequirements
vkGetImageSubresourceLayout
vkGetPipelineCacheData
vkGetQueryPoolResults
vkGetRenderAreaGranularity
vkMapMemory
vkMergePipelineCaches
vkQueueBindSparse
vkQueueSubmit
vkQueueWaitIdle
vkResetCommandBuffer
vkResetCommandPool
vkResetDescriptorPool
vkResetEvent
vkResetFences
vkSetEvent
vkUnmapMemory
vkUpdateDescriptorSets
vkWaitForFences
vkBindBufferMemory2
vkBindImageMemory2
vkCmdDispatchBase
vkCmdSetDeviceMask
vkGetDeviceQueue2
vkGetImageMemoryRequirements2
vkTrimCommandPool
vkCmdWriteBufferMarkerAMD
vkCmdDrawIndirectCountAMD
vkGetShaderInfoAMD
vkGetCalibratedTimestampsEXT
vkCmdSetDiscardRectangleEXT
vkDisplayPowerControlEXT
vkGetSwapchainCounterEXT
vkRegisterDeviceEventEXT
vkRegisterDisplayEventEXT
vkSetHdrMetadataEXT
vkCmdSetSampleLocationsEXT
vkCmdBeginQueryIndexedEXT
vkCmdDrawIndirectByteCountEXT
vkCmdEndQueryIndexedEXT
vkCmdEndTransformFeedbackEXT
vkCmdBeginRenderPass2KHR
vkCmdEndRenderPass2KHR
vkCmdNextSubpass2KHR
vkCreateRenderPass2KHR
vkCreateSharedSwapchainsKHR
vkCmdDrawIndirectCountKHR
vkGetFenceFdKHR
vkImportFenceFdKHR
vkGetMemoryFdKHR
vkGetMemoryFdPropertiesKHR
vkGetSemaphoreFdKHR
vkImportSemaphoreFdKHR
vkTrimCommandPoolKHR
vkCmdPushDescriptorSetKHR
vkGetSwapchainStatusKHR
vkCmdProcessCommandsNVX
vkCreateObjectTableNVX
vkDestroyObjectTableNVX
vkRegisterObjectsNVX
vkUnregisterObjectsNVX
vkCmdSetViewportWScalingNV
vkCmdDrawMeshTasksIndirectNV
vkCmdDrawMeshTasksNV
vkCmdTraceRaysNV
vkCompileDeferredNV
vkCreateRayTracingPipelinesNV
vkCmdSetExclusiveScissorNV
vkCmdBindShadingRateImageNV
vkCmdSetCoarseSampleOrderNV
vkCreateInstance
vkEnumerateInstanceVersion
vkGetInstanceProcAddr
vkCreateDevice
vkDestroyInstance
vkEnumeratePhysicalDevices
vkGetDeviceProcAddr
vkGetPhysicalDeviceFeatures
vkGetPhysicalDeviceProperties
vkGetPhysicalDeviceFeatures2
vkReleaseDisplayEXT
vkCreateDisplayModeKHR
vkGetDisplayModePropertiesKHR
vkCreateXcbSurfaceKHR
vkGetImageSparseMemoryRequirements
vkInvalidateMappedMemoryRanges
vkCreateDescriptorUpdateTemplate
vkCreateSamplerYcbcrConversion
vkDestroyDescriptorUpdateTemplate
vkDestroySamplerYcbcrConversion
vkGetBufferMemoryRequirements2
vkGetDescriptorSetLayoutSupport
vkGetDeviceGroupPeerMemoryFeatures
vkGetImageSparseMemoryRequirements2
vkUpdateDescriptorSetWithTemplate
vkCmdDrawIndexedIndirectCountAMD
vkCmdBeginConditionalRenderingEXT
vkCmdEndConditionalRenderingEXT
vkGetMemoryHostPointerPropertiesEXT
vkGetImageDrmFormatModifierPropertiesEXT
vkCmdBeginTransformFeedbackEXT
vkCmdBindTransformFeedbackBuffersEXT
vkGetPastPresentationTimingGOOGLE
vkGetRefreshCycleDurationGOOGLE
vkCmdDrawIndexedIndirectCountKHR
vkGetBufferMemoryRequirements2KHR
vkGetImageMemoryRequirements2KHR
vkGetImageSparseMemoryRequirements2KHR
vkGetDescriptorSetLayoutSupportKHR
vkCreateSamplerYcbcrConversionKHR
vkDestroySamplerYcbcrConversionKHR
vkCmdReserveSpaceForCommandsNVX
vkCreateIndirectCommandsLayoutNVX
vkDestroyIndirectCommandsLayoutNVX
vkCmdDrawMeshTasksIndirectCountNV
vkBindAccelerationStructureMemoryNV
vkCmdBuildAccelerationStructureNV
vkCmdCopyAccelerationStructureNV
vkCmdWriteAccelerationStructuresPropertiesNV
vkCreateAccelerationStructureNV
vkDestroyAccelerationStructureNV
vkGetAccelerationStructureHandleNV
vkGetAccelerationStructureMemoryRequirementsNV
vkGetRayTracingShaderGroupHandlesNV
vkCmdSetViewportShadingRatePaletteNV
vkCmdPushDescriptorSetWithTemplateKHR
vkEnumerateInstanceExtensionProperties
vkEnumerateInstanceLayerProperties
vkEnumerateDeviceExtensionProperties
vkEnumerateDeviceLayerProperties
vkGetPhysicalDeviceFormatProperties
vkGetPhysicalDeviceImageFormatProperties
vkGetPhysicalDeviceMemoryProperties
vkGetPhysicalDeviceQueueFamilyProperties
vkGetPhysicalDeviceSparseImageFormatProperties
vkEnumeratePhysicalDeviceGroups
vkGetPhysicalDeviceExternalBufferProperties
vkGetPhysicalDeviceExternalFenceProperties
vkGetPhysicalDeviceExternalSemaphoreProperties
vkGetPhysicalDeviceFormatProperties2
vkGetPhysicalDeviceImageFormatProperties2
vkGetPhysicalDeviceMemoryProperties2
vkGetPhysicalDeviceProperties2
vkGetPhysicalDeviceQueueFamilyProperties2
vkGetPhysicalDeviceSparseImageFormatProperties2
vkGetPhysicalDeviceCalibrateableTimeDomainsEXT
vkGetPhysicalDeviceSurfaceCapabilities2EXT
vkGetPhysicalDeviceMultisamplePropertiesEXT
vkCreateDisplayPlaneSurfaceKHR
vkGetDisplayPlaneCapabilitiesKHR
vkGetDisplayPlaneSupportedDisplaysKHR
vkGetPhysicalDeviceDisplayPlanePropertiesKHR
vkGetPhysicalDeviceDisplayPropertiesKHR
vkGetPhysicalDeviceExternalFencePropertiesKHR
vkGetPhysicalDeviceExternalBufferPropertiesKHR
vkGetPhysicalDeviceExternalSemaphorePropertiesKHR
vkGetDisplayModeProperties2KHR
vkGetDisplayPlaneCapabilities2KHR
vkGetPhysicalDeviceDisplayPlaneProperties2KHR
vkGetPhysicalDeviceDisplayProperties2KHR
vkGetPhysicalDeviceSurfaceCapabilities2KHR
vkGetPhysicalDeviceSurfaceFormats2KHR
vkGetPhysicalDeviceXcbPresentationSupportKHR
vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX
vkGetPhysicalDeviceExternalImageFormatPropertiesNV
VectorAligned
Vector2D
Vector4D
QAngle
Quaternion
RadianEuler
DegreeEuler
VMatrix
matrix3x4_t
matrix3x4a_t
CTransform
CUtlSymbolLarge
CUtlString
CUtlSymbol
CUtlStringToken
fltx4
CEntityIndex
CResourceString
SheetSequenceFrame_t
CResourceArray
SequenceFloatParam_t
SheetFrameImage_t
SheetSequence_t
RenderSlotType_t
VsInputSignatureElement_t
CUtlVector
rnd_down
rnd_up
MNetworkOverride_Invalid
MNetworkSerializer
MNetworkEncoder
MNetworkChangeCallback
MNetworkBitCount
MNetworkUserGroup
MNetworkPriority
MNetworkRemoveAll
ChangeCallbackOnChange
NETWORK_FIELD_LOWEST_PRIORITY
28ISchemaCollectionManipulator
19CSchemaRegistration
38CSchemaRegistration_rendersystemvulkan
27CSchemaUtlVectorManipulatorI10CUtlVectorI25VsInputSignatureElement_t10CUtlMemoryIS1_iEES1_E
CubeMapFace_t
CUBEMAP_FACE_POSITIVE_X
CUBEMAP_FACE_NEGATIVE_X
CUBEMAP_FACE_POSITIVE_Y
CUBEMAP_FACE_NEGATIVE_Y
CUBEMAP_FACE_POSITIVE_Z
CUBEMAP_FACE_NEGATIVE_Z
TextureSpecificationFlags_t
TSPEC_FLAGS
TSPEC_RENDER_TARGET
TSPEC_VERTEX_TEXTURE
TSPEC_UNFILTERABLE_OK
TSPEC_SUGGEST_CLAMPS
TSPEC_SUGGEST_CLAMPT
TSPEC_SUGGEST_CLAMPU
TSPEC_NO_LOD
TSPEC_CUBE_TEXTURE
TSPEC_VOLUME_TEXTURE
TSPEC_TEXTURE_ARRAY
TSPEC_TEXTURE_GEN_MIP_MAPS
TSPEC_LINE_TEXTURE_360
TSPEC_LINEAR_ADDRESSING_360
TSPEC_USE_TYPED_IMAGEFORMAT
TSPEC_SHARED_RESOURCE
TSPEC_UAV
TSPEC_INPUT_ATTACHMENT
TSPEC_LINEAR_COLOR_SPACE
TSPEC_RENDER_TARGET_SAMPLEABLE
TSPEC_CUBE_CAN_SAMPLE_AS_ARRAY
Sheet_t
m_Sequences
uvCropped
uvUncropped
m_flDisplayTime
m_Images
m_nId
m_bClamp
m_bAlphaCrop
m_bNoColor
m_bNoAlpha
m_Frames
m_flTotalTime
m_floatParams
m_value
VsInputSignature_t
m_elems
m_pName
m_pSemantic
m_pD3DSemanticName
m_nD3DSemanticIndex
RenderInputLayoutField_t
m_pSemanticName
m_nSemanticIndex
m_Format
m_nOffset
m_nSlot
m_nSlotType
m_nInstanceStepRate
RenderMultisampleType_t
RENDER_MULTISAMPLE_TYPE_COUNT
InputLayoutVariation_t
INPUT_LAYOUT_VARIATION_MAX
RenderPrimitiveType_t
RENDER_PRIM_POINTS
RENDER_PRIM_LINES
RENDER_PRIM_LINE_STRIP
RENDER_PRIM_TRIANGLES
RENDER_PRIM_TRIANGLE_STRIP
RENDER_PRIM_INSTANCED_QUADS
RENDER_PRIM_HETEROGENOUS
RENDER_PRIM_COMPUTE_SHADER
RENDER_PRIM_TYPE_COUNT
RenderBufferFlags_t
RENDER_BUFFER_UAV_COUNTER
RENDER_SLOT_INVALID
RENDER_SLOT_PER_VERTEX
RENDER_SLOT_PER_INSTANCE
INPUT_LAYOUT_VARIATION_DEFAULT
INPUT_LAYOUT_VARIATION_STREAM1_MAT3X4
INPUT_LAYOUT_VARIATION_STREAM1_INSTANCEID
INPUT_LAYOUT_VARIATION_STREAM1_INSTANCEID_LIGHTMAP_PARAMS
INPUT_LAYOUT_VARIATION_STREAM1_INSTANCEID_MORPH_VERT_ID
RENDER_PRIM_LINES_WITH_ADJACENCY
RENDER_PRIM_LINE_STRIP_WITH_ADJACENCY
RENDER_PRIM_TRIANGLES_WITH_ADJACENCY
RENDER_PRIM_TRIANGLE_STRIP_WITH_ADJACENCY
RENDER_PRIM_1_CONTROL_POINT_PATCHLIST
RENDER_PRIM_2_CONTROL_POINT_PATCHLIST
RENDER_PRIM_3_CONTROL_POINT_PATCHLIST
RENDER_PRIM_4_CONTROL_POINT_PATCHLIST
RENDER_PRIM_5_CONTROL_POINT_PATCHLIST
RENDER_PRIM_6_CONTROL_POINT_PATCHLIST
RENDER_PRIM_7_CONTROL_POINT_PATCHLIST
RENDER_PRIM_8_CONTROL_POINT_PATCHLIST
RENDER_PRIM_9_CONTROL_POINT_PATCHLIST
RENDER_PRIM_10_CONTROL_POINT_PATCHLIST
RENDER_PRIM_11_CONTROL_POINT_PATCHLIST
RENDER_PRIM_12_CONTROL_POINT_PATCHLIST
RENDER_PRIM_13_CONTROL_POINT_PATCHLIST
RENDER_PRIM_14_CONTROL_POINT_PATCHLIST
RENDER_PRIM_15_CONTROL_POINT_PATCHLIST
RENDER_PRIM_16_CONTROL_POINT_PATCHLIST
RENDER_PRIM_17_CONTROL_POINT_PATCHLIST
RENDER_PRIM_18_CONTROL_POINT_PATCHLIST
RENDER_PRIM_19_CONTROL_POINT_PATCHLIST
RENDER_PRIM_20_CONTROL_POINT_PATCHLIST
RENDER_PRIM_21_CONTROL_POINT_PATCHLIST
RENDER_PRIM_22_CONTROL_POINT_PATCHLIST
RENDER_PRIM_23_CONTROL_POINT_PATCHLIST
RENDER_PRIM_24_CONTROL_POINT_PATCHLIST
RENDER_PRIM_25_CONTROL_POINT_PATCHLIST
RENDER_PRIM_26_CONTROL_POINT_PATCHLIST
RENDER_PRIM_27_CONTROL_POINT_PATCHLIST
RENDER_PRIM_28_CONTROL_POINT_PATCHLIST
RENDER_PRIM_29_CONTROL_POINT_PATCHLIST
RENDER_PRIM_30_CONTROL_POINT_PATCHLIST
RENDER_PRIM_31_CONTROL_POINT_PATCHLIST
RENDER_PRIM_32_CONTROL_POINT_PATCHLIST
RENDER_BUFFER_USAGE_VERTEX_BUFFER
RENDER_BUFFER_USAGE_INDEX_BUFFER
RENDER_BUFFER_USAGE_SHADER_RESOURCE
RENDER_BUFFER_USAGE_UNORDERED_ACCESS
RENDER_BUFFER_BYTEADDRESS_BUFFER
RENDER_BUFFER_STRUCTURED_BUFFER
RENDER_BUFFER_APPEND_CONSUME_BUFFER
librendersystemvulkan.so
configvalue.cpp
RegisterConfigValue: Unknown error constructing config value "%s"!\n
HookUpConfigValue
{}()':
%i %i %i %i
FCVAR_NEVER_AS_STRING
"%s" = "%s"
 ( def. "%s" )
 min. %f
 max. %f
"%s" 
%-120s - %s\n
%-120s\n
<deferred>
<no deferred ref found>
<unconnected>
<null>
%s%d
game
client
notify
singleplayer
notconnected
cheat
replicated
server_can_execute
clientcmd_can_execute
user
ss_added
CCommand::Tokenize: Encountered command which overflows the tokenizer buffer.. Skipping!\n
CCommand::Tokenize: Encountered command which overflows the argument buffer.. Clamped!\n
Warning:  %s = '%s' is infinite, clamping value.\n
Access of unconnected SplitScreenConVarRef\n
 [%.3f server clamped to %.3f]
InstallChangeCallback called with NULL callback, ignoring!!!\n
InstallChangeCallback ignoring duplicate change callback!!!\n
ConVar(%s) defined with infinite float value (%s)\n
Invalid access of deferred ConVarRef for '%s'\n
Access of unconnected ConVarRef\n
ConVarRef %s doesn't point to an existing ConVar\n
7IConVar
23IConCommandBaseAccessor
14ConCommandBase
10ConCommand
6ConVar
16CDefaultAccessor
18CPlaceholderConVar
<< NULL >>\n
developer
"\t\t"
0x%016llX
%lld
%f %f %f %f
0x%p
%llu
%s, 
(*%s*), 
 ReadToken overflow
<NULL>
#include
#include is NULL 
#base
#base is NULL 
int( %d = 0x%X )
float( %f )
ptr( 0x%p )
%ls [wstring, len = %d]
u64( %lld = 0x%llX )
#int#
#empty#
update
delete
borrow
keyvalues.cpp
KeyValues::RecursiveSaveToFile: TODO, missing code for TYPE_COLOR.\n
KeyValues::SaveToFile: couldn't open file "%s" in path "%s".\n
JSON error, unterminated element: 
KeyValues Error: %s in file %s\n
KV Conditional Evaluation Error
RecursiveLoadFromBuffer:  recursion overflow
RecursiveLoadFromBuffer:  got EOF instead of keyname
RecursiveLoadFromBuffer:  got empty keyname
RecursiveLoadFromBuffer:  got NULL key
RecursiveLoadFromBuffer:  got } in key
RecursiveLoadFromBuffer:  got conditional between key and value
LoadFromBuffer: expected '{', found '%s'
KeyValues::ParseIncludedKeys: Couldn't load included keyvalue file %s\n
19IKeyValuesErrorSpew
26CDefaultKeyValuesErrorSpew
8CFmtStrNILi256ELb0EE
mempool.cpp
CUtlMemoryPoolBase: Cannot specify 0 elements to grow each time!\n
NewNode
CUtlMemoryPoolBase
unknown
CMemoryStack %s\n
ATTEMPTED TO DECOMMIT OWNED MEMORY STACK SPACE\n
    Total used memory:      %d KB\n
    Total committed memory: %d KB\n
    Max committed memory: %u KB out of %d KB\n
utlbuffer.cpp
CUtlBuffer::VaPrintf: String overflowed buffer [%llu]\n
VaPrintf
utlstring.cpp
%s: string format requested %d chars\n
FormatV
WIN32
WINDOWS
X360
LINUX
POSIX
WINXP
GAMECONSOLE
DEMO
LOWVIOLENCE
HIGHDPI
Conditional Error: %s\n
Bad expression token: %c
Logic Error in CExpressionEvaluator
Bad expression operator: '%c%c', expected C style boolean expression operator.
Bad expression syntax: '%s', expected a single matching pair of enclosing braces.
VApplication001
interfaces.cpp
VEngineCvar007
VStringTokenSystem001
TestScriptMgr001
VProcessUtils002
Physics2 Interface Old v0.5
VBaseFileSystem011
VFileSystem017
ResourceManifestRegistry001
ResourceHandleUtils001
SchemaSystem_001
ResourceCompilerSystem001
VMaterialSystem2_001
PostProcessingSystem_001
InputSystemVersion001
InputStackSystemVersion001
SoundSystem001
SoundOpSystemEdit001
SoundOpSystem001
SteamAudio001
DebugTextureInfo001
VBAllocTracker001
COLORCORRECTION_VERSION_1
VP4003
VMDLLIB001
QueuedLoaderVersion001
VGUI_ivgui008
VGUI_Input005
VGUI_Panel010
VGUI_Surface032
VGUI_Scheme010
VGUI_System010
VMediaFoundation001
VAvi001
VBik001
IQuickTime001
MeshSystem001
MeshUtils001
VRenderDeviceSetupV001
SceneSystem_002
SceneUtils_001
WorldRendererMgr001
RenderSystemSurface001
AssetSystem001
AssetSystemTest001
ParticleSystemMgr003
VScriptManager010
ToolScriptManager001
PropertyEditorSystem_001
MATCHFRAMEWORK_001
PanoramaUIEngine001
PanoramaUIClient001
PanoramaTextServices001
ToolFramework2_002
WorldRendererBuilderMgr001
PhysicsBuilderMgr001
VisBuilder_001
EnvironmentMapBuilder_001
BakedLODBuilderMgr001
DotaCardGameClient_001
HelpSystem_001
ToolSceneNodeFactory_001
EconItemToolModel_001
ToolGameSimulationSystem_001
SchemaTestExternal_Two_001
SchemaTestExternal_One_001
AnimationSystem_001
AnimationSystemUtils_001
HammerMapLoader001
MaterialUtils_001
FontManager_001
TextLayout_001
AssetPreviewSystem_001
AssetBrowserSystem_001
VConComm001
NetworkSystemVersion001
NetworkSystemUtilsVersion001
NetworkMessagesVersion001
SerializedEntitiesVersion001
Source2Client002
Source2ClientUI001
Source2ClientPrediction001
Source2Server001
Source2ServerSerializers002
Source2Host001
Source2GameClients001
Source2GameEntities001
EngineServiceMgr001
HostStateMgr001
NetworkService_001
NetworkClientService_001
NetworkP2PService_001
NetworkServerService_001
TextMessageMgr_001
ToolService_001
RenderService_001
StatsService_001
UserInfoChangeService_001
VProfService_001
InputService_001
MapListService_001
GameUIService_001
SoundService_001
BenchmarkService001
VDebugService_001
KeyValueCache001
GameResourceServiceClientV001
GameResourceServiceServerV001
Source2EngineToClient001
Source2EngineToServer001
VPhysics2_Interface_001
ServerUploadGameStats001
VR_001
WorkshopSetup001
ModelDocUtils001
AnimGraphEditorUtils001
APPSYSTEM: In ConnectInterfaces(), s_nRegistrationCount is %d!\n
VPhysX Interface ResourceMgr v0.1
ToolGameSimulationDispatcher_001
MODEL_PROCESSING_SERVICES_INTERFACE_001
FlattenedSerializersVersion001
Source2EngineToServerStringTable001
Source2EngineToClientStringTable001
VPhysics2_Handle_Interface_001
MODEL_PROCESSING_SCRIPT_INTERFACE_001
EXPORTSYSTEM_INTERFACE_VERSION_001
ConnectInterfaces
20CPostConnectCallback
ParseEXRHeaderFromMemory() failed! Error message: %s\n
LoadEXRImageFromMemory() failed! Error message: %s\n
EXRReadFile() - R channel not found!\n
EXRReadFile() - G channel not found!\n
EXRReadFile() - B channel not found!\n
<PWL
floatbitmap.cpp
R channel not found!\n
G channel not found!\n
B channel not found!\n
Unable to read file %s\n
Pf\n%d %d\n-1.000000\n
PF\n%d %d\n-1.000000\n
%01d
%02d
%03d
%04d
%05d
%06d
.pfm
.psd
.tif
.png
.jpg
.exr
FloatBitMap::QuarterSize
sub%dx%d.tga
submrg%dx%d.tga
after solve err=%f\n
before solve err=%f\n
floatbitmap.cpp(141): Unknown gamma type "%s"!\n
floatbitmap.cpp(338): Conversion not supported yet!\n
floatbitmap.cpp(438): Conversion not supported yet!\n
FloatBitMap_t::LoadFromFloatBitmap: Received improper bitmap size, skipping!\n
FloatBitMap_t::CopyFloatBitmap: Received NULL pointer!\n
BC6h compression not supported on this target (windows only).\n
BC7 compression not supported on this target (windows only).\n
Unsupported ETC image format %d.\n
Non-windows platforms don't support loading of TIFF images\n
Non-windows platforms don't support loading of PNG images\n
Non-windows platforms don't support loading of JPG images\n
ParseEXRHeaderFromMemory failed! Error message: %s\n
LoadEXRImageFromMemory failed! Error message: %s\n
LoadFromInMemoryEXR( %s ) failed.\n
Only DXT1/DXT5 online texture compression supported.\n
FloatBitMap_t::LoadFromBuffer: Received improper buffer size, skipping!\n
FloatBitMap_t::LoadFromBuffer: Unsupported color format, skipping!\n
FloatBitMap_t::WriteToBuffer: Received improper buffer size %s (expecting %s), skipping!\n
floatbitmap.cpp(901): Unsupported color format "%s", skipping!\n
floatbitmap.cpp(2486): Error calling TGALoader::GetInfo( %s )\n
floatbitmap.cpp(2497): Error loading %s\n
floatbitmap.cpp(2520): Error! Unknown file type for %s\n
floatbitmap.cpp(2539): Error! Slice %d format %dx%dx%d Attr(%d) != previous slices of %dx%d Attr(%d) for %s\n
FloatBitMap_t: Error loading %s\n
FloatBitMap::QuarterSizeBlocky
FloatBitMap::DownsampleNiceFiltered
ConvertGammaToLinear
p?RGB565
IA88
RGB888_BLUESCREEN
BGR888_BLUESCREEN
DXT1
DXT3
DXT5
BGR565
BGRA4444
DXT1_ONEBITALPHA
BGRA5551
UV88
UVWQ8888
RGBA16161616F
UVLX8888
R32F
RGB323232F
RGBA32323232F
NV_DST16
NV_DST24
NV_INTZ
NV_RAWZ
ATI_DST16
ATI_DST24
ATI2N
ATI1N
X360_DST16
X360_DST24
X360_DST24F
LINEAR_BGRX8888
LINEAR_RGBA8888
LINEAR_ABGR8888
LINEAR_ARGB8888
LINEAR_BGRA8888
LINEAR_RGB888
LINEAR_BGR888
LINEAR_BGRX5551
LINEAR_I8
LINEAR_RGBA16161616
LE_BGRX8888
LE_BGRA8888
RG1616F
RG3232F
RGBX8888
NV_NULL
RGBA1010102
BGRA1010102
R16F
D15S1
LINEAR_D24S8
D24X8
D24X4S4
D24FS8
D16_SHADOW
D24X8_SHADOW
RGBA16161616_EDRAM
RGBA1010102F_EDRAM
R16F_EXPAND
RG1616F_EXPAND
RGBA16161616F_EXPAND
DXT5_NM
RG1616
RGBA8888_LINEAR
BGRA8888_LINEAR
BGRX8888_LINEAR
RGBX555
BC6H
R32_UINT
R8G8B8_ETC2
R8G8B8A8_ETC2_EAC
R11_EAC
RG11_EAC
RGBA16161616F_EDRAM_RGBA1010102F
RGBA16161616F_EXPAND_EDRAM_RGBA1010102F
RGBA16161616_EDRAM_RGBA16161616
Unsupported PSD color mode!\n
alpha
transparency
sequence number %d too low in sheet file!!!\n
Invalid sequence number %d!!!\n
9.1.15
vector::_M_default_append
vector::_M_emplace_back_aux
vector::_M_range_insert
chlist
channels
compression
box2i
dataWindow
displayWindow
lineOrder
pixelAspectRatio
screenWindowCenter
screenWindowWidth
Output memory size is zero
Cannot write a file
Failed to read attribute.\n
tiles
Unknown compression type.
# of channels is zero.\n
chunkCount
Data size too short
Cannot read file 
fread() error on 
data_height = 
Invalid tile size x : 
Invalid tile size y : 
Insufficient data size.\n
Insufficient data length.\n
, height = 
, channels = 
Invalid data width value
Invalid data height value
data width too large.
data height too large.
File size too short 
Invalid EXR header.
R channel not found
G channel not found
B channel not found
Failed to parse EXR version
Cannot read a file 
File size is zero : 
Invalid magic number
Failed to parse attribute\n
Failed to parse channel info
Invalid channels format
stream end
need dictionary
file error
data error
out of memory
buf error
parameter error
vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)
PARALLEL_PROCESS tinyexr_impl.cpp:163
Invalid argument for SaveEXRImageToMemory
ZFP compression is not supported in this build
Invalid argument for SaveEXRImageToFile
basic_string::_S_construct null not valid
Unsupported component value : 
Insufficient data size for attributes.\n
ZFP compression is not supported.
Failed to parse channel info.\n
"compression" attribute not found in the header.
"channels" attribute not found in the header.
"lineOrder" attribute not found in the header.
"displayWindow" attribute not found in the header.
"dataWindow" attribute not found in the header or invalid.
"pixelAspectRatio" attribute not found in the header.
"screenWindowWidth" attribute not found in the header.
"screenWindowCenter" attribute not found in the header.
Invalid argument for ParseEXRMultipartHeaderFromMemory
`chunkCount' attribute is not found in the header.
Invalid argument for ParseEXRMultipartHeaderFromFile()
`fread' error. file may be corrupted.
Invalid argument. `memory` or `exr_header` argument is null in ParseEXRHeaderFromMemory()
Insufficient header/data size.\n
Invalid argument for ParseEXRHeaderFromFile
Invalid data width or data height: 
data_with or data_height too large. data_width: 
Failed to compute channel layout.\n
Image data size is zero or too large: width = 
Invalid data found when decoding pixels.\n
Invalid argument for LoadEXRMultipartImageFromMemory()
EXRHeader variable is not initialized.
Invalid offset size in EXR header chunks.
Invalid `part number' in EXR header chunks.
Invalid argument for LoadEXRMultipartImageFromFile
Invalid argument for LoadEXRImageFromMemory
Invalid argument for DecodeEXRImage().
data width or data height is negative.
Invalid offset value in DecodeEXRImage.
Insufficient data size in offset table.
Cannot reconstruct lineOffset table in DecodeEXRImage.
Invalid argument for LoadEXRImageFromFile
Invalid argument for LoadEXR()
Loading multipart or DeepImage is not supported  in LoadEXR() API
Invalid argument for LoadEXRFromMemory
Invalid argument for LoadDeepEXR
Unsupported version or scanline
Unsupported compression type : 
Unsupported compression format
PNG load error %s\n
1.5.2
Ga==\n
.M;UU
@mathlib.cpp
SSE and SSE2 are required.
-sse2
-sse3
-sse4
-avx
MathLib_Init
.eB5
'7_p
@?a\v6C
?N24CFieldPathHuffmanEncoder5INodeE
N24CFieldPathHuffmanEncoder12InternalNodeE
N24CFieldPathHuffmanEncoder8LeafNodeE
_addons
content
CONTENTROOT
GAMEROOT
%s.360%s
.360
Valid Relative Path
Valid Game Absolute Path
Valid Content Absolute Path
Valid External Path
Invalid Path
Unknown Path Class
src/public/tier0/platform.h
VGAME
sdktools/bin/vproj.exe
sdktools/bin/vprojUI.exe
gameinfo.txt
gameinfo.gi
VScript
VScriptDbg
22CSchemaInstallCallback
File has not been opened!\n
CUtlStreamBuffer does not support TEXT_BUFFER's use CUtlBuffer\n
<no failure reason set>
schemabindings.cpp
FATAL ERROR: unable to register all schema data: %s\n
RegisterAllModuleData
CONTENT
FixupResourceName: Illegal full path passed in ("%s")!\n
FixupResourceName: Illegal path, missing extension passed in ("%s")!\n
GenerateResourceNameFromFileName: Invalid extension specified in file name "%s"!\n
ERROR: Specified full path %s does not lie under the mod search path!)\n
ERROR: Specified path %s could not be made content-relative\n
ERROR: Resource name "%s" has the incorrect extension "%s" for the specified resource type (expected "%s")!\n
Unable to write file '%s'\n
No Buffer
Missing file '%s'
Failed to convert KV3 to string; error: %s\n
Unable to determine buffer encoding.
{}[]()=&, \t\n'"*;
<!--
schema
Line %d at "%s": %s
Line %d: %s
Expected type of next member
Expected []
Expected ( <count> )
Expected token
Expected '[' or '('
Expected value or ']'
Expected ',' or '%s'
Expected '{'
__oldschema_object_name
Expected "="after member '%s'
Invalid data for member '%s'
Invalid header
CAuthPhysBody
m_pParent
CAuthPhysJoint
m_pBody
Expected '&' and instance name or 'NULL'
Failed to assign bool literal value
Line %d: Invalid literal value "%s"
Cycle or diamond double-reference to '%s'
Unresolved object reference '%s'
Expected <member name> after type
__temp_unserialization_member__
z:KEZ
{}[]=, \t\n'":|;
(None)
Expected '#'
Expected '['
Expected hex byte (eg. 00-FF)
null
Line %d: Invalid value "%s"
Unrecognized flag name '%s'
Expected member name or '}'
Invalid member name '%s'
Bad header format (expected '<!--'
Bad header format (expected 'kv3'
Bad header format (expected 'encoding'
Bad header format (expected ':'
Bad header format (expected encoding name)
Bad header format (expected 'version'
Bad header format (expected encoding uuid)
Bad header format (expected 'format'
Bad header format (expected format name)
Bad header format (expected format uuid)
Bad header format (no closing marker)
Bad header format (malformed UUID)
Bad header (unrecognized encoding specifier)
Expected '=' after member name '%s'
resource
-inf
"""\n
\"""
%02X
Unsupported text encoding id.
00000000-0000-0000-0000-000000000000
Cannot save KV3 text to a non-text buffer!
Cannot save as KV3_FORMAT_LOAD_WITH_NO_UPCONVERSION.
<!-- kv3 encoding:%s:version{%s} format:%s:version{%s} -->\n
Unexpected end of file
Unrecognized type '%d'
Invalid data.
Decompression failure
Bad header: invalid binary marker
Bad header: unrecognized encoding id
Bad header: invalid compression header
Invalid compressed buffer size
Trailing Data
Truncated data
%.15lf
Can't write binary data to a text buffer.
Unsupported binary encoding id.
Cannot register same format from/to a KV3 conversion (from '%s' to '%s')
Two KV3 format GUIDs with the same human-friendly name ('%s')
Double-register of KV3 conversion (from '%s' to '%s')
No valid format conversion from '%s' to '%s'
kv3format_manager.cpp
RegisterFormatConversion
_test_conversion_counter
A->B
G->B
B->C
C->D
C->E
rootNode
children
BlendList
AnimationList
IKChain
IKChainOld
PhysicsFileReference
PhysicsFile
WeightList
master_morph_weight
recenter_on_parent_bone
AnimAlign
AnimCommonParams
AnimBaseParams
AnimLinearDelta
AnimSubtract
AnimIkLockLocal
AnimLayer
AnimLayerBase
AnimAddLayer
AnimBlendLayerBase
AnimBlendLayer
AnimBlendLayerPoseParam
AnimAutoLayer
AnimCycleOverride
AnimSmoothLoop
AnimStartLoop
AnimOffset
BaseIKRig
PhysicsBoneMarkup
PhysicsBodyMarkup
AnimFile
loop
looping
AnimProxy
1DBlend
EmptyAnim
anim_name
GenericGameData
game_class
prop_data
game_keys
breakable_model
breakable_skin
breakable_count
BreakPieceExternal
BreakPieceEmbedded
placement_bone
placement_attach
placement_mode
AnimEvent
event_class
AE_NPC_START_POWERED_RAGDOLL
event_keys
pose_control
pose_control_type
AbsolutePoseControl
NoPoseControl
shapeType
mesh
PhysicsMeshFile
faceMergeAngle
PhysicsHullFile
maxVerticesPerHull
maxHullVertices
SequenceMarkup
SequenceMarkupList
RenderMeshFile
VSNAPFile
RemoveBoneAndChildren
bone_name
bone_names
sequence_name
AnimDelta
anim_name_a
anim_name_b
source_filename
frame
break_uniform_burst
burst_scale
burst_randomize
break_create_joint_revolute
anchor_position
anchor_angles
friction
enable_limit
min_angle
max_angle
create_particle
attachment_offset
physgun_interactions
preferred_carryangles
blockLOS
AIWalkable
allowstatic
dmg.bullets
dmg.club
dmg.explosive
dmg.fire
health
explosive_damage
explosive_radius
explosion_delay
glow
spawn_motion_disabled
nav_data
nav_attribute_avoid
cable
material
numsegments
gravity
texturescale
dynamic_interaction
origin_relative
origin_max_delta
test_angles_relative
loop_in_action
loop_break_on_damage
loop_break_on_flashlight
AE_CL_BODYGROUP_SET_VALUE
AE_CL_CREATE_PARTICLE_EFFECT
stop_on_seq_change
stop_immediately
AE_CL_STOP_PARTICLE_EFFECT
stop_instantly
play_endcap
AE_CL_ADD_PARTICLE_EFFECT_CP
control_point
AE_CL_PLAYSOUND_LOOPING
emitFromWorld
AE_IK_SET_LOCK_ROTATION_ALPHA
lockRotationAlpha
AE_SCRIPT_EVENT_FIREEVENT
eventindex
auto_unragdoll_duration
invert_orientation
hurt_me
hurt_them
AE_ZOMBIE_POPHEADCRAB
speed
AE_BLIND_ZOMBIE_SNIFF
last_sniff
AE_HIDE_WEAPON
AE_SV_DUSTTRAIL
suppress
AE_NPC_WEAPON_FIRE
secondary
sequence_number
cantdie
AE_ZOMBIE_TOGGLE_HEAD
headtype
AE_VORTIGAUNT_START_HEAL_GLOW
handindex
AE_VORTIGAUNT_START_HURT_GLOW
AE_VORTIGAUNT_ZAP_POWERUP
AE_VORTIGAUNT_ZAP_SHOOT
AE_PASSENGER_PHYSICS_PUSH
force
AE_MELEE_DAMAGE
yaw_start
yaw_end
AE_CL_CREATE_PARTICLE_BRASS
bUpdate
AE_IK_SET_MASTER_BLEND_AMOUNT
blendamount
AE_IK_SET_CHAIN_BLEND_AMOUNT
AE_ACTION_SET_TURN_RATE_SCALE
turn_rate
BreakCommand
collision_group
health_override
is_debris
BodyGroup
meshes
BodyGroupChoice
cloth_collide
PhysicsShapeCapsule
ClothShapeList
ClothShapeCapsule
radius0
radius1
point0
point1
PhysicsShapeSphere
ClothShapeSphere
center
cloth_collision_layer0
cloth_collision_layer1
cloth_collision_layer2
cloth_collision_layer3
body_type
IKRigSimple
IKRigBiped
IKRigBug
IKData
BentNormalData
EditorDynamicConfig
PreviewBoneMergedModel
PreviewBoneAttachedModel
PreviewAttachmentModel
ConfigAttachedModel
model_name
attachment_type
bonemerge
attach_point
use_additional_offset
relative_origin
relative_angles
PreviewPresetList
DynamicConfigList
PreviewPreset
PhysicsShapeHull
PhysicsShapeMesh
default
PhysicsHullFromRender
surface_prop
collision_prop
BasePhysicsShape
CommandProcedure
CommandProcedureList
ai_model_info
vr_carry_type
explosion_type
explosion_buildup
explosion_behavior
physicsmode
multiplayer_break
modeldoc0
modeldoc1
modeldoc2
modeldoc3
modeldoc4
modeldoc5
modeldoc6
modeldoc7
modeldoc8
modeldoc9
modeldoc10
modeldoc11
modeldoc12
modeldoc13
modeldoc14
modeldoc15
modeldoc16
modeldoc17
modeldoc18
modeldoc19
modeldoc20
modeldoc21
modeldoc22
modeldoc23
modeldoc24
modeldoc25
modeldoc26
modeldoc27
modeldoc28
vmdl
AE_CL_CREATE_PARTICLE_EFFECT_CFG
AE_NPC_BECOME_TEMPORARY_RAGDOLL
AE_NPC_HURT_INTERACTION_PARTNER
AE_DOTA_SUPPRESS_CONSTANT_LAYER
AE_NPC_WEAPON_SET_SEQUENCE_NUMBER
AE_NPC_SET_INTERACTION_CANTDIE
AE_IK_ALLOW_PLANE_TILT_NORMAL_UPDATES
mXr4
\nCwf\r
LrwcE
\twT'
bt3V
{YIN?
n\f"pA3Q
"ikrig
m_ChainData
ikdata
m_ControlRigData
m_JointConstraintPairs
m_Bone
m_JointName
m_Name
m_IKChains
m_Joints
m_JointConstraintData
m_pJointConstraintData
m_EndEffectorBone
m_DefaultSolverSettings
m_SolverType
Two Bone
m_DefaultTargetSettings
m_TargetSource
m_EndEffectorTargetBone
vmdlkeys0
vmdlkeys1
vmdlkeys2
vmdlkeys3
m_bDoBonesOrientAlongPositiveX
j\n\r^
CSolveIKChainAnimNode
m_IkChains
m_IkChain
m_SolverSettingSource
Default
m_TargetSettingSource
animgraph0
vanmgrph
<"C_OP_RemapSpeedtoCP
m_PreEmissionOperators
m_Operators
PARTICLE_DEPTH_FEATHERING_OFF
m_Renderers
m_bParticleFeathering
m_nFeatheringMode
ANIMATION_TYPE_FIT_LIFETIME
ANIMATION_TYPE_FIXED_RATE
m_bFitCycleToLifetime
m_nAnimationType
m_nBehaviorVersion
C_OP_SetControlPointRotation
m_Initializers
C_INIT_CreateSequentialPath
C_OP_ContinuousEmitter
m_Emitters
m_flEmissionScale
m_bScalePerParticle
m_flScalePerParentParticle
C_INIT_CreateWithinSphere
m_bUseHighestEndCP
C_INIT_CreateFromCPs
m_nIncrement
C_OP_NoiseEmitter
C_OP_TwistAroundAxis
m_ForceGenerators
m_bLocalSpace
m_nControlPointNumber
C_OP_RenderSprites
C_OP_WorldTraceConstraint
m_Constraints
m_nCollisionMode
C_OP_RenderModels
m_bForceLoopingAnimation
PARTICLE_SET_REPLACE_VALUE
m_bScaleInitialValue
m_nSetMethod
m_bScaleInitialRange
m_bScaleCurrent
m_Children
m_bDisableOperator
m_bDisableChild
C_INIT_InitFromParentKilled
m_bRunForParentApplyKillList
C_INIT_CreateInEpitrochoid
m_nType
PF_TYPE_LITERAL
m_flLiteralValue
C_OP_RenderTrails
m_flRadiusTaper
m_flRadiusScale
PF_TYPE_RANDOM_UNIFORM
m_flRandomMin
m_flRandomMax
m_nRandomMode
m_flClusterRefireTimeMin
m_flClusterRefireTimeMax
m_nClusterSizeMin
m_nClusterSizeMax
m_flClusterCooldownMin
m_flClusterCooldownMax
m_flClusterRefireTime
PF_RANDOM_MODE_VARYING
m_flClusterSize
m_flClusterCooldown
m_nControlPoint
m_nVectorComponent
m_nMapType
PF_MAP_TYPE_MULT
m_flMultFactor
C_OP_StopAfterCPDuration
m_nCP
m_nCPField
m_flDuration
m_flEmissionDuration
m_flStartTime
m_flEmitRate
m_nScaleControlPoint
m_nScaleControlPointField
PF_MAP_TYPE_REMAP
m_flInput0
m_flInput1
m_flOutput0
m_flOutput1
m_nOpScaleCP
m_nOpStrengthScaleSeed
m_flOpStrengthMinScale
m_flOpStrengthMaxScale
m_nScaleCPComponent
m_flOpStrength
C_OP_InstantaneousEmitter
m_nParticlesToEmit
m_nMinParticlesToEmit
m_flStartTimeMax
PF_MAP_TYPE_REMAP_BIASED
m_nBiasType
PF_BIAS_TYPE_EXPONENTIAL
m_flBiasParameter
C_OP_AttractToControlPoint
m_fForceAmount
m_fForceAmountMin
m_nScaleCP
m_nScaleCPField
m_bRemapPullForceToLife
m_fLifespanScaleExp
m_bApplyMinForce
PVEC_TYPE_LITERAL_COLOR
m_LiteralColor
PVEC_TYPE_LITERAL
m_vLiteralValue
m_ColorScale
m_vecColorScale
m_Color
m_vEndTrailTintFactor
m_flTailAlphaScale
m_vecTailColorScale
CParticleSystemDefinition
m_pszSnapshotName
m_hSnapshot
C_OP_InitSetSnapshotOnCP
m_snapshotName
vsnap
particles/
%s%s
vpcf1
vpcf2
vpcf3
vpcf4
vpcf5
vpcf6
vpcf7
vpcf8
vpcf9
vpcf10
vpcf11
vpcf12
vpcf13
vpcf14
vpcf15
vpcf16
vpcf17
vpcf18
vpcf19
vpcf20
vpcf21
vpcf22
vpcf23
vpcf24
vpcf25
vpcf26
vpcf
m_bOffsetExistingPos
C_INIT_CreateOnModelAtHeight
C_INIT_SetHitboxToClosest
C_INIT_PositionOffset
C_INIT_PositionOffsetToCP
C_INIT_PositionPlaceOnGround
C_INIT_VelocityFromNormal
C_INIT_VelocityRandom
C_INIT_InitialVelocityNoise
C_INIT_VelocityRadialRandom
C_INIT_RandomVectorComponent
C_INIT_AddVectorToVector
C_INIT_SequenceFromCP
C_INIT_PositionWarp
C_INIT_MoveBetweenPoints
m_bTrailBias
C_INIT_RemapScalar
C_INIT_InheritVelocity
C_INIT_VelocityFromCP
C_INIT_AgeNoise
C_INIT_SequenceLifeTime
C_INIT_RemapScalarToVector
C_INIT_OffsetVectorToVector
C_INIT_RandomYawFlip
C_INIT_RemapCPtoScalar
C_INIT_RemapCPtoVector
C_INIT_DistanceToCPInit
C_INIT_LifespanFromVelocity
C_INIT_ModelCull
C_INIT_RtEnvCull
C_INIT_NormalOffset
C_INIT_RemapSpeedToScalar
C_INIT_InitFromCPSnapshot
m_nAttributeToWrite
C_INIT_SetRigidAttachment
C_INIT_GlobalScale
C_INIT_MakeShapes
C_OP_RemapModelVolumetoCP
C_OP_RemapBoundingVolumetoCP
C_OP_RampCPLinearRandom
C_OP_SetControlPointPositions
C_OP_DistanceBetweenCPsToCP
C_OP_SetControlPointToPlayer
C_OP_SetControlPointToHand
C_OP_SetControlPointToHMD
C_OP_SetControlPointToCenter
C_OP_RemapCPtoCP
C_OP_HSVShiftToCP
PARTICLE_DEPTH_FEATHERING_ON_OPTIONAL
C_INIT_RemapInitialCPDirectionToRotation
C_OP_LockToSavedSequentialPath
C_INIT_InheritFromParentParticles
C_OP_InheritFromParentParticles
COLLISION_MODE_USE_NEAREST_TRACE
COLLISION_MODE_INITIAL_TRACE_DOWN
COLLISION_MODE_PER_FRAME_PLANESET
COLLISION_MODE_PER_PARTICLE_TRACE
PARTICLE_SET_SCALE_INITIAL_VALUE
PARTICLE_SET_SCALE_CURRENT_VALUE
m_nFirstMultipleOverride_BackwardCompat
C_OP_RepeatedTriggerChildGroup
PF_TYPE_PARTICLE_AGE_NORMALIZED
PF_TYPE_CONTROL_POINT_COMPONENT
m_bInitFromKilledParentParticles
m_flInitFromKilledParentParticles
C_INIT_InitialVelocityFromHitbox
C_INIT_RemapParticleCountToScalar
C_INIT_InitialRepulsionVelocity
C_INIT_RemapInitialVisibilityScalar
C_INIT_RemapNamedModelElementToScalar
C_OP_RemapAverageScalarValuetoCP
C_OP_SetParentControlPointsToChildCP
C_OP_SetSingleControlPointPosition
C_OP_SetRandomControlPointPosition
C_OP_SetControlPointOrientation
C_OP_SetControlPointFromObjectScale
C_OP_SetControlPointPositionToTimeOfDayValue
C_OP_SetControlPointToImpactPoint
C_OP_SetCPOrientationToPointAtCP
C_OP_EnableChildrenFromParentParticleCount
C_OP_DriveCPFromGlobalSoundFloat
C_OP_SetControlPointFieldToWater
lcQe
r\n,}v
' D]7
?Cg"
S+Ot
Po5H
E3:0
l=!\n
Avfx_shader_file.cpp
Shader file version mismatch.  Expected (%d), Got (%d).
Unserialize
14CVfxShaderFile
20CVfxShaderFileVulkan
\t ();,\n\r
\t ();,
vfx_common.cpp
ERROR!
__SET_BY_FEATURE__
__FROM_ATTRIBUTE__
#define
#undef
HEADER
COMMON
MODES
FEATURES
struct VS_INPUT
struct PS_INPUT
struct GS_INPUT
struct HS_INPUT
struct DS_INPUT
struct HS_OUTPUT
struct HS_PATCH_CONSTANTS
system.fxc
SHADER_SOURCE
Unknown DX level\n
SHADER_SOURCE_ROOT
PC_SM_3_0
%d..%d
.ini
shaders/vfx
.vpk:
.vcs
(On the line reading %s):\n
=\t ();,\n\r<>
ChildOf
Requires
Requires%d
Allow
Allow%d
SerializeStaticComboWorker
FeatureRule
vfxc
0123456789)"
StaticComboRule
DynamicComboRule
StaticCombo
DynamicCombo
DynamicComboFromFeature
Static combos:\n
   %s 0..0\n
   %s 
%d..%d\n
   None\n
   StaticComboRule( 
ChildOf( 
Requires%d( 
Allow%d( 
==%d
Dynamic combos:\n
   DynamicComboRule( 
Dynamic )\n
\nSkipped %d%% of all combos\n
CompileShadersForFeatureCombo
Spawning %d compile jobs\n
-dev
CUtlBlockMemory overflow!\n
m_nVariableSourceMax
m_staticComboArray
m_staticComboRuleArray
m_dynamicComboArray
m_dynamicComboRuleArray
m_variableDescriptionArray
m_vsInputSignatureArray
nCombos
.vpk
PC SM 3.0
vfx_dx9
features
vs_3_0
ps_3_0
PC_SM_4_0
PC SM 4.0 (D3D10)
vfx_dx11
gs_4_0
PC_SM_4_1
PC SM 4.1 (D3D10.1)
vs_4_1
ps_4_1
gs_4_1
PC_SM_5_0
PC SM 5.0 (D3D11)
vs_5_0
ps_5_0
gs_5_0
hs_5_0
ds_5_0
cs_5_0
PC_SM_3_0_GL
PC SM 3.0 (GLSL)
vfx_gl
PC_SM_4_0_GL
PC SM 4.0 (GLSL)
PC_SM_4_1_GL
PC SM 4.1 (GLSL)
PC_SM_5_0_GL
PC SM 5.0 (GLSL)
PC_SM_4_0_VULKAN
PC SM 4.0 (VULKAN)
PC_SM_4_1_VULKAN
PC SM 4.1 (VULKAN)
PC_SM_5_0_VULKAN
PC SM 5.0 (VULKAN)
MOBILE_GLES_3_0
Mobile SM 3.0 (GLES 3.0)
MOBILE_GLES_3_1
Mobile SM 3.0 (GLES 3.1)
IOS_VULKAN_4_0
iOS SM 4.0 (VULKAN)
ANDROID_VULKAN_4_0
Android SM 4.0 (VULKAN)
______<INVALID>______
\nPS_RENDER_STATE
PCGL
MOBILE_GLES
IOS_VULKAN
ANDROID_VULKAN
3_0_gl
4_0_gl
4_1_gl
5_0_gl
4_0_vulkan
4_1_vulkan
5_0_vulkan
3_0_gles
3_1_gles
<invalid>
MainVs
MainPs
MainGs
MainHs
MainDs
MainCs
Vertex Shader
Pixel Shader
Geometry Shader
Hull Shader
Domain Shader
Compute Shader
Pixel Shader Render State
VFX_PROGRAM_MAX
Modes
Dev Shader
Compile Targets
Description
modes
DevShader
CompileTargets
_feature
_psrs
__SetByArtist__
__Attribute__
__FeatureToInt__
__FeatureToBool__
__FeatureToFloat__
__RenderStateLiteral__
__Expression__
__SetByArtistAndExpression__
InvViewportSize
InvTextureDim
TextureDimLog2
TextureSheetData
ShadingComplexity
ShaderIDColor
ExternalDescSet
bool2
bool3
bool4
samplerCUBE
float3x3
float4x3
float4x4
cbuffer
samplerCUBEARRAY
sampler2DARRAY
sampler1DARRAY
sampler3DARRAY
rwbuffer
rwtexture1d
rwtexture1darray
rwtexture2d
rwtexture2darray
rwtexture3d
rwstructuredbuffer
rwbyteaddressbuffer
appendstructuredbuffer
consumestructuredbuffer
rwstructuredbufferwithcounter
externaldescriptorset
Slider
VectorText
CheckBox
__FROM_ATTRIBUTE_OR_FEATURE__
D_FADE_COLOR
S_TOOLS_ENABLED
S_SHADER_QUALITY
S_VR
S_MOLTEN_VK
S_BINDLESS_RUNTIME
S_MOBILE
S_TRANSFORM_CONSTANT_BUFFER
S_SUPPORTS_CLIP_DISTANCE
IS_SM_
Error resolving symbol "%s"\n
Compile Target Expression
Expression Parser - 
%s[line %d:%d] 
Expecting %s
Unknown variable name %s.
%s() isn't a known function.
frac
floor
ceil
saturate
lerp
dot4
dot3
dot2
smoothstep
SrgbLinearToGamma
SrgbGammaToLinear
random
TextureSize
Mismatched set
<EOR>
<DOWN>
<UP>
HEXINTEGERLITERAL
FLOATLITERAL
BOOLLITERAL
HEX_DIGIT
EXPONENT
FLOATSUFFIX
COMMENT
UNICODE_ESC
OCTAL_ESC
ESC_SEQ
'return'
'||'
'&&'
'=='
'!='
'<='
'>='
'exists'
#pragma 
#error 
#extension 
#version 
#line 
version not supported
4.60 glslang Khronos. 13.3381
basic_string::_S_create
relaxed-errors
suppress-warnings
keep-uncalled
source-entrypoint
@this
@count
client vulkan100
client opengl100
target-env spirv1.1
target-env spirv1.2
target-env spirv1.3
target-env spirv1.4
target-env spirv1.5
target-env spirvUnknown
target-env vulkan1.0
target-env vulkan1.1
target-env vulkanUnknown
target-env opengl
\nLinked 
 stage:\n\n
entry-point
INTERNAL ERROR: 
resource-set-binding
flatten-uniform-arrays
auto-map-bindings
invert-y
no-storage-format
hlsl-iomap
auto-map-locations
Unable to parse built-ins
Unable to parse built-ins\n%s\n
core
compatibility
unknown profile
hlsl-offsets
BuiltinSymbolTable {\n
#version
\n int;
;()[]
#version: versions before 150 do not allow a profile token
#version: versions 300, 310, and 320 support only the es profile
#version: only version 300, 310, and 320 support the es profile
#version: geometry shaders require es profile with version 310 or non-es profile with version 150 or above
#version: tessellation shaders require es profile with version 310 or non-es profile with version 150 or above
#version: compute shaders require es profile with version 310 or above, or non-es profile with version 420 or above
#version: ray tracing shaders require non-es profile with version 460 or above
#version: mesh/task shaders require es profile with version 320 or above, or non-es profile with version 450 or above
#version: statement must appear first in es-profile shader; before comments or newlines
#version: ES shaders for SPIR-V require version 310 or higher
#version: compilation for SPIR-V does not support the compatibility profile
#version: Desktop shaders for Vulkan SPIR-V require version 140 or higher
#version: Desktop shaders for OpenGL SPIR-V require version 330 or higher
#version: versions 300, 310, and 320 require specifying the 'es' profile
OpenGL ES GLSL 3.20 glslang Khronos. 13.3381
Cannot mix ES profile with non-ES profile shaders
Cannot attach multiple ES shaders of the same type to a single program
Unable to determine source language
Not all shaders have valid object code.
Warning, (version, profile) forced to be (
), while in source code it is (
Illegal to have non-comment, non-whitespace tokens before #version
No errors.  No code generation or linking was requested.
 compilation errors.  No code generated.\n\n
SubGroupSize
SubGroupInvocation
SubGroupEqMask
SubGroupGeMask
SubGroupGtMask
SubGroupLeMask
SubGroupLtMask
DrawId
FragStencilRef
SampleId
BaryCoordNoPersp
BaryCoordNoPerspCentroid
BaryCoordNoPerspSample
BaryCoordSmooth
BaryCoordSmoothCentroid
BaryCoordSmoothSample
BaryCoordPullModel
LaunchIdNV
ObjectRayTminNV
ObjectRayTmaxNV
unknown built-in variable
LEVEL 
anonymous member 
basic_string::append
subpass
column_major
row_major
std140
packed
std430
rgba32f
rgba16f
rg32f
rg16f
r11f_g11f_b10f
r16f
rgba16
rgb10_a2
rgba8
rg16
rgba16_snorm
rgba8_snorm
rg16_snorm
rg8_snorm
r16_snorm
r8_snorm
rgba32i
rgba16i
rgba8i
rg32i
rg16i
rg8i
r32i
r16i
rgba32ui
rgba16ui
rgba8ui
rg32ui
rg16ui
rgb10_a2ui
rg8ui
r32ui
r16ui
r8ui
temp
global
const (read only)
inout
gl_VertexId
gl_InstanceId
gl_Position
gl_PointSize
gl_ClipVertex
gl_FrontFacing
fragColor
gl_FragDepth
rayPayloadNV
rayPayloadInNV
hitAttributeNV
callableDataNV
callableDataInNV
unknown qualifier
lowp
mediump
highp
unknown precision qualifier
sampler/image
accelerationStructureNV
unknown type
 component=
 index=
 set=
 binding=
 stream=
 offset=
 align=
 xfb_offset=
 xfb_stride=
 input_attachment_index=
 constant_id=
 push_constant
 buffer_reference
 buffer_reference_align=
 layoutViewportRelative
 shaderRecordNV
 invariant
 noContraction
 centroid
 smooth
 noperspective
 __explicitInterpAMD
 pervertexNV
 perprimitiveNV
 perviewNV
 taskNV
 patch
 sample
 coherent
 devicecoherent
 queuefamilycoherent
 workgroupcoherent
 subgroupcoherent
 nonprivate
 volatile
 restrict
 readonly
 writeonly
 specialization-constant
 nonuniform
 unsized
-element array of
 matrix of
-component vector of
 location=
 xfb_buffer=
 runtime-sized array of
layout(
asnv
-tx-struct
struct-
block-
basic_string::insert
anon@
 layoutSecondaryViewportRelativeOffset=
feature not yet implemented
no longer supported in
GL_NV_cooperative_matrix
GL_EXT_shader_8bit_storage
GL_AMD_gpu_shader_int16
GL_EXT_shader_16bit_storage
GL_AMD_gpu_shader_half_float
#define GL_core_profile 1\n
#define VULKAN 
#define GL_SPIRV 
vertex
fragment
tessellation control
tessellation evaluation
geometry
ray-generation
intersection
any-hit
closest-hit
miss
callable
task
unknown stage
not supported in this stage:
#extension
extension not supported:
 deprecated in version 
WARNING: 
GL_OES_texture_3D
GL_OES_standard_derivatives
GL_EXT_frag_depth
GL_OES_EGL_image_external
GL_EXT_YUV_target
GL_EXT_shader_texture_lod
GL_EXT_shadow_samplers
GL_ARB_texture_rectangle
GL_3DL_array_objects
GL_ARB_texture_gather
GL_ARB_gpu_shader5
GL_ARB_compute_shader
GL_ARB_tessellation_shader
GL_ARB_enhanced_layouts
GL_ARB_texture_cube_map_array
GL_ARB_shader_texture_lod
GL_ARB_shader_atomic_counters
GL_ARB_shader_draw_parameters
GL_ARB_shader_group_vote
GL_ARB_derivative_control
GL_ARB_viewport_array
GL_ARB_gpu_shader_int64
GL_ARB_shader_ballot
GL_ARB_sparse_texture2
GL_ARB_sparse_texture_clamp
GL_ARB_shader_stencil_export
GL_ARB_post_depth_coverage
GL_ARB_shader_clock
GL_KHR_shader_subgroup_basic
GL_KHR_shader_subgroup_vote
GL_KHR_shader_subgroup_ballot
GL_KHR_shader_subgroup_quad
GL_KHR_memory_scope_semantics
GL_EXT_shader_atomic_int64
GL_EXT_post_depth_coverage
GL_EXT_nonuniform_qualifier
GL_EXT_scalar_block_layout
GL_EXT_buffer_reference
GL_EXT_buffer_reference2
GL_EXT_buffer_reference_uvec2
GL_GOOGLE_include_directive
GL_AMD_shader_ballot
GL_AMD_shader_trinary_minmax
GL_AMD_gcn_shader
GL_AMD_shader_fragment_mask
GL_NV_viewport_array2
GL_NV_stereo_view_rendering
GL_NV_shader_atomic_int64
GL_NV_shading_rate_image
GL_NV_ray_tracing
GL_NV_shader_sm_builtins
GL_OES_sample_variables
GL_OES_shader_image_atomic
GL_EXT_geometry_shader
GL_EXT_geometry_point_size
GL_EXT_gpu_shader5
GL_EXT_primitive_bounding_box
GL_EXT_shader_io_blocks
GL_EXT_tessellation_shader
GL_EXT_texture_buffer
GL_EXT_texture_cube_map_array
GL_OES_geometry_shader
GL_OES_geometry_point_size
GL_OES_gpu_shader5
GL_OES_primitive_bounding_box
GL_OES_shader_io_blocks
GL_OES_tessellation_shader
GL_OES_texture_buffer
GL_OES_texture_cube_map_array
GL_EXT_device_group
GL_EXT_multiview
GL_EXT_shader_realtime_clock
GL_OVR_multiview
GL_OVR_multiview2
basic_string::assign
 is being used for 
Possible extensions include:
#extension GL_NV_mesh_shader
require
disable
warn
behavior not supported:
%s profile; removed in version %d
only allowed when generating SPIR-V
only allowed when using GLSL for Vulkan
not allowed when using GLSL for Vulkan
not allowed when generating SPIR-V
GL_NV_integer_cooperative_matrix
GL_EXT_shader_explicit_arithmetic_types
GL_EXT_shader_explicit_arithmetic_types_int32
GL_EXT_shader_explicit_arithmetic_types_int8
GL_EXT_shader_explicit_arithmetic_types_int16
GL_EXT_shader_explicit_arithmetic_types_float32
GL_EXT_shader_explicit_arithmetic_types_float16
#define GL_ES 1\n#define GL_FRAGMENT_PRECISION_HIGH 1\n#define GL_OES_texture_3D 1\n#define GL_OES_standard_derivatives 1\n#define GL_EXT_frag_depth 1\n#define GL_OES_EGL_image_external 1\n#define GL_OES_EGL_image_external_essl3 1\n#define GL_EXT_YUV_target 1\n#define GL_EXT_shader_texture_lod 1\n#define GL_EXT_shadow_samplers 1\n#define GL_ANDROID_extension_pack_es31a 1\n#define GL_KHR_blend_equation_advanced 1\n#define GL_OES_sample_variables 1\n#define GL_OES_shader_image_atomic 1\n#define GL_OES_shader_multisample_interpolation 1\n#define GL_OES_texture_storage_multisample_2d_array 1\n#define GL_EXT_geometry_shader 1\n#define GL_EXT_geometry_point_size 1\n#define GL_EXT_gpu_shader5 1\n#define GL_EXT_primitive_bounding_box 1\n#define GL_EXT_shader_io_blocks 1\n#define GL_EXT_tessellation_shader 1\n#define GL_EXT_tessellation_point_size 1\n#define GL_EXT_texture_buffer 1\n#define GL_EXT_texture_cube_map_array 1\n#define GL_OES_geometry_shader 1\n#define GL_OES_geometry_point_size 1\n#define GL_OES_gpu_shader5 1\n#define GL_OES_primitive_bounding_box 1\n#define GL_OES_shader_io_blocks 1\n#define GL_OES_tessellation_shader 1\n#define GL_OES_tessellation_point_size 1\n#define GL_OES_texture_buffer 1\n#define GL_OES_texture_cube_map_array 1\n#define GL_EXT_shader_non_constant_global_initializers 1\n
#define GL_FRAGMENT_PRECISION_HIGH 1\n#define GL_ARB_texture_rectangle 1\n#define GL_ARB_shading_language_420pack 1\n#define GL_ARB_texture_gather 1\n#define GL_ARB_gpu_shader5 1\n#define GL_ARB_separate_shader_objects 1\n#define GL_ARB_compute_shader 1\n#define GL_ARB_tessellation_shader 1\n#define GL_ARB_enhanced_layouts 1\n#define GL_ARB_texture_cube_map_array 1\n#define GL_ARB_shader_texture_lod 1\n#define GL_ARB_explicit_attrib_location 1\n#define GL_ARB_explicit_uniform_location 1\n#define GL_ARB_shader_image_load_store 1\n#define GL_ARB_shader_atomic_counters 1\n#define GL_ARB_shader_draw_parameters 1\n#define GL_ARB_shader_group_vote 1\n#define GL_ARB_derivative_control 1\n#define GL_ARB_shader_texture_image_samples 1\n#define GL_ARB_viewport_array 1\n#define GL_ARB_gpu_shader_int64 1\n#define GL_ARB_shader_ballot 1\n#define GL_ARB_sparse_texture2 1\n#define GL_ARB_sparse_texture_clamp 1\n#define GL_ARB_shader_stencil_export 1\n#define GL_ARB_post_depth_coverage 1\n#define GL_ARB_fragment_shader_interlock 1\n#define GL_EXT_shader_non_constant_global_initializers 1\n#define GL_EXT_shader_image_load_formatted 1\n#define GL_EXT_post_depth_coverage 1\n#define GL_EXT_control_flow_attributes 1\n#define GL_EXT_nonuniform_qualifier 1\n#define GL_EXT_shader_16bit_storage 1\n#define GL_EXT_shader_8bit_storage 1\n#define GL_EXT_samplerless_texture_functions 1\n#define GL_EXT_scalar_block_layout 1\n#define GL_EXT_fragment_invocation_density 1\n#define GL_EXT_buffer_reference 1\n#define GL_EXT_buffer_reference2 1\n#define GL_EXT_buffer_reference_uvec2 1\n#define GL_EXT_demote_to_helper_invocation 1\n#define GL_KHR_shader_subgroup_basic 1\n#define GL_KHR_shader_subgroup_vote 1\n#define GL_KHR_shader_subgroup_arithmetic 1\n#define GL_KHR_shader_subgroup_ballot 1\n#define GL_KHR_shader_subgroup_shuffle 1\n#define GL_KHR_shader_subgroup_shuffle_relative 1\n#define GL_KHR_shader_subgroup_clustered 1\n#define GL_KHR_shader_subgroup_quad 1\n#define E_GL_EXT_shader_atomic_int64 1\n#define E_GL_EXT_shader_realtime_clock 1\n#define GL_AMD_shader_ballot 1\n#define GL_AMD_shader_trinary_minmax 1\n#define GL_AMD_shader_explicit_vertex_parameter 1\n#define GL_AMD_gcn_shader 1\n#define GL_AMD_gpu_shader_half_float 1\n#define GL_AMD_texture_gather_bias_lod 1\n#define GL_AMD_gpu_shader_int16 1\n#define GL_AMD_shader_image_load_store_lod 1\n#define GL_AMD_shader_fragment_mask 1\n#define GL_AMD_gpu_shader_half_float_fetch 1\n#define GL_NV_sample_mask_override_coverage 1\n#define GL_NV_geometry_shader_passthrough 1\n#define GL_NV_viewport_array2 1\n#define GL_NV_shader_atomic_int64 1\n#define GL_NV_conservative_raster_underestimation 1\n#define GL_NV_shader_subgroup_partitioned 1\n#define GL_NV_shading_rate_image 1\n#define GL_NV_ray_tracing 1\n#define GL_NV_fragment_shader_barycentric 1\n#define GL_NV_compute_shader_derivatives 1\n#define GL_NV_shader_texture_footprint 1\n#define GL_NV_mesh_shader 1\n#define GL_NV_cooperative_matrix 1\n#define GL_NV_integer_cooperative_matrix 1\n#define GL_EXT_shader_explicit_arithmetic_types 1\n#define GL_EXT_shader_explicit_arithmetic_types_int8 1\n#define GL_EXT_shader_explicit_arithmetic_types_int16 1\n#define GL_EXT_shader_explicit_arithmetic_types_int32 1\n#define GL_EXT_shader_explicit_arithmetic_types_int64 1\n#define GL_EXT_shader_explicit_arithmetic_types_float16 1\n#define GL_EXT_shader_explicit_arithmetic_types_float32 1\n#define GL_EXT_shader_explicit_arithmetic_types_float64 1\n#define GL_EXT_shader_subgroup_extended_types_int8 1\n#define GL_EXT_shader_subgroup_extended_types_int16 1\n#define GL_EXT_shader_subgroup_extended_types_int64 1\n#define GL_EXT_shader_subgroup_extended_types_float16 1\n
#define GL_compatibility_profile 1\n
#define GL_EXT_device_group 1\n#define GL_EXT_multiview 1\n#define GL_NV_shader_sm_builtins 1\n
#define GL_OVR_multiview 1\n#define GL_OVR_multiview2 1\n
#define GL_GOOGLE_cpp_style_line_directive 1\n#define GL_GOOGLE_include_directive 1\n
#define GL_NV_shader_noperspective_interpolation 1\n
not supported with this profile:
extension 'all' cannot have 'require' or 'enable' behavior
extension is only partially supported:
deprecated, may be removed in future release
; may be removed in future release
GL_OES_EGL_image_external_essl3
GL_ARB_shading_language_420pack
GL_ARB_separate_shader_objects
GL_ARB_explicit_attrib_location
GL_ARB_explicit_uniform_location
GL_ARB_shader_image_load_store
GL_ARB_shader_texture_image_samples
GL_ARB_shader_viewport_layer_array
GL_ARB_fragment_shader_interlock
GL_KHR_shader_subgroup_arithmetic
GL_KHR_shader_subgroup_shuffle
GL_KHR_shader_subgroup_shuffle_relative
GL_KHR_shader_subgroup_clustered
GL_EXT_shader_non_constant_global_initializers
GL_EXT_shader_image_load_formatted
GL_EXT_control_flow_attributes
GL_EXT_samplerless_texture_functions
GL_EXT_fragment_invocation_density
GL_EXT_demote_to_helper_invocation
GL_GOOGLE_cpp_style_line_directive
GL_AMD_shader_explicit_vertex_parameter
GL_AMD_texture_gather_bias_lod
GL_AMD_shader_image_load_store_lod
GL_AMD_gpu_shader_half_float_fetch
GL_NV_sample_mask_override_coverage
GL_NV_geometry_shader_passthrough
GL_NVX_multiview_per_view_attributes
GL_NV_conservative_raster_underestimation
GL_NV_shader_noperspective_interpolation
GL_NV_shader_subgroup_partitioned
GL_NV_fragment_shader_barycentric
GL_NV_compute_shader_derivatives
GL_NV_shader_texture_footprint
GL_ANDROID_extension_pack_es31a
GL_KHR_blend_equation_advanced
GL_OES_shader_multisample_interpolation
GL_OES_texture_storage_multisample_2d_array
GL_EXT_tessellation_point_size
GL_OES_tessellation_point_size
GL_EXT_shader_explicit_arithmetic_types_int64
GL_EXT_shader_explicit_arithmetic_types_float64
GL_EXT_shader_subgroup_extended_types_int8
GL_EXT_shader_subgroup_extended_types_int16
GL_EXT_shader_subgroup_extended_types_int64
GL_EXT_shader_subgroup_extended_types_float16
The following extension must be enabled to use this feature:
required extension not requested:
not supported for this version or the enabled extensions
Branch: Kill
Branch: Break
Branch: Continue
Branch: Return
case: 
Demote
default: 
Branch: Unknown Branch
 with expression\n
: Flatten
: DontFlatten
Loop with condition 
not 
tested first
: Unroll
: DontUnroll
: Dependency 
Loop Condition\n
No loop condition\n
Loop Body\n
No loop body\n
Loop Terminal Expression\n
lines_adjacency
line_strip
triangles
triangles_adjacency
triangle_strip
quads
isolines
equal_spacing
fractional_even_spacing
fractional_odd_spacing
depth_any
depth_greater
depth_less
depth_unchanged
pixel_interlock_ordered
pixel_interlock_unordered
sample_interlock_ordered
sample_interlock_unordered
Shader version: 
Requested 
in xfb mode\n
input primitive = 
vertex spacing = 
triangle order = 
using point mode\n
invocations = 
max_vertices = 
output primitive = 
using early_fragment_tests\n
using post_depth_coverage\n
using 
blend_support_all_equations
interlock ordering = 
max_primitives = 
local_size = (
local_size ids = (
using
blend_support_multiply
blend_support_screen
blend_support_overlay
blend_support_darken
blend_support_lighten
blend_support_colordodge
blend_support_colorburn
blend_support_hardlight
blend_support_softlight
blend_support_difference
blend_support_exclusion
blend_support_hsl_hue
blend_support_hsl_saturation
blend_support_hsl_color
blend_support_hsl_luminosity
, operation at 
node is still EOpNull!
Sequence\n
Linker Objects\n
Comma
Function Definition: 
Function Call: 
Function Parameters: 
Construct float
Construct double
Construct vec2
Construct vec3
Construct vec4
Construct dvec2
Construct dvec3
Construct dvec4
Construct bool
Construct bvec2
Construct bvec3
Construct bvec4
Construct int8_t
Construct i8vec2
Construct i8vec3
Construct i8vec4
Construct int
Construct ivec2
Construct ivec3
Construct ivec4
Construct uint8_t
Construct u8vec2
Construct u8vec3
Construct u8vec4
Construct uint
Construct uvec2
Construct uvec3
Construct uvec4
Construct int64
Construct i64vec2
Construct i64vec3
Construct i64vec4
Construct uint64
Construct u64vec2
Construct u64vec3
Construct u64vec4
Construct int16_t
Construct i16vec2
Construct i16vec3
Construct i16vec4
Construct uint16_t
Construct u16vec2
Construct u16vec3
Construct u16vec4
Construct mat2
Construct mat2x3
Construct mat2x4
Construct mat3x2
Construct mat3
Construct mat3x4
Construct mat4x2
Construct mat4x3
Construct mat4
Construct dmat2
Construct dmat2x3
Construct dmat2x4
Construct dmat3x2
Construct dmat3
Construct dmat3x4
Construct dmat4x2
Construct dmat4x3
Construct dmat4
Construct imat2
Construct imat2x3
Construct imat2x4
Construct imat3x2
Construct imat3
Construct imat3x4
Construct imat4x2
Construct imat4x3
Construct imat4
Construct umat2
Construct umat2x3
Construct umat2x4
Construct umat3x2
Construct umat3
Construct umat3x4
Construct umat4x2
Construct umat4x3
Construct umat4
Construct bmat2
Construct bmat2x3
Construct bmat2x4
Construct bmat3x2
Construct bmat3
Construct bmat3x4
Construct bmat4x2
Construct bmat4x3
Construct bmat4
Construct float16_t
Construct f16vec2
Construct f16vec3
Construct f16vec4
Construct f16mat2
Construct f16mat2x3
Construct f16mat2x4
Construct f16mat3x2
Construct f16mat3
Construct f16mat3x4
Construct f16mat4x2
Construct f16mat4x3
Construct f16mat4
Construct structure
Construct reference
Construct cooperative matrix
Compare Less Than
Compare Greater Than
Compare Less Than or Equal
Compare Greater Than or Equal
modf
arc tangent
dot-product
cross-product
face-forward
refract
component-wise multiply
outer product
EmitVertex
EndPrimitive
MemoryBarrierAtomicCounter
GroupMemoryBarrier
readInvocation
swizzleInvocations
swizzleInvocationsMasked
writeInvocation
min3
max3
mid3
AtomicCounterAdd
AtomicCounterSubtract
AtomicCounterMin
AtomicCounterMax
AtomicCounterAnd
AtomicCounterOr
AtomicCounterXor
AtomicCounterExchange
AtomicCounterCompSwap
imageQuerySize
imageQuerySamples
imageLoad
imageStore
imageAtomicAdd
imageAtomicMin
imageAtomicMax
imageAtomicAnd
imageAtomicOr
imageAtomicXor
imageAtomicExchange
imageAtomicCompSwap
imageAtomicLoad
imageAtomicStore
imageLoadLod
imageStoreLod
textureSize
textureQueryLod
textureQueryLevels
textureSamples
textureProj
textureLod
textureOffset
textureFetch
textureFetchOffset
textureProjOffset
textureLodOffset
textureProjLod
textureProjLodOffset
textureGrad
textureGradOffset
textureProjGrad
textureProjGradOffset
textureGather
textureGatherOffset
textureGatherOffsets
textureClamp
textureOffsetClamp
textureGradClamp
textureGradOffsetClamp
textureGatherLod
textureGatherLodOffset
textureGatherLodOffsets
sparseTexture
sparseTextureOffset
sparseTextureLod
sparseTextureLodOffset
sparseTexelFetch
sparseTexelFetchOffset
sparseTextureGrad
sparseTextureGradOffset
sparseTextureGather
sparseTextureGatherOffset
sparseTextureGatherOffsets
sparseImageLoad
sparseTextureClamp
sparseTextureOffsetClamp
sparseTextureGradClamp
sparseTextureGradOffsetClam
sparseTextureGatherLod
sparseTextureGatherLodOffset
sparseTextureGatherLodOffsets
sparseImageLoadLod
imageSampleFootprintNV
imageSampleFootprintClampNV
imageSampleFootprintLodNV
imageSampleFootprintGradNV
uMulExtended
iMulExtended
bitfieldExtract
bitfieldInsert
frexp
ldexp
interpolateAtSample
interpolateAtOffset
interpolateAtVertex
sincos
AllMemoryBarrierWithGroupSync
DeviceMemoryBarrier
WorkgroupMemoryBarrier
subgroupBarrier
subgroupMemoryBarrier
subgroupMemoryBarrierBuffer
subgroupMemoryBarrierImage
subgroupMemoryBarrierShared
subgroupElect
subgroupAll
subgroupAny
subgroupAllEqual
subgroupBroadcast
subgroupBroadcastFirst
subgroupBallot
subgroupInverseBallot
subgroupBallotBitExtract
subgroupBallotBitCount
subgroupBallotFindLSB
subgroupBallotFindMSB
subgroupShuffle
subgroupShuffleXor
subgroupShuffleUp
subgroupShuffleDown
subgroupAdd
subgroupMul
subgroupMin
subgroupMax
subgroupAnd
subgroupOr
subgroupXor
subgroupInclusiveAdd
subgroupInclusiveMul
subgroupInclusiveMin
subgroupInclusiveMax
subgroupInclusiveAnd
subgroupInclusiveOr
subgroupInclusiveXor
subgroupExclusiveAdd
subgroupExclusiveMul
subgroupExclusiveMin
subgroupExclusiveMax
subgroupExclusiveAnd
subgroupExclusiveOr
subgroupExclusiveXor
subgroupClusteredAdd
subgroupClusteredMul
subgroupClusteredMin
subgroupClusteredMax
subgroupClusteredAnd
subgroupClusteredOr
subgroupClusteredXor
subgroupQuadBroadcast
subgroupQuadSwapHorizontal
subgroupQuadSwapVertical
subgroupQuadSwapDiagonal
subgroupPartitionNV
subgroupPartitionedAddNV
subgroupPartitionedMulNV
subgroupPartitionedMinNV
subgroupPartitionedMaxNV
subgroupPartitionedAndNV
subgroupPartitionedOrNV
subgroupPartitionedXorNV
subpassLoadMS
traceNV
reportIntersectionNV
ignoreIntersectionNV
terminateRayNV
executeCallableNV
Load cooperative matrix
Store cooperative matrix
MulAdd cooperative matrices
IsHelperInvocation
Bad aggregation op
Test condition and select
: no shortcircuit
true case\n
true case is null\n
false case\n
indirect index
: direct index for structure
vector swizzle
matrix swizzle
subtract
right-shift
left-shift
bitwise and
inclusive-or
exclusive-or
Compare Equal
Compare Not Equal
vector-scale
vector-times-matrix
matrix-times-vector
matrix-scale
matrix-multiply
logical-or
logical-xor
logical-and
<unknown op>
Negate value
Negate conditional
Bitwise not
Post-Increment
Post-Decrement
Pre-Increment
Pre-Decrement
copy object
Convert int8_t to bool
Convert uint8_t to bool
Convert int16_t to bool
Convert uint16_t to bool
Convert int to bool
Convert uint to bool
Convert int64 to bool
Convert uint64 to bool
Convert float16_t to bool
Convert float to bool
Convert double to bool
Convert bool to int8_t
Convert bool to uint8_t
Convert bool to in16t_t
Convert bool to uint16_t
Convert bool to int
Convert bool to uint
Convert bool to int64
Convert bool to uint64
Convert bool to float16_t
Convert bool to float
Convert bool to double
Convert int8_t to int16_t
Convert int8_t to int
Convert int8_t to int64
Convert int8_t to uint8_t
Convert int8_t to uint16_t
Convert int8_t to uint
Convert int8_t to uint64
Convert uint8_t to int8_t
Convert uint8_t to int16_t
Convert uint8_t to int
Convert uint8_t to int64
Convert uint8_t to uint16_t
Convert uint8_t to uint
Convert uint8_t to uint64
Convert int8_t to float16_t
Convert int8_t to float
Convert int8_t to double
Convert uint8_t to float16_t
Convert uint8_t to float
Convert uint8_t to double
Convert int16_t to int8_t
Convert int16_t to int
Convert int16_t to int64
Convert int16_t to uint8_t
Convert int16_t to uint16_t
Convert int16_t to uint
Convert int16_t to uint64
Convert int16_t to float16_t
Convert int16_t to float
Convert int16_t to double
Convert uint16_t to int8_t
Convert uint16_t to int16_t
Convert uint16_t to int
Convert uint16_t to int64
Convert uint16_t to uint8_t
Convert uint16_t to uint
Convert uint16_t to uint64
Convert uint16_t to float16_t
Convert uint16_t to float
Convert uint16_t to double
Convert int to int8_t
Convert int to int16_t
Convert int to int64
Convert int to uint8_t
Convert int to uint16_t
Convert int to uint
Convert int to uint64
Convert int to float16_t
Convert int to float
Convert int to double
Convert uint to int8_t
Convert uint to int16_t
Convert uint to int
Convert uint to int64
Convert uint to uint8_t
Convert uint to uint16_t
Convert uint to uint64
Convert uint to float16_t
Convert uint to float
Convert uint to double
Convert int64 to int8_t
Convert int64 to int16_t
Convert int64 to int
Convert int64 to uint8_t
Convert int64 to uint16_t
Convert int64 to uint
Convert int64 to uint64
Convert int64 to float16_t
Convert int64 to float
Convert int64 to double
Convert uint64 to int8_t
Convert uint64 to int16_t
Convert uint64 to int
Convert uint64 to int64
Convert uint64 to uint8_t
Convert uint64 to uint16
Convert uint64 to uint
Convert uint64 to float16_t
Convert uint64 to float
Convert uint64 to double
Convert float16_t to int8_t
Convert float16_t to int16_t
Convert float16_t to int
Convert float16_t to int64
Convert float16_t to uint8_t
Convert float16_t to uint16_t
Convert float16_t to uint
Convert float16_t to uint64
Convert float16_t to float
Convert float16_t to double
Convert float to float16_t
Convert float to double
Convert float to int8_t
Convert float to int16_t
Convert float to int
Convert float to int64
Convert float to uint8_t
Convert float to uint16_t
Convert float to uint
Convert float to uint64
Convert double to float16_t
Convert double to float
Convert double to int8_t
Convert double to int16_t
Convert double to int
Convert double to int64
Convert double to uint8_t
Convert double to uint16_t
Convert double to uint
Convert double to uint64
Convert uint64_t to pointer
Convert pointer to uint64_t
radians
degrees
arc sine
arc cosine
arc hyp. sine
arc hyp. cosine
arc hyp. tangent
inverse sqrt
Absolute value
Floor
trunc
roundEven
Ceiling
Fraction
isnan
isinf
floatBitsToInt
floatBitsToUint
uintBitsToFloat
doubleBitsToInt64
doubleBitsToUint64
uint64BitsToDouble
float16BitsToInt16
float16BitsToUint16
uint16BitsToFloat16
unpackSnorm2x16
unpackUnorm2x16
unpackHalf2x16
pack64
unpack32
unpack16
unpack8
PackSnorm4x8
UnpackSnorm4x8
PackUnorm4x8
UnpackUnorm4x8
PackDouble2x32
UnpackDouble2x32
unpackInt2x32
unpackUint2x32
unpackInt2x16
unpackUint2x16
unpackInt4x16
unpackUint4x16
unpackFloat2x16
dPdx
dPdy
fwidth
dPdxFine
dPdyFine
fwidthFine
dPdxCoarse
dPdyCoarse
fwidthCoarse
interpolateAtCentroid
determinant
inverse
transpose
array length
EmitStreamVertex
EndStreamPrimitive
AtomicCounterIncrement
AtomicCounterDecrement
bitFieldReverse
bitCount
findLSB
findMSB
noise
readFirstInvocation
anyInvocation
allInvocations
allInvocationsEqual
clip
isfinite
sparseTexelsResident
minInvocations
maxInvocations
addInvocations
minInvocationsNonUniform
maxInvocationsNonUniform
addInvocationsNonUniform
minInvocationsInclusiveScan
maxInvocationsInclusiveScan
addInvocationsInclusiveScan
minInvocationsExclusiveScan
maxInvocationsExclusiveScan
addInvocationsExclusiveScan
mbcnt
fragmentMaskFetchAMD
fragmentFetchAMD
cubeFaceIndex
cubeFaceCoord
Construct reference type
Bad unary op
%-.13e
const bool
-1.#INF
+1.#INF
1.#IND
%d (%s)
const int8_t
%u (%s)
const uint8_t
const int16_t
const uint16_t
const int
const uint
%lld (%s)
const int64_t
%llu (%s)
const uint64_t
Unknown constant
Constant:\n
shading_rate_interlock_ordered
shading_rate_interlock_unordered
gl_FragCoord pixel center is integer\n
gl_FragCoord origin is upper left\n
Construct combined texture-sampler
mageSampleFootprintGradClampNV
DeviceMemoryBarrierWithGroupSync
WorkgroupMemoryBarrierWithGroupSync
subgroupBallotInclusiveBitCount
subgroupBallotExclusiveBitCount
subgroupPartitionedInclusiveAddNV
subgroupPartitionedInclusiveMulNV
subgroupPartitionedInclusiveMinNV
subgroupPartitionedInclusiveMaxNV
subgroupPartitionedInclusiveAndNV
subgroupPartitionedInclusiveOrNV
subgroupPartitionedInclusiveXorNV
subgroupPartitionedExclusiveAddNV
subgroupPartitionedExclusiveMulNV
subgroupPartitionedExclusiveMinNV
subgroupPartitionedExclusiveMaxNV
subgroupPartitionedExclusiveAndNV
subgroupPartitionedExclusiveOrNV
subgroupPartitionedExclusiveXorNV
writePackedPrimitiveIndices4x8NV
move second child to first child
add second child into first child
subtract second child into first child
multiply second child into first child
matrix mult second child into first child
vector scale second child into first child
matrix scale second child into first child
divide second child into first child
mod second child into first child
and second child into first child
or second child into first child
exclusive or second child into first child
left shift second child into first child
right shift second child into first child
minInvocationsInclusiveScanNonUniform
maxInvocationsInclusiveScanNonUniform
addInvocationsInclusiveScanNonUniform
minInvocationsExclusiveScanNonUniform
maxInvocationsExclusiveScanNonUniform
addInvocationsExclusiveScanNonUniform
mBLinking 
 stage: 
Recursion detected:
    
 calling 
Entry point not found
gl_ClipDistance
gl_CullDistance
gl_FragColor
gl_FragData
xfb_stride is too large:
    xfb_buffer 
gl_PositionPerViewNV
gl_ClipDistancePerViewNV
gl_CullDistancePerViewNV
gl_Layer
gl_LayerPerViewNV
gl_ViewportMask
gl_ViewportMaskPerViewNV
Unknown Stage.
, xfb_stride 
, minimum stride needed: 
Initializers must match:
" versus "
Types must match:
Memory qualifiers must match:
Contradictory local size
Contradictory depth layouts
Contradictory xfb_stride
can't handle multiple entry points per stage
when more than one fragment shader output, all must have location qualifiers
No function definition (body) found: 
Missing entry point: Each stage requires one entry point
Only one push_constant block is allowed per stage
Can only use one of gl_ClipDistance or gl_ClipVertex (gl_ClipDistance is preferred)
Can only use one of gl_CullDistance or gl_ClipVertex (gl_ClipDistance is preferred)
Cannot use gl_FragColor or gl_FragData when using user-defined outputs
Cannot use both gl_FragColor and gl_FragData
, components (1/4 stride) needed are 
, gl_MaxTransformFeedbackInterleavedComponents is 
At least one shader must specify an output layout(vertices=...)
At least one shader must specify an input layout primitive
At least one shader must specify an output layout primitive
At least one shader must specify a layout(max_vertices = value)
Only one shaderRecordNV buffer block is allowed per stage
Can only use one of gl_Position or gl_PositionPerViewNV
Can only use one of gl_ClipDistance or gl_ClipDistancePerViewNV
Can only use one of gl_CullDistance or gl_CullDistancePerViewNV
Can only use one of gl_Layer or gl_LayerPerViewNV
Can only use one of gl_ViewportMask or gl_ViewportMaskPerViewNV
At least one shader must specify a layout(max_primitives = value)
Only one taskNV interface block is allowed per shader
xfb_stride is too small to hold all buffer entries:
xfb_stride must be multiple of 8 for buffer holding a double or 64-bit integer:
xfb_stride must be multiple of 4:
xfb_stride must be multiple of 2 for buffer holding a half float or 16-bit integer:
post_depth_coverage requires early_fragment_tests
Storage qualifiers must match:
Precision qualifiers must match:
Presence of invariant qualifier must match:
Presence of precise qualifier must match:
Interpolation and auxiliary storage qualifiers must match:
Layout qualification must match:
Multiple function bodies in multiple compilation units for the same signature in the same stage:
stages must match when linking into a single stage
can't link compilation units from different source languages
Cannot cross link ES and desktop profiles
number of invocations must match between compilation units
Contradictory layout max_vertices values
Contradictory layout vertices values
Contradictory layout max_primitives values
Contradictory input layout primitives
Contradictory output layout primitives
gl_FragCoord redeclarations must match across shaders
Contradictory input vertex spacing
Contradictory triangle ordering
Contradictory local size specialization ids
, counter %d
, numMembers %d
, arrayStride %d
, topLevelArrayStride %d
Uniform reflection:\n
Uniform block reflection:\n
Buffer variable reflection:\n
Buffer block reflection:\n
Pipeline input reflection:\n
Pipeline output reflection:\n
Local size %s: %d\n
basic_string::compare
%s: offset %d, type %x, size %d, index %d, binding %d, stages %d
unexpected
missing #endif
unexpected location
combined tokens are too long
combined token is invalid
string literals not supported
float literal too long
basic_string::erase
unexpected use of
expected 'INF'
double floating-point suffix
half floating-point suffix
hexadecimal literal too big
hexadecimal literal too long
64-bit hexadecimal literal
16-bit hexadecimal literal
numeric literal too long
octal literal digit too large
octal literal too big
64-bit octal literal
16-bit octal literal
64-bit literal
End of input in comment
End of line in string
numeric literal too big
16-bit  literal
16-bit literal
octal and hex sequences not supported
unexpected location; end of argument
not supported for these tokens
unexpected location; end of replacement list
preprocessor directive cannot be preceded by another token
character literals not supported
bad character in float exponent
float literal needs a decimal point or exponent
bad digit in hexadecimal literal
$@mapped binding out of range: 
mapped set out of range: 
Invalid binding: 
Invalid location: 
Invalid shader In/Out variable semantic: 
Invalid shader In/Out variable: 
Invalid In/Out variable type : 
Invalid Uniform variable type : 
(null)
const int  gl_MaxLights = %d;
const int gl_MaxSamples = %d;
highp 
,int);\n
vec2 textureQueryLod(
, float
, float16_t
, vec
int textureQueryLevels(
 textureSize(
int 
textureSamples(
, f16vec
float16_t 
float 
vec4 
sparseTexel
texel
,f16vec4
,vec4
,float16_t,float16_t
,float,float
,f16vec
,vec
,int
,ivec
,out 
,ivec2
coherent volatile 
inout 
vec4 subpassLoad
highp int
highp uint
, ivec
vec4);\n
, float);\n
, out 
, int, int, int, int, int
, int, int, int);\n
void barrier();
void memoryBarrier();
bool helperInvocationEXT();\n
in highp int gl_DeviceIndex;\n
in int gl_DrawID;\n
out float gl_ClipDistance[];
float gl_CullDistance[];
int gl_VertexID;
int gl_InstanceID;
in highp uint gl_ViewID_OVR;\n
out int gl_ViewportIndex;
out vec4 gl_ClipVertex;
in int gl_InvocationID;
vec2 gl_PointCoord;
out int gl_FragStencilRefARB;
vec4 gl_FragColor;
in float gl_ClipDistance[];
flat in int gl_PrimitiveID;
uniform int gl_NumSamples;
vec4 ftransform();
highp float gl_FragDepthEXT;
gl_VertexIndex
gl_InstanceIndex
gl_BaseVertexARB
gl_BaseInstanceARB
gl_DrawIDARB
gl_BaseVertex
gl_BaseInstance
gl_DrawID
gl_SubGroupSizeARB
gl_SubGroupInvocationARB
gl_SubGroupEqMaskARB
gl_SubGroupGeMaskARB
gl_SubGroupGtMaskARB
gl_SubGroupLeMaskARB
gl_SubGroupLtMaskARB
ballotARB
readInvocationARB
readFirstInvocationARB
anyInvocationARB
allInvocationsARB
allInvocationsEqualARB
texture2DGradEXT
texture2DProjGradEXT
textureCubeGradEXT
gl_ViewID_OVR
shadow2DEXT
shadow2DProjEXT
gl_BoundingBoxEXT
gl_BoundingBoxOES
gl_BoundingBox
gl_in
gl_out
gl_PrimitiveIDIn
gl_PrimitiveID
gl_InvocationID
gl_ViewportIndex
gl_SecondaryPositionNV
gl_SecondaryViewportMaskNV
gl_PatchVerticesIn
gl_TessLevelOuter
gl_TessLevelInner
gl_TessCoord
gl_FrontColor
gl_BackColor
gl_FrontSecondaryColor
gl_BackSecondaryColor
gl_TexCoord
gl_FogFragCoord
gl_SubgroupEqMask
gl_SubgroupGeMask
gl_SubgroupGtMask
gl_SubgroupLeMask
gl_SubgroupLtMask
gl_WarpsPerSMNV
gl_SMCountNV
gl_WarpIDNV
gl_SMIDNV
gl_FragDepthEXT
gl_HelperInvocation
gl_FragStencilRefARB
gl_SampleID
gl_SamplePosition
gl_SampleMaskIn
gl_SampleMask
gl_NumSamples
gl_Color
gl_SecondaryColor
texture2DLodEXT
texture2DProjLodEXT
textureCubeLodEXT
dFdx
dFdy
texture1DLod
texture2DLod
texture3DLod
textureCubeLod
texture1DProjLod
texture2DProjLod
texture3DProjLod
shadow1DLod
shadow2DLod
shadow1DProjLod
shadow2DProjLod
texture1DGradARB
texture1DProjGradARB
texture2DGradARB
texture2DProjGradARB
texture3DGradARB
texture3DProjGradARB
textureCubeGradARB
shadow1DGradARB
shadow1DProjGradARB
shadow2DGradARB
shadow2DProjGradARB
texture2DRectGradARB
texture2DRectProjGradARB
shadow2DRectGradARB
shadow2DRectProjGradARB
memoryBarrier
atomicCounterIncrement
atomicCounterDecrement
atomicCounter
dFdxFine
dFdyFine
dFdxCoarse
dFdyCoarse
sparseTextureARB
sparseTextureLodARB
sparseTextureOffsetARB
sparseTexelFetchARB
sparseTexelFetchOffsetARB
sparseTextureLodOffsetARB
sparseTextureGradARB
sparseTextureGradOffsetARB
sparseTextureGatherARB
sparseTextureGatherOffsetARB
sparseTextureGatherOffsetsARB
sparseImageLoadARB
sparseTextureClampARB
sparseTextureOffsetClampARB
sparseTextureGradClampARB
textureClampARB
textureOffsetClampARB
textureGradClampARB
textureGradOffsetClampARB
gl_BaryCoordNoPerspAMD
gl_BaryCoordNoPerspSampleAMD
gl_BaryCoordSmoothAMD
gl_BaryCoordSmoothCentroidAMD
gl_BaryCoordSmoothSampleAMD
gl_BaryCoordPullModelAMD
interpolateAtVertexAMD
textureGatherLodAMD
textureGatherLodOffsetAMD
textureGatherLodOffsetsAMD
sparseTextureGatherLodAMD
imageLoadLodAMD
imageStoreLodAMD
sparseImageLoadLodAMD
gl_FragFullyCoveredNV
gl_FragSizeEXT
gl_FragInvocationCountEXT
clockARB
clock2x32ARB
clockRealtimeEXT
clockRealtime2x32EXT
gl_DeviceIndex
gl_ViewIndex
gl_ScopeDevice
gl_ScopeWorkgroup
gl_ScopeSubgroup
gl_ScopeInvocation
gl_SemanticsRelaxed
gl_SemanticsAcquire
gl_SemanticsRelease
gl_SemanticsAcquireRelease
gl_SemanticsMakeAvailable
gl_SemanticsMakeVisible
gl_SemanticsVolatile
gl_StorageSemanticsNone
gl_StorageSemanticsBuffer
gl_StorageSemanticsShared
gl_StorageSemanticsImage
gl_StorageSemanticsOutput
helperInvocationEXT
gl_NumWorkGroups
gl_WorkGroupSize
gl_WorkGroupID
gl_LocalInvocationID
gl_GlobalInvocationID
gl_LocalInvocationIndex
gl_MaxComputeWorkGroupCount
gl_MaxComputeWorkGroupSize
gl_MaxComputeImageUniforms
gl_MaxComputeAtomicCounters
memoryBarrierAtomicCounter
memoryBarrierBuffer
memoryBarrierImage
memoryBarrierShared
controlBarrier
gl_NumSubgroups
gl_SubgroupID
coopMatLoadNV
coopMatStoreNV
coopMatMulAddNV
gl_LaunchIDNV
gl_LaunchSizeNV
gl_InstanceCustomIndexNV
gl_WorldRayOriginNV
gl_WorldRayDirectionNV
gl_ObjectRayOriginNV
gl_ObjectRayDirectionNV
gl_RayTminNV
gl_RayTmaxNV
gl_HitTNV
gl_HitKindNV
gl_ObjectToWorldNV
gl_WorldToObjectNV
gl_IncomingRayFlagsNV
matrixCompMult
outerProduct
gl_MeshVerticesNV
gl_MeshPrimitivesNV
gl_PrimitiveCountNV
gl_PrimitiveIndicesNV
gl_MeshViewCountNV
gl_MeshViewIndicesNV
gl_MaxMeshOutputVerticesNV
gl_MaxMeshOutputPrimitivesNV
gl_MaxMeshWorkGroupSizeNV
gl_MaxMeshViewCountNV
gl_TaskCountNV
gl_MaxTaskWorkGroupSizeNV
halfBitsToInt16
halfBitsToUint16
uint16BitsToHalf
unpackSnorm4x8
unpackUnorm4x8
unpackDouble2x32
atomicLoad
atomicStore
atomicCounterAdd
atomicCounterSubtract
atomicCounterMin
atomicCounterMax
atomicCounterAnd
atomicCounterOr
atomicCounterXor
atomicCounterExchange
atomicCounterCompSwap
uaddCarry
usubBorrow
umulExtended
imulExtended
bitfieldReverse
imageSize
imageSamples
texelFetch
texelFetchOffset
noise1
noise2
noise3
noise4
textureFootprintNV
textureFootprintClampNV
textureFootprintLodNV
textureFootprintGradNV
textureFootprintGradClampNV
ftransform
texture1DProj
texture2DRectProj
shadow2DRect
shadow2DRectProj
texture2DProj
texture3DProj
shadow1D
shadow2D
shadow1DProj
shadow2DProj
sparseTexelsResidentARB
minInvocationsAMD
maxInvocationsAMD
addInvocationsAMD
minInvocationsNonUniformAMD
maxInvocationsNonUniformAMD
addInvocationsNonUniformAMD
swizzleInvocationsAMD
swizzleInvocationsMaskedAMD
writeInvocationAMD
mbcntAMD
cubeFaceIndexAMD
cubeFaceCoordAMD
timeAMD
beginInvocationInterlockARB
endInvocationInterlockARB
gl_SIMDGroupSizeAMD
gl_FragmentSizeNV
gl_InvocationsPerPixelNV
gl_BaryCoordNV
gl_BaryCoordNoPerspNV
gl_Normal
gl_Vertex
gl_MultiTexCoord0
gl_MultiTexCoord1
gl_MultiTexCoord2
gl_MultiTexCoord3
gl_MultiTexCoord4
gl_MultiTexCoord5
gl_MultiTexCoord6
gl_MultiTexCoord7
gl_FogCoord
gl_MinProgramTexelOffset
gl_MaxProgramTexelOffset
gl_MaxViewports
bool   subgroupAllEqual(%s);\n
%s     subgroupAdd(%s);\n
%s     subgroupMul(%s);\n
%s     subgroupMin(%s);\n
%s     subgroupMax(%s);\n
%s     subgroupAnd(%s);\n
%s     subgroupOr(%s);\n
%s     subgroupXor(%s);\n
asin
acos
atan
inversesqrt
faceforward
cross
lessThan
lessThanEqual
greaterThan
greaterThanEqual
equal
notEqual
asinh
acosh
atanh
atomicAdd
atomicMin
atomicMax
atomicAnd
atomicOr
atomicXor
atomicExchange
atomicCompSwap
const mediump int  gl_MaxVertexAttribs = %d;
const mediump int  gl_MaxVertexUniformVectors = %d;
const mediump int  gl_MaxVertexTextureImageUnits = %d;
const mediump int  gl_MaxCombinedTextureImageUnits = %d;
const mediump int  gl_MaxTextureImageUnits = %d;
const mediump int  gl_MaxFragmentUniformVectors = %d;
const mediump int  gl_MaxDrawBuffers = %d;
const mediump int  gl_MaxVaryingVectors = %d;
const mediump int  gl_MaxVertexOutputVectors = %d;
const mediump int  gl_MaxFragmentInputVectors = %d;
const mediump int  gl_MinProgramTexelOffset = %d;
const mediump int  gl_MaxProgramTexelOffset = %d;
const int gl_MaxGeometryInputComponents = %d;
const int gl_MaxGeometryOutputComponents = %d;
const int gl_MaxGeometryImageUniforms = %d;
const int gl_MaxGeometryTextureImageUnits = %d;
const int gl_MaxGeometryOutputVertices = %d;
const int gl_MaxGeometryTotalOutputComponents = %d;
const int gl_MaxGeometryUniformComponents = %d;
const int gl_MaxGeometryAtomicCounters = %d;
const int gl_MaxGeometryAtomicCounterBuffers = %d;
const int gl_MaxTessControlInputComponents = %d;
const int gl_MaxTessControlOutputComponents = %d;
const int gl_MaxTessControlTextureImageUnits = %d;
const int gl_MaxTessControlUniformComponents = %d;
const int gl_MaxTessControlTotalOutputComponents = %d;
const int gl_MaxTessEvaluationInputComponents = %d;
const int gl_MaxTessEvaluationOutputComponents = %d;
const int gl_MaxTessEvaluationTextureImageUnits = %d;
const int gl_MaxTessEvaluationUniformComponents = %d;
const int gl_MaxTessPatchComponents = %d;
const int gl_MaxPatchVertices = %d;
const int gl_MaxTessGenLevel = %d;
in gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;highp vec4 gl_SecondaryPositionNV;highp vec4 gl_PositionPerViewNV[];} gl_in[gl_MaxPatchVertices];\n
const int  gl_MaxVertexAttribs = %d;
const int  gl_MaxVertexTextureImageUnits = %d;
const int  gl_MaxCombinedTextureImageUnits = %d;
const int  gl_MaxTextureImageUnits = %d;
const int  gl_MaxDrawBuffers = %d;
const int  gl_MaxClipPlanes = %d;
const int  gl_MaxTextureUnits = %d;
const int  gl_MaxTextureCoords = %d;
const int  gl_MaxVertexUniformComponents = %d;
const int  gl_MaxVaryingFloats = %d;
const int  gl_MaxFragmentUniformComponents = %d;
const int gl_MaxClipDistances = %d;
const int gl_MaxVaryingComponents = %d;
const int gl_MaxGeometryVaryingComponents = %d;
const int gl_MaxVertexOutputComponents = %d;
const int gl_MaxFragmentInputComponents = %d;
in gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];
vec4 gl_ClipVertex;vec4 gl_FrontColor;vec4 gl_BackColor;vec4 gl_FrontSecondaryColor;vec4 gl_BackSecondaryColor;vec4 gl_TexCoord[];float gl_FogFragCoord;
float gl_CullDistance[];vec4 gl_SecondaryPositionNV;vec4 gl_PositionPerViewNV[];
} gl_in[gl_MaxPatchVertices];\n
const int gl_MaxCombinedImageUnitsAndFragmentOutputs = %d;
const int gl_MaxImageSamples = %d;
const int gl_MaxTessControlImageUniforms = %d;
const int gl_MaxTessEvaluationImageUniforms = %d;
const int gl_MaxTransformFeedbackBuffers = %d;
const int gl_MaxTransformFeedbackInterleavedComponents = %d;
const int gl_MaxImageUnits = %d;
const int gl_MaxCombinedShaderOutputResources = %d;
const int gl_MaxVertexImageUniforms = %d;
const int gl_MaxFragmentImageUniforms = %d;
const int gl_MaxCombinedImageUniforms = %d;
const int gl_MaxVertexAtomicCounters = %d;
const int gl_MaxFragmentAtomicCounters = %d;
const int gl_MaxCombinedAtomicCounters = %d;
const int gl_MaxAtomicCounterBindings = %d;
const int gl_MaxVertexAtomicCounterBuffers = %d;
const int gl_MaxFragmentAtomicCounterBuffers = %d;
const int gl_MaxCombinedAtomicCounterBuffers = %d;
const int gl_MaxAtomicCounterBufferSize = %d;
const int gl_MaxTessControlAtomicCounters = %d;
const int gl_MaxTessEvaluationAtomicCounters = %d;
const int gl_MaxTessControlAtomicCounterBuffers = %d;
const int gl_MaxTessEvaluationAtomicCounterBuffers = %d;
const ivec3 gl_MaxComputeWorkGroupCount = ivec3(%d,%d,%d);
const ivec3 gl_MaxComputeWorkGroupSize = ivec3(%d,%d,%d);
const int gl_MaxComputeUniformComponents = %d;
const int gl_MaxComputeTextureImageUnits = %d;
const int gl_MaxComputeImageUniforms = %d;
const int gl_MaxComputeAtomicCounters = %d;
const int gl_MaxComputeAtomicCounterBuffers = %d;
const int gl_MaxCullDistances = %d;
const int gl_MaxCombinedClipAndCullDistances = %d;
const int gl_MaxMeshOutputVerticesNV = %d;
const int gl_MaxMeshOutputPrimitivesNV = %d;
const ivec3 gl_MaxMeshWorkGroupSizeNV = ivec3(%d,%d,%d);
const ivec3 gl_MaxTaskWorkGroupSizeNV = ivec3(%d,%d,%d);
const int gl_MaxMeshViewCountNV = %d;
uniform mat4  gl_TextureMatrix[gl_MaxTextureCoords];uniform mat4  gl_TextureMatrixInverse[gl_MaxTextureCoords];uniform mat4  gl_TextureMatrixTranspose[gl_MaxTextureCoords];uniform mat4  gl_TextureMatrixInverseTranspose[gl_MaxTextureCoords];uniform vec4  gl_ClipPlane[gl_MaxClipPlanes];uniform gl_LightSourceParameters  gl_LightSource[gl_MaxLights];uniform gl_LightProducts gl_FrontLightProduct[gl_MaxLights];uniform gl_LightProducts gl_BackLightProduct[gl_MaxLights];uniform vec4  gl_TextureEnvColor[gl_MaxTextureImageUnits];uniform vec4  gl_EyePlaneS[gl_MaxTextureCoords];uniform vec4  gl_EyePlaneT[gl_MaxTextureCoords];uniform vec4  gl_EyePlaneR[gl_MaxTextureCoords];uniform vec4  gl_EyePlaneQ[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneS[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneT[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneR[gl_MaxTextureCoords];uniform vec4  gl_ObjectPlaneQ[gl_MaxTextureCoords];
const int gl_MaxViewports = %d;
 imageSize(readonly writeonly volatile coherent 
imageSamples(readonly writeonly volatile coherent 
vec4 imageLoad(readonly volatile coherent 
void imageStore(writeonly volatile coherent 
float imageAtomicExchange(volatile coherent 
vec4 imageLoadLodAMD(readonly volatile coherent 
void imageStoreLodAMD(writeonly volatile coherent 
int sparseImageLoadLodAMD(readonly volatile coherent 
int sparseImageLoadARB(readonly volatile coherent 
 imageAtomicCompSwap(volatile coherent 
 imageAtomicLoad(volatile coherent 
void imageAtomicStore(volatile coherent 
bool sparseTexelsResidentARB(int code);\n
float dFdxFine(float p);vec2  dFdxFine(vec2  p);vec3  dFdxFine(vec3  p);vec4  dFdxFine(vec4  p);float dFdyFine(float p);vec2  dFdyFine(vec2  p);vec3  dFdyFine(vec3  p);vec4  dFdyFine(vec4  p);float fwidthFine(float p);vec2  fwidthFine(vec2  p);vec3  fwidthFine(vec3  p);vec4  fwidthFine(vec4  p);float dFdxCoarse(float p);vec2  dFdxCoarse(vec2  p);vec3  dFdxCoarse(vec3  p);vec4  dFdxCoarse(vec4  p);float dFdyCoarse(float p);vec2  dFdyCoarse(vec2  p);vec3  dFdyCoarse(vec3  p);vec4  dFdyCoarse(vec4  p);float fwidthCoarse(float p);vec2  fwidthCoarse(vec2  p);vec3  fwidthCoarse(vec3  p);vec4  fwidthCoarse(vec4  p);
float16_t dFdx(float16_t);f16vec2   dFdx(f16vec2);f16vec3   dFdx(f16vec3);f16vec4   dFdx(f16vec4);float16_t dFdy(float16_t);f16vec2   dFdy(f16vec2);f16vec3   dFdy(f16vec3);f16vec4   dFdy(f16vec4);float16_t dFdxFine(float16_t);f16vec2   dFdxFine(f16vec2);f16vec3   dFdxFine(f16vec3);f16vec4   dFdxFine(f16vec4);float16_t dFdyFine(float16_t);f16vec2   dFdyFine(f16vec2);f16vec3   dFdyFine(f16vec3);f16vec4   dFdyFine(f16vec4);float16_t dFdxCoarse(float16_t);f16vec2   dFdxCoarse(f16vec2);f16vec3   dFdxCoarse(f16vec3);f16vec4   dFdxCoarse(f16vec4);float16_t dFdyCoarse(float16_t);f16vec2   dFdyCoarse(f16vec2);f16vec3   dFdyCoarse(f16vec3);f16vec4   dFdyCoarse(f16vec4);float16_t fwidth(float16_t);f16vec2   fwidth(f16vec2);f16vec3   fwidth(f16vec3);f16vec4   fwidth(f16vec4);float16_t fwidthFine(float16_t);f16vec2   fwidthFine(f16vec2);f16vec3   fwidthFine(f16vec3);f16vec4   fwidthFine(f16vec4);float16_t fwidthCoarse(float16_t);f16vec2   fwidthCoarse(f16vec2);f16vec3   fwidthCoarse(f16vec3);f16vec4   fwidthCoarse(f16vec4);
float64_t dFdx(float64_t);f64vec2   dFdx(f64vec2);f64vec3   dFdx(f64vec3);f64vec4   dFdx(f64vec4);float64_t dFdy(float64_t);f64vec2   dFdy(f64vec2);f64vec3   dFdy(f64vec3);f64vec4   dFdy(f64vec4);float64_t dFdxFine(float64_t);f64vec2   dFdxFine(f64vec2);f64vec3   dFdxFine(f64vec3);f64vec4   dFdxFine(f64vec4);float64_t dFdyFine(float64_t);f64vec2   dFdyFine(f64vec2);f64vec3   dFdyFine(f64vec3);f64vec4   dFdyFine(f64vec4);float64_t dFdxCoarse(float64_t);f64vec2   dFdxCoarse(f64vec2);f64vec3   dFdxCoarse(f64vec3);f64vec4   dFdxCoarse(f64vec4);float64_t dFdyCoarse(float64_t);f64vec2   dFdyCoarse(f64vec2);f64vec3   dFdyCoarse(f64vec3);f64vec4   dFdyCoarse(f64vec4);float64_t fwidth(float64_t);f64vec2   fwidth(f64vec2);f64vec3   fwidth(f64vec3);f64vec4   fwidth(f64vec4);float64_t fwidthFine(float64_t);f64vec2   fwidthFine(f64vec2);f64vec3   fwidthFine(f64vec3);f64vec4   fwidthFine(f64vec4);float64_t fwidthCoarse(float64_t);f64vec2   fwidthCoarse(f64vec2);f64vec3   fwidthCoarse(f64vec3);f64vec4   fwidthCoarse(f64vec4);
double sqrt(double);dvec2  sqrt(dvec2);dvec3  sqrt(dvec3);dvec4  sqrt(dvec4);double inversesqrt(double);dvec2  inversesqrt(dvec2);dvec3  inversesqrt(dvec3);dvec4  inversesqrt(dvec4);double abs(double);dvec2  abs(dvec2);dvec3  abs(dvec3);dvec4  abs(dvec4);double sign(double);dvec2  sign(dvec2);dvec3  sign(dvec3);dvec4  sign(dvec4);double floor(double);dvec2  floor(dvec2);dvec3  floor(dvec3);dvec4  floor(dvec4);double trunc(double);dvec2  trunc(dvec2);dvec3  trunc(dvec3);dvec4  trunc(dvec4);double round(double);dvec2  round(dvec2);dvec3  round(dvec3);dvec4  round(dvec4);double roundEven(double);dvec2  roundEven(dvec2);dvec3  roundEven(dvec3);dvec4  roundEven(dvec4);double ceil(double);dvec2  ceil(dvec2);dvec3  ceil(dvec3);dvec4  ceil(dvec4);double fract(double);dvec2  fract(dvec2);dvec3  fract(dvec3);dvec4  fract(dvec4);double mod(double, double);dvec2  mod(dvec2 , double);dvec3  mod(dvec3 , double);dvec4  mod(dvec4 , double);dvec2  mod(dvec2 , dvec2);dvec3  mod(dvec3 , dvec3);dvec4  mod(dvec4 , dvec4);double modf(double, out double);dvec2  modf(dvec2,  out dvec2);dvec3  modf(dvec3,  out dvec3);dvec4  modf(dvec4,  out dvec4);double min(double, double);dvec2  min(dvec2,  double);dvec3  min(dvec3,  double);dvec4  min(dvec4,  double);dvec2  min(dvec2,  dvec2);dvec3  min(dvec3,  dvec3);dvec4  min(dvec4,  dvec4);double max(double, double);dvec2  max(dvec2 , double);dvec3  max(dvec3 , double);dvec4  max(dvec4 , double);dvec2  max(dvec2 , dvec2);dvec3  max(dvec3 , dvec3);dvec4  max(dvec4 , dvec4);double clamp(double, double, double);dvec2  clamp(dvec2 , double, double);dvec3  clamp(dvec3 , double, double);dvec4  clamp(dvec4 , double, double);dvec2  clamp(dvec2 , dvec2 , dvec2);dvec3  clamp(dvec3 , dvec3 , dvec3);dvec4  clamp(dvec4 , dvec4 , dvec4);double mix(double, double, double);dvec2  mix(dvec2,  dvec2,  double);dvec3  mix(dvec3,  dvec3,  double);dvec4  mix(dvec4,  dvec4,  double);dvec2  mix(dvec2,  dvec2,  dvec2);dvec3  mix(dvec3,  dvec3,  dvec3);dvec4  mix(dvec4,  dvec4,  dvec4);double mix(double, double, bool);dvec2  mix(dvec2,  dvec2,  bvec2);dvec3  mix(dvec3,  dvec3,  bvec3);dvec4  mix(dvec4,  dvec4,  bvec4);double step(double, double);dvec2  step(dvec2 , dvec2);dvec3  step(dvec3 , dvec3);dvec4  step(dvec4 , dvec4);dvec2  step(double, dvec2);dvec3  step(double, dvec3);dvec4  step(double, dvec4);double smoothstep(double, double, double);dvec2  smoothstep(dvec2 , dvec2 , dvec2);dvec3  smoothstep(dvec3 , dvec3 , dvec3);dvec4  smoothstep(dvec4 , dvec4 , dvec4);dvec2  smoothstep(double, double, dvec2);dvec3  smoothstep(double, double, dvec3);dvec4  smoothstep(double, double, dvec4);bool  isnan(double);bvec2 isnan(dvec2);bvec3 isnan(dvec3);bvec4 isnan(dvec4);bool  isinf(double);bvec2 isinf(dvec2);bvec3 isinf(dvec3);bvec4 isinf(dvec4);double length(double);double length(dvec2);double length(dvec3);double length(dvec4);double distance(double, double);double distance(dvec2 , dvec2);double distance(dvec3 , dvec3);double distance(dvec4 , dvec4);double dot(double, double);double dot(dvec2 , dvec2);double dot(dvec3 , dvec3);double dot(dvec4 , dvec4);dvec3 cross(dvec3, dvec3);double normalize(double);dvec2  normalize(dvec2);dvec3  normalize(dvec3);dvec4  normalize(dvec4);double faceforward(double, double, double);dvec2  faceforward(dvec2,  dvec2,  dvec2);dvec3  faceforward(dvec3,  dvec3,  dvec3);dvec4  faceforward(dvec4,  dvec4,  dvec4);double reflect(double, double);dvec2  reflect(dvec2 , dvec2 );dvec3  reflect(dvec3 , dvec3 );dvec4  reflect(dvec4 , dvec4 );double refract(double, double, double);dvec2  refract(dvec2 , dvec2 , double);dvec3  refract(dvec3 , dvec3 , double);dvec4  refract(dvec4 , dvec4 , double);dmat2 matrixCompMult(dmat2, dmat2);dmat3 matrixCompMult(dmat3, dmat3);dmat4 matrixCompMult(dmat4, dmat4);dmat2x3 matrixCompMult(dmat2x3, dmat2x3);dmat2x4 matrixCompMult(dmat2x4, dmat2x4);dmat3x2 matrixCompMult(dmat3x2, dmat3x2);dmat3x4 matrixCompMult(dmat3x4, dmat3x4);dmat4x2 matrixCompMult(dmat4x2, dmat4x2);dmat4x3 matrixCompMult(dmat4x3, dmat4x3);dmat2   outerProduct(dvec2, dvec2);dmat3   outerProduct(dvec3, dvec3);dmat4   outerProduct(dvec4, dvec4);dmat2x3 outerProduct(dvec3, dvec2);dmat3x2 outerProduct(dvec2, dvec3);dmat2x4 outerProduct(dvec4, dvec2);dmat4x2 outerProduct(dvec2, dvec4);dmat3x4 outerProduct(dvec4, dvec3);dmat4x3 outerProduct(dvec3, dvec4);dmat2   transpose(dmat2);dmat3   transpose(dmat3);dmat4   transpose(dmat4);dmat2x3 transpose(dmat3x2);dmat3x2 transpose(dmat2x3);dmat2x4 transpose(dmat4x2);dmat4x2 transpose(dmat2x4);dmat3x4 transpose(dmat4x3);dmat4x3 transpose(dmat3x4);double determinant(dmat2);double determinant(dmat3);double determinant(dmat4);dmat2 inverse(dmat2);dmat3 inverse(dmat3);dmat4 inverse(dmat4);bvec2 lessThan(dvec2, dvec2);bvec3 lessThan(dvec3, dvec3);bvec4 lessThan(dvec4, dvec4);bvec2 lessThanEqual(dvec2, dvec2);bvec3 lessThanEqual(dvec3, dvec3);bvec4 lessThanEqual(dvec4, dvec4);bvec2 greaterThan(dvec2, dvec2);bvec3 greaterThan(dvec3, dvec3);bvec4 greaterThan(dvec4, dvec4);bvec2 greaterThanEqual(dvec2, dvec2);bvec3 greaterThanEqual(dvec3, dvec3);bvec4 greaterThanEqual(dvec4, dvec4);bvec2 equal(dvec2, dvec2);bvec3 equal(dvec3, dvec3);bvec4 equal(dvec4, dvec4);bvec2 notEqual(dvec2, dvec2);bvec3 notEqual(dvec3, dvec3);bvec4 notEqual(dvec4, dvec4);\n
int64_t abs(int64_t);i64vec2 abs(i64vec2);i64vec3 abs(i64vec3);i64vec4 abs(i64vec4);int64_t sign(int64_t);i64vec2 sign(i64vec2);i64vec3 sign(i64vec3);i64vec4 sign(i64vec4);int64_t  min(int64_t,  int64_t);i64vec2  min(i64vec2,  int64_t);i64vec3  min(i64vec3,  int64_t);i64vec4  min(i64vec4,  int64_t);i64vec2  min(i64vec2,  i64vec2);i64vec3  min(i64vec3,  i64vec3);i64vec4  min(i64vec4,  i64vec4);uint64_t min(uint64_t, uint64_t);u64vec2  min(u64vec2,  uint64_t);u64vec3  min(u64vec3,  uint64_t);u64vec4  min(u64vec4,  uint64_t);u64vec2  min(u64vec2,  u64vec2);u64vec3  min(u64vec3,  u64vec3);u64vec4  min(u64vec4,  u64vec4);int64_t  max(int64_t,  int64_t);i64vec2  max(i64vec2,  int64_t);i64vec3  max(i64vec3,  int64_t);i64vec4  max(i64vec4,  int64_t);i64vec2  max(i64vec2,  i64vec2);i64vec3  max(i64vec3,  i64vec3);i64vec4  max(i64vec4,  i64vec4);uint64_t max(uint64_t, uint64_t);u64vec2  max(u64vec2,  uint64_t);u64vec3  max(u64vec3,  uint64_t);u64vec4  max(u64vec4,  uint64_t);u64vec2  max(u64vec2,  u64vec2);u64vec3  max(u64vec3,  u64vec3);u64vec4  max(u64vec4,  u64vec4);int64_t  clamp(int64_t,  int64_t,  int64_t);i64vec2  clamp(i64vec2,  int64_t,  int64_t);i64vec3  clamp(i64vec3,  int64_t,  int64_t);i64vec4  clamp(i64vec4,  int64_t,  int64_t);i64vec2  clamp(i64vec2,  i64vec2,  i64vec2);i64vec3  clamp(i64vec3,  i64vec3,  i64vec3);i64vec4  clamp(i64vec4,  i64vec4,  i64vec4);uint64_t clamp(uint64_t, uint64_t, uint64_t);u64vec2  clamp(u64vec2,  uint64_t, uint64_t);u64vec3  clamp(u64vec3,  uint64_t, uint64_t);u64vec4  clamp(u64vec4,  uint64_t, uint64_t);u64vec2  clamp(u64vec2,  u64vec2,  u64vec2);u64vec3  clamp(u64vec3,  u64vec3,  u64vec3);u64vec4  clamp(u64vec4,  u64vec4,  u64vec4);int64_t  mix(int64_t,  int64_t,  bool);i64vec2  mix(i64vec2,  i64vec2,  bvec2);i64vec3  mix(i64vec3,  i64vec3,  bvec3);i64vec4  mix(i64vec4,  i64vec4,  bvec4);uint64_t mix(uint64_t, uint64_t, bool);u64vec2  mix(u64vec2,  u64vec2,  bvec2);u64vec3  mix(u64vec3,  u64vec3,  bvec3);u64vec4  mix(u64vec4,  u64vec4,  bvec4);int64_t doubleBitsToInt64(double);i64vec2 doubleBitsToInt64(dvec2);i64vec3 doubleBitsToInt64(dvec3);i64vec4 doubleBitsToInt64(dvec4);uint64_t doubleBitsToUint64(double);u64vec2  doubleBitsToUint64(dvec2);u64vec3  doubleBitsToUint64(dvec3);u64vec4  doubleBitsToUint64(dvec4);double int64BitsToDouble(int64_t);dvec2  int64BitsToDouble(i64vec2);dvec3  int64BitsToDouble(i64vec3);dvec4  int64BitsToDouble(i64vec4);double uint64BitsToDouble(uint64_t);dvec2  uint64BitsToDouble(u64vec2);dvec3  uint64BitsToDouble(u64vec3);dvec4  uint64BitsToDouble(u64vec4);int64_t  packInt2x32(ivec2);uint64_t packUint2x32(uvec2);ivec2    unpackInt2x32(int64_t);uvec2    unpackUint2x32(uint64_t);bvec2 lessThan(i64vec2, i64vec2);bvec3 lessThan(i64vec3, i64vec3);bvec4 lessThan(i64vec4, i64vec4);bvec2 lessThan(u64vec2, u64vec2);bvec3 lessThan(u64vec3, u64vec3);bvec4 lessThan(u64vec4, u64vec4);bvec2 lessThanEqual(i64vec2, i64vec2);bvec3 lessThanEqual(i64vec3, i64vec3);bvec4 lessThanEqual(i64vec4, i64vec4);bvec2 lessThanEqual(u64vec2, u64vec2);bvec3 lessThanEqual(u64vec3, u64vec3);bvec4 lessThanEqual(u64vec4, u64vec4);bvec2 greaterThan(i64vec2, i64vec2);bvec3 greaterThan(i64vec3, i64vec3);bvec4 greaterThan(i64vec4, i64vec4);bvec2 greaterThan(u64vec2, u64vec2);bvec3 greaterThan(u64vec3, u64vec3);bvec4 greaterThan(u64vec4, u64vec4);bvec2 greaterThanEqual(i64vec2, i64vec2);bvec3 greaterThanEqual(i64vec3, i64vec3);bvec4 greaterThanEqual(i64vec4, i64vec4);bvec2 greaterThanEqual(u64vec2, u64vec2);bvec3 greaterThanEqual(u64vec3, u64vec3);bvec4 greaterThanEqual(u64vec4, u64vec4);bvec2 equal(i64vec2, i64vec2);bvec3 equal(i64vec3, i64vec3);bvec4 equal(i64vec4, i64vec4);bvec2 equal(u64vec2, u64vec2);bvec3 equal(u64vec3, u64vec3);bvec4 equal(u64vec4, u64vec4);bvec2 notEqual(i64vec2, i64vec2);bvec3 notEqual(i64vec3, i64vec3);bvec4 notEqual(i64vec4, i64vec4);bvec2 notEqual(u64vec2, u64vec2);bvec3 notEqual(u64vec3, u64vec3);bvec4 notEqual(u64vec4, u64vec4);int64_t findLSB(int64_t);i64vec2 findLSB(i64vec2);i64vec3 findLSB(i64vec3);i64vec4 findLSB(i64vec4);int64_t findLSB(uint64_t);i64vec2 findLSB(u64vec2);i64vec3 findLSB(u64vec3);i64vec4 findLSB(u64vec4);int64_t findMSB(int64_t);i64vec2 findMSB(i64vec2);i64vec3 findMSB(i64vec3);i64vec4 findMSB(i64vec4);int64_t findMSB(uint64_t);i64vec2 findMSB(u64vec2);i64vec3 findMSB(u64vec3);i64vec4 findMSB(u64vec4);\n
float min3(float, float, float);vec2  min3(vec2,  vec2,  vec2);vec3  min3(vec3,  vec3,  vec3);vec4  min3(vec4,  vec4,  vec4);int   min3(int,   int,   int);ivec2 min3(ivec2, ivec2, ivec2);ivec3 min3(ivec3, ivec3, ivec3);ivec4 min3(ivec4, ivec4, ivec4);uint  min3(uint,  uint,  uint);uvec2 min3(uvec2, uvec2, uvec2);uvec3 min3(uvec3, uvec3, uvec3);uvec4 min3(uvec4, uvec4, uvec4);float max3(float, float, float);vec2  max3(vec2,  vec2,  vec2);vec3  max3(vec3,  vec3,  vec3);vec4  max3(vec4,  vec4,  vec4);int   max3(int,   int,   int);ivec2 max3(ivec2, ivec2, ivec2);ivec3 max3(ivec3, ivec3, ivec3);ivec4 max3(ivec4, ivec4, ivec4);uint  max3(uint,  uint,  uint);uvec2 max3(uvec2, uvec2, uvec2);uvec3 max3(uvec3, uvec3, uvec3);uvec4 max3(uvec4, uvec4, uvec4);float mid3(float, float, float);vec2  mid3(vec2,  vec2,  vec2);vec3  mid3(vec3,  vec3,  vec3);vec4  mid3(vec4,  vec4,  vec4);int   mid3(int,   int,   int);ivec2 mid3(ivec2, ivec2, ivec2);ivec3 mid3(ivec3, ivec3, ivec3);ivec4 mid3(ivec4, ivec4, ivec4);uint  mid3(uint,  uint,  uint);uvec2 mid3(uvec2, uvec2, uvec2);uvec3 mid3(uvec3, uvec3, uvec3);uvec4 mid3(uvec4, uvec4, uvec4);float16_t min3(float16_t, float16_t, float16_t);f16vec2   min3(f16vec2,   f16vec2,   f16vec2);f16vec3   min3(f16vec3,   f16vec3,   f16vec3);f16vec4   min3(f16vec4,   f16vec4,   f16vec4);float16_t max3(float16_t, float16_t, float16_t);f16vec2   max3(f16vec2,   f16vec2,   f16vec2);f16vec3   max3(f16vec3,   f16vec3,   f16vec3);f16vec4   max3(f16vec4,   f16vec4,   f16vec4);float16_t mid3(float16_t, float16_t, float16_t);f16vec2   mid3(f16vec2,   f16vec2,   f16vec2);f16vec3   mid3(f16vec3,   f16vec3,   f16vec3);f16vec4   mid3(f16vec4,   f16vec4,   f16vec4);int16_t   min3(int16_t,   int16_t,   int16_t);i16vec2   min3(i16vec2,   i16vec2,   i16vec2);i16vec3   min3(i16vec3,   i16vec3,   i16vec3);i16vec4   min3(i16vec4,   i16vec4,   i16vec4);int16_t   max3(int16_t,   int16_t,   int16_t);i16vec2   max3(i16vec2,   i16vec2,   i16vec2);i16vec3   max3(i16vec3,   i16vec3,   i16vec3);i16vec4   max3(i16vec4,   i16vec4,   i16vec4);int16_t   mid3(int16_t,   int16_t,   int16_t);i16vec2   mid3(i16vec2,   i16vec2,   i16vec2);i16vec3   mid3(i16vec3,   i16vec3,   i16vec3);i16vec4   mid3(i16vec4,   i16vec4,   i16vec4);uint16_t  min3(uint16_t,  uint16_t,  uint16_t);u16vec2   min3(u16vec2,   u16vec2,   u16vec2);u16vec3   min3(u16vec3,   u16vec3,   u16vec3);u16vec4   min3(u16vec4,   u16vec4,   u16vec4);uint16_t  max3(uint16_t,  uint16_t,  uint16_t);u16vec2   max3(u16vec2,   u16vec2,   u16vec2);u16vec3   max3(u16vec3,   u16vec3,   u16vec3);u16vec4   max3(u16vec4,   u16vec4,   u16vec4);uint16_t  mid3(uint16_t,  uint16_t,  uint16_t);u16vec2   mid3(u16vec2,   u16vec2,   u16vec2);u16vec3   mid3(u16vec3,   u16vec3,   u16vec3);u16vec4   mid3(u16vec4,   u16vec4,   u16vec4);\n
uint atomicAdd(coherent volatile inout uint, uint, int, int, int); int atomicAdd(coherent volatile inout  int,  int, int, int, int);uint atomicMin(coherent volatile inout uint, uint, int, int, int); int atomicMin(coherent volatile inout  int,  int, int, int, int);uint atomicMax(coherent volatile inout uint, uint, int, int, int); int atomicMax(coherent volatile inout  int,  int, int, int, int);uint atomicAnd(coherent volatile inout uint, uint, int, int, int); int atomicAnd(coherent volatile inout  int,  int, int, int, int);uint atomicOr (coherent volatile inout uint, uint, int, int, int); int atomicOr (coherent volatile inout  int,  int, int, int, int);uint atomicXor(coherent volatile inout uint, uint, int, int, int); int atomicXor(coherent volatile inout  int,  int, int, int, int);uint atomicExchange(coherent volatile inout uint, uint, int, int, int); int atomicExchange(coherent volatile inout  int,  int, int, int, int);uint atomicCompSwap(coherent volatile inout uint, uint, uint, int, int, int, int, int); int atomicCompSwap(coherent volatile inout  int,  int,  int, int, int, int, int, int);uint atomicLoad(coherent volatile in uint, int, int, int); int atomicLoad(coherent volatile in  int, int, int, int);void atomicStore(coherent volatile out uint, uint, int, int, int);void atomicStore(coherent volatile out  int,  int, int, int, int);\n
uint64_t atomicMin(coherent volatile inout uint64_t, uint64_t); int64_t atomicMin(coherent volatile inout  int64_t,  int64_t);uint64_t atomicMin(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicMin(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicMax(coherent volatile inout uint64_t, uint64_t); int64_t atomicMax(coherent volatile inout  int64_t,  int64_t);uint64_t atomicMax(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicMax(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicAnd(coherent volatile inout uint64_t, uint64_t); int64_t atomicAnd(coherent volatile inout  int64_t,  int64_t);uint64_t atomicAnd(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicAnd(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicOr (coherent volatile inout uint64_t, uint64_t); int64_t atomicOr (coherent volatile inout  int64_t,  int64_t);uint64_t atomicOr (coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicOr (coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicXor(coherent volatile inout uint64_t, uint64_t); int64_t atomicXor(coherent volatile inout  int64_t,  int64_t);uint64_t atomicXor(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicXor(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicAdd(coherent volatile inout uint64_t, uint64_t); int64_t atomicAdd(coherent volatile inout  int64_t,  int64_t);uint64_t atomicAdd(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicAdd(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicExchange(coherent volatile inout uint64_t, uint64_t); int64_t atomicExchange(coherent volatile inout  int64_t,  int64_t);uint64_t atomicExchange(coherent volatile inout uint64_t, uint64_t, int, int, int); int64_t atomicExchange(coherent volatile inout  int64_t,  int64_t, int, int, int);uint64_t atomicCompSwap(coherent volatile inout uint64_t, uint64_t, uint64_t); int64_t atomicCompSwap(coherent volatile inout  int64_t,  int64_t,  int64_t);uint64_t atomicCompSwap(coherent volatile inout uint64_t, uint64_t, uint64_t, int, int, int, int, int); int64_t atomicCompSwap(coherent volatile inout  int64_t,  int64_t,  int64_t, int, int, int, int, int);uint64_t atomicLoad(coherent volatile in uint64_t, int, int, int); int64_t atomicLoad(coherent volatile in  int64_t, int, int, int);void atomicStore(coherent volatile out uint64_t, uint64_t, int, int, int);void atomicStore(coherent volatile out  int64_t,  int64_t, int, int, int);\n
int   floatBitsToInt(highp float value);ivec2 floatBitsToInt(highp vec2  value);ivec3 floatBitsToInt(highp vec3  value);ivec4 floatBitsToInt(highp vec4  value);uint  floatBitsToUint(highp float value);uvec2 floatBitsToUint(highp vec2  value);uvec3 floatBitsToUint(highp vec3  value);uvec4 floatBitsToUint(highp vec4  value);float intBitsToFloat(highp int   value);vec2  intBitsToFloat(highp ivec2 value);vec3  intBitsToFloat(highp ivec3 value);vec4  intBitsToFloat(highp ivec4 value);float uintBitsToFloat(highp uint  value);vec2  uintBitsToFloat(highp uvec2 value);vec3  uintBitsToFloat(highp uvec3 value);vec4  uintBitsToFloat(highp uvec4 value);\n
double frexp(double, out int);dvec2  frexp( dvec2, out ivec2);dvec3  frexp( dvec3, out ivec3);dvec4  frexp( dvec4, out ivec4);double ldexp(double, int);dvec2  ldexp( dvec2, ivec2);dvec3  ldexp( dvec3, ivec3);dvec4  ldexp( dvec4, ivec4);double packDouble2x32(uvec2);uvec2 unpackDouble2x32(double);\n
mat2 matrixCompMult(mat2 x, mat2 y);mat3 matrixCompMult(mat3 x, mat3 y);mat4 matrixCompMult(mat4 x, mat4 y);\n
mat2   outerProduct(vec2 c, vec2 r);mat3   outerProduct(vec3 c, vec3 r);mat4   outerProduct(vec4 c, vec4 r);mat2x3 outerProduct(vec3 c, vec2 r);mat3x2 outerProduct(vec2 c, vec3 r);mat2x4 outerProduct(vec4 c, vec2 r);mat4x2 outerProduct(vec2 c, vec4 r);mat3x4 outerProduct(vec4 c, vec3 r);mat4x3 outerProduct(vec3 c, vec4 r);mat2   transpose(mat2   m);mat3   transpose(mat3   m);mat4   transpose(mat4   m);mat2x3 transpose(mat3x2 m);mat3x2 transpose(mat2x3 m);mat2x4 transpose(mat4x2 m);mat4x2 transpose(mat2x4 m);mat3x4 transpose(mat4x3 m);mat4x3 transpose(mat3x4 m);mat2x3 matrixCompMult(mat2x3, mat2x3);mat2x4 matrixCompMult(mat2x4, mat2x4);mat3x2 matrixCompMult(mat3x2, mat3x2);mat3x4 matrixCompMult(mat3x4, mat3x4);mat4x2 matrixCompMult(mat4x2, mat4x2);mat4x3 matrixCompMult(mat4x3, mat4x3);\n
float determinant(mat2 m);float determinant(mat3 m);float determinant(mat4 m);mat2 inverse(mat2 m);mat3 inverse(mat3 m);mat4 inverse(mat4 m);\n
vec4 texture2D(sampler2D, vec2);vec4 texture2DProj(sampler2D, vec3);vec4 texture2DProj(sampler2D, vec4);vec4 texture3D(sampler3D, vec3);vec4 texture3DProj(sampler3D, vec4);vec4 textureCube(samplerCube, vec3);\n
vec4 texture1D(sampler1D, float);vec4 texture1DProj(sampler1D, vec2);vec4 texture1DProj(sampler1D, vec4);vec4 shadow1D(sampler1DShadow, vec3);vec4 shadow2D(sampler2DShadow, vec3);vec4 shadow1DProj(sampler1DShadow, vec4);vec4 shadow2DProj(sampler2DShadow, vec4);vec4 texture2DRect(sampler2DRect, vec2);vec4 texture2DRectProj(sampler2DRect, vec3);vec4 texture2DRectProj(sampler2DRect, vec4);vec4 shadow2DRect(sampler2DRectShadow, vec3);vec4 shadow2DRectProj(sampler2DRectShadow, vec4);\n
vec4 texture2D(samplerExternalOES, vec2 coord);vec4 texture2DProj(samplerExternalOES, vec3);vec4 texture2DProj(samplerExternalOES, vec4);\n
highp ivec2 textureSize(samplerExternalOES, int lod);vec4 texture(samplerExternalOES, vec2);vec4 texture(samplerExternalOES, vec2, float bias);vec4 textureProj(samplerExternalOES, vec3);vec4 textureProj(samplerExternalOES, vec3, float bias);vec4 textureProj(samplerExternalOES, vec4);vec4 textureProj(samplerExternalOES, vec4, float bias);vec4 texelFetch(samplerExternalOES, ivec2, int lod);\n
highp ivec2 textureSize(__samplerExternal2DY2YEXT, int lod);vec4 texture(__samplerExternal2DY2YEXT, vec2);vec4 texture(__samplerExternal2DY2YEXT, vec2, float bias);vec4 textureProj(__samplerExternal2DY2YEXT, vec3);vec4 textureProj(__samplerExternal2DY2YEXT, vec3, float bias);vec4 textureProj(__samplerExternal2DY2YEXT, vec4);vec4 textureProj(__samplerExternal2DY2YEXT, vec4, float bias);vec4 texelFetch(__samplerExternal2DY2YEXT sampler, ivec2, int lod);\n
vec4 texture2DGradEXT(sampler2D, vec2, vec2, vec2);vec4 texture2DProjGradEXT(sampler2D, vec3, vec2, vec2);vec4 texture2DProjGradEXT(sampler2D, vec4, vec2, vec2);vec4 textureCubeGradEXT(samplerCube, vec3, vec3, vec3);float shadow2DEXT(sampler2DShadow, vec3);float shadow2DProjEXT(sampler2DShadow, vec4);\n
float noise1(float x);float noise1(vec2  x);float noise1(vec3  x);float noise1(vec4  x);vec2 noise2(float x);vec2 noise2(vec2  x);vec2 noise2(vec3  x);vec2 noise2(vec4  x);vec3 noise3(float x);vec3 noise3(vec2  x);vec3 noise3(vec3  x);vec3 noise3(vec4  x);vec4 noise4(float x);vec4 noise4(vec2  x);vec4 noise4(vec3  x);vec4 noise4(vec4  x);\n
uint atomicCounterIncrement(atomic_uint);uint atomicCounterDecrement(atomic_uint);uint atomicCounter(atomic_uint);\n
uint atomicCounterAdd(atomic_uint, uint);uint atomicCounterSubtract(atomic_uint, uint);uint atomicCounterMin(atomic_uint, uint);uint atomicCounterMax(atomic_uint, uint);uint atomicCounterAnd(atomic_uint, uint);uint atomicCounterOr(atomic_uint, uint);uint atomicCounterXor(atomic_uint, uint);uint atomicCounterExchange(atomic_uint, uint);uint atomicCounterCompSwap(atomic_uint, uint, uint);\n
  int findLSB(  int);ivec2 findLSB(ivec2);ivec3 findLSB(ivec3);ivec4 findLSB(ivec4);  int findLSB( uint);ivec2 findLSB(uvec2);ivec3 findLSB(uvec3);ivec4 findLSB(uvec4);\n
  int bitCount(  int);ivec2 bitCount(ivec2);ivec3 bitCount(ivec3);ivec4 bitCount(ivec4);  int bitCount( uint);ivec2 bitCount(uvec2);ivec3 bitCount(uvec3);ivec4 bitCount(uvec4);  int findMSB(highp   int);ivec2 findMSB(highp ivec2);ivec3 findMSB(highp ivec3);ivec4 findMSB(highp ivec4);  int findMSB(highp  uint);ivec2 findMSB(highp uvec2);ivec3 findMSB(highp uvec3);ivec4 findMSB(highp uvec4);\n
uint64_t ballotARB(bool);float readInvocationARB(float, uint);vec2  readInvocationARB(vec2,  uint);vec3  readInvocationARB(vec3,  uint);vec4  readInvocationARB(vec4,  uint);int   readInvocationARB(int,   uint);ivec2 readInvocationARB(ivec2, uint);ivec3 readInvocationARB(ivec3, uint);ivec4 readInvocationARB(ivec4, uint);uint  readInvocationARB(uint,  uint);uvec2 readInvocationARB(uvec2, uint);uvec3 readInvocationARB(uvec3, uint);uvec4 readInvocationARB(uvec4, uint);float readFirstInvocationARB(float);vec2  readFirstInvocationARB(vec2);vec3  readFirstInvocationARB(vec3);vec4  readFirstInvocationARB(vec4);int   readFirstInvocationARB(int);ivec2 readFirstInvocationARB(ivec2);ivec3 readFirstInvocationARB(ivec3);ivec4 readFirstInvocationARB(ivec4);uint  readFirstInvocationARB(uint);uvec2 readFirstInvocationARB(uvec2);uvec3 readFirstInvocationARB(uvec3);uvec4 readFirstInvocationARB(uvec4);\n
bool anyInvocationARB(bool);bool allInvocationsARB(bool);bool allInvocationsEqualARB(bool);\n
void subgroupBarrier();void subgroupMemoryBarrier();void subgroupMemoryBarrierBuffer();void subgroupMemoryBarrierImage();bool subgroupElect();bool   subgroupAll(bool);\nbool   subgroupAny(bool);\nuvec4  subgroupBallot(bool);\nbool   subgroupInverseBallot(uvec4);\nbool   subgroupBallotBitExtract(uvec4, uint);\nuint   subgroupBallotBitCount(uvec4);\nuint   subgroupBallotInclusiveBitCount(uvec4);\nuint   subgroupBallotExclusiveBitCount(uvec4);\nuint   subgroupBallotFindLSB(uvec4);\nuint   subgroupBallotFindMSB(uvec4);\n
void subgroupMemoryBarrierShared();\n
bool anyInvocation(bool);bool allInvocations(bool);bool allInvocationsEqual(bool);\n
float minInvocationsAMD(float);vec2  minInvocationsAMD(vec2);vec3  minInvocationsAMD(vec3);vec4  minInvocationsAMD(vec4);int   minInvocationsAMD(int);ivec2 minInvocationsAMD(ivec2);ivec3 minInvocationsAMD(ivec3);ivec4 minInvocationsAMD(ivec4);uint  minInvocationsAMD(uint);uvec2 minInvocationsAMD(uvec2);uvec3 minInvocationsAMD(uvec3);uvec4 minInvocationsAMD(uvec4);double minInvocationsAMD(double);dvec2  minInvocationsAMD(dvec2);dvec3  minInvocationsAMD(dvec3);dvec4  minInvocationsAMD(dvec4);int64_t minInvocationsAMD(int64_t);i64vec2 minInvocationsAMD(i64vec2);i64vec3 minInvocationsAMD(i64vec3);i64vec4 minInvocationsAMD(i64vec4);uint64_t minInvocationsAMD(uint64_t);u64vec2  minInvocationsAMD(u64vec2);u64vec3  minInvocationsAMD(u64vec3);u64vec4  minInvocationsAMD(u64vec4);float16_t minInvocationsAMD(float16_t);f16vec2   minInvocationsAMD(f16vec2);f16vec3   minInvocationsAMD(f16vec3);f16vec4   minInvocationsAMD(f16vec4);int16_t minInvocationsAMD(int16_t);i16vec2 minInvocationsAMD(i16vec2);i16vec3 minInvocationsAMD(i16vec3);i16vec4 minInvocationsAMD(i16vec4);uint16_t minInvocationsAMD(uint16_t);u16vec2  minInvocationsAMD(u16vec2);u16vec3  minInvocationsAMD(u16vec3);u16vec4  minInvocationsAMD(u16vec4);float minInvocationsInclusiveScanAMD(float);vec2  minInvocationsInclusiveScanAMD(vec2);vec3  minInvocationsInclusiveScanAMD(vec3);vec4  minInvocationsInclusiveScanAMD(vec4);int   minInvocationsInclusiveScanAMD(int);ivec2 minInvocationsInclusiveScanAMD(ivec2);ivec3 minInvocationsInclusiveScanAMD(ivec3);ivec4 minInvocationsInclusiveScanAMD(ivec4);uint  minInvocationsInclusiveScanAMD(uint);uvec2 minInvocationsInclusiveScanAMD(uvec2);uvec3 minInvocationsInclusiveScanAMD(uvec3);uvec4 minInvocationsInclusiveScanAMD(uvec4);double minInvocationsInclusiveScanAMD(double);dvec2  minInvocationsInclusiveScanAMD(dvec2);dvec3  minInvocationsInclusiveScanAMD(dvec3);dvec4  minInvocationsInclusiveScanAMD(dvec4);int64_t minInvocationsInclusiveScanAMD(int64_t);i64vec2 minInvocationsInclusiveScanAMD(i64vec2);i64vec3 minInvocationsInclusiveScanAMD(i64vec3);i64vec4 minInvocationsInclusiveScanAMD(i64vec4);uint64_t minInvocationsInclusiveScanAMD(uint64_t);u64vec2  minInvocationsInclusiveScanAMD(u64vec2);u64vec3  minInvocationsInclusiveScanAMD(u64vec3);u64vec4  minInvocationsInclusiveScanAMD(u64vec4);float16_t minInvocationsInclusiveScanAMD(float16_t);f16vec2   minInvocationsInclusiveScanAMD(f16vec2);f16vec3   minInvocationsInclusiveScanAMD(f16vec3);f16vec4   minInvocationsInclusiveScanAMD(f16vec4);int16_t minInvocationsInclusiveScanAMD(int16_t);i16vec2 minInvocationsInclusiveScanAMD(i16vec2);i16vec3 minInvocationsInclusiveScanAMD(i16vec3);i16vec4 minInvocationsInclusiveScanAMD(i16vec4);uint16_t minInvocationsInclusiveScanAMD(uint16_t);u16vec2  minInvocationsInclusiveScanAMD(u16vec2);u16vec3  minInvocationsInclusiveScanAMD(u16vec3);u16vec4  minInvocationsInclusiveScanAMD(u16vec4);float minInvocationsExclusiveScanAMD(float);vec2  minInvocationsExclusiveScanAMD(vec2);vec3  minInvocationsExclusiveScanAMD(vec3);vec4  minInvocationsExclusiveScanAMD(vec4);int   minInvocationsExclusiveScanAMD(int);ivec2 minInvocationsExclusiveScanAMD(ivec2);ivec3 minInvocationsExclusiveScanAMD(ivec3);ivec4 minInvocationsExclusiveScanAMD(ivec4);uint  minInvocationsExclusiveScanAMD(uint);uvec2 minInvocationsExclusiveScanAMD(uvec2);uvec3 minInvocationsExclusiveScanAMD(uvec3);uvec4 minInvocationsExclusiveScanAMD(uvec4);double minInvocationsExclusiveScanAMD(double);dvec2  minInvocationsExclusiveScanAMD(dvec2);dvec3  minInvocationsExclusiveScanAMD(dvec3);dvec4  minInvocationsExclusiveScanAMD(dvec4);int64_t minInvocationsExclusiveScanAMD(int64_t);i64vec2 minInvocationsExclusiveScanAMD(i64vec2);i64vec3 minInvocationsExclusiveScanAMD(i64vec3);i64vec4 minInvocationsExclusiveScanAMD(i64vec4);uint64_t minInvocationsExclusiveScanAMD(uint64_t);u64vec2  minInvocationsExclusiveScanAMD(u64vec2);u64vec3  minInvocationsExclusiveScanAMD(u64vec3);u64vec4  minInvocationsExclusiveScanAMD(u64vec4);float16_t minInvocationsExclusiveScanAMD(float16_t);f16vec2   minInvocationsExclusiveScanAMD(f16vec2);f16vec3   minInvocationsExclusiveScanAMD(f16vec3);f16vec4   minInvocationsExclusiveScanAMD(f16vec4);int16_t minInvocationsExclusiveScanAMD(int16_t);i16vec2 minInvocationsExclusiveScanAMD(i16vec2);i16vec3 minInvocationsExclusiveScanAMD(i16vec3);i16vec4 minInvocationsExclusiveScanAMD(i16vec4);uint16_t minInvocationsExclusiveScanAMD(uint16_t);u16vec2  minInvocationsExclusiveScanAMD(u16vec2);u16vec3  minInvocationsExclusiveScanAMD(u16vec3);u16vec4  minInvocationsExclusiveScanAMD(u16vec4);float maxInvocationsAMD(float);vec2  maxInvocationsAMD(vec2);vec3  maxInvocationsAMD(vec3);vec4  maxInvocationsAMD(vec4);int   maxInvocationsAMD(int);ivec2 maxInvocationsAMD(ivec2);ivec3 maxInvocationsAMD(ivec3);ivec4 maxInvocationsAMD(ivec4);uint  maxInvocationsAMD(uint);uvec2 maxInvocationsAMD(uvec2);uvec3 maxInvocationsAMD(uvec3);uvec4 maxInvocationsAMD(uvec4);double maxInvocationsAMD(double);dvec2  maxInvocationsAMD(dvec2);dvec3  maxInvocationsAMD(dvec3);dvec4  maxInvocationsAMD(dvec4);int64_t maxInvocationsAMD(int64_t);i64vec2 maxInvocationsAMD(i64vec2);i64vec3 maxInvocationsAMD(i64vec3);i64vec4 maxInvocationsAMD(i64vec4);uint64_t maxInvocationsAMD(uint64_t);u64vec2  maxInvocationsAMD(u64vec2);u64vec3  maxInvocationsAMD(u64vec3);u64vec4  maxInvocationsAMD(u64vec4);float16_t maxInvocationsAMD(float16_t);f16vec2   maxInvocationsAMD(f16vec2);f16vec3   maxInvocationsAMD(f16vec3);f16vec4   maxInvocationsAMD(f16vec4);int16_t maxInvocationsAMD(int16_t);i16vec2 maxInvocationsAMD(i16vec2);i16vec3 maxInvocationsAMD(i16vec3);i16vec4 maxInvocationsAMD(i16vec4);uint16_t maxInvocationsAMD(uint16_t);u16vec2  maxInvocationsAMD(u16vec2);u16vec3  maxInvocationsAMD(u16vec3);u16vec4  maxInvocationsAMD(u16vec4);float maxInvocationsInclusiveScanAMD(float);vec2  maxInvocationsInclusiveScanAMD(vec2);vec3  maxInvocationsInclusiveScanAMD(vec3);vec4  maxInvocationsInclusiveScanAMD(vec4);int   maxInvocationsInclusiveScanAMD(int);ivec2 maxInvocationsInclusiveScanAMD(ivec2);ivec3 maxInvocationsInclusiveScanAMD(ivec3);ivec4 maxInvocationsInclusiveScanAMD(ivec4);uint  maxInvocationsInclusiveScanAMD(uint);uvec2 maxInvocationsInclusiveScanAMD(uvec2);uvec3 maxInvocationsInclusiveScanAMD(uvec3);uvec4 maxInvocationsInclusiveScanAMD(uvec4);double maxInvocationsInclusiveScanAMD(double);dvec2  maxInvocationsInclusiveScanAMD(dvec2);dvec3  maxInvocationsInclusiveScanAMD(dvec3);dvec4  maxInvocationsInclusiveScanAMD(dvec4);int64_t maxInvocationsInclusiveScanAMD(int64_t);i64vec2 maxInvocationsInclusiveScanAMD(i64vec2);i64vec3 maxInvocationsInclusiveScanAMD(i64vec3);i64vec4 maxInvocationsInclusiveScanAMD(i64vec4);uint64_t maxInvocationsInclusiveScanAMD(uint64_t);u64vec2  maxInvocationsInclusiveScanAMD(u64vec2);u64vec3  maxInvocationsInclusiveScanAMD(u64vec3);u64vec4  maxInvocationsInclusiveScanAMD(u64vec4);float16_t maxInvocationsInclusiveScanAMD(float16_t);f16vec2   maxInvocationsInclusiveScanAMD(f16vec2);f16vec3   maxInvocationsInclusiveScanAMD(f16vec3);f16vec4   maxInvocationsInclusiveScanAMD(f16vec4);int16_t maxInvocationsInclusiveScanAMD(int16_t);i16vec2 maxInvocationsInclusiveScanAMD(i16vec2);i16vec3 maxInvocationsInclusiveScanAMD(i16vec3);i16vec4 maxInvocationsInclusiveScanAMD(i16vec4);uint16_t maxInvocationsInclusiveScanAMD(uint16_t);u16vec2  maxInvocationsInclusiveScanAMD(u16vec2);u16vec3  maxInvocationsInclusiveScanAMD(u16vec3);u16vec4  maxInvocationsInclusiveScanAMD(u16vec4);float maxInvocationsExclusiveScanAMD(float);vec2  maxInvocationsExclusiveScanAMD(vec2);vec3  maxInvocationsExclusiveScanAMD(vec3);vec4  maxInvocationsExclusiveScanAMD(vec4);int   maxInvocationsExclusiveScanAMD(int);ivec2 maxInvocationsExclusiveScanAMD(ivec2);ivec3 maxInvocationsExclusiveScanAMD(ivec3);ivec4 maxInvocationsExclusiveScanAMD(ivec4);uint  maxInvocationsExclusiveScanAMD(uint);uvec2 maxInvocationsExclusiveScanAMD(uvec2);uvec3 maxInvocationsExclusiveScanAMD(uvec3);uvec4 maxInvocationsExclusiveScanAMD(uvec4);double maxInvocationsExclusiveScanAMD(double);dvec2  maxInvocationsExclusiveScanAMD(dvec2);dvec3  maxInvocationsExclusiveScanAMD(dvec3);dvec4  maxInvocationsExclusiveScanAMD(dvec4);int64_t maxInvocationsExclusiveScanAMD(int64_t);i64vec2 maxInvocationsExclusiveScanAMD(i64vec2);i64vec3 maxInvocationsExclusiveScanAMD(i64vec3);i64vec4 maxInvocationsExclusiveScanAMD(i64vec4);uint64_t maxInvocationsExclusiveScanAMD(uint64_t);u64vec2  maxInvocationsExclusiveScanAMD(u64vec2);u64vec3  maxInvocationsExclusiveScanAMD(u64vec3);u64vec4  maxInvocationsExclusiveScanAMD(u64vec4);float16_t maxInvocationsExclusiveScanAMD(float16_t);f16vec2   maxInvocationsExclusiveScanAMD(f16vec2);f16vec3   maxInvocationsExclusiveScanAMD(f16vec3);f16vec4   maxInvocationsExclusiveScanAMD(f16vec4);int16_t maxInvocationsExclusiveScanAMD(int16_t);i16vec2 maxInvocationsExclusiveScanAMD(i16vec2);i16vec3 maxInvocationsExclusiveScanAMD(i16vec3);i16vec4 maxInvocationsExclusiveScanAMD(i16vec4);uint16_t maxInvocationsExclusiveScanAMD(uint16_t);u16vec2  maxInvocationsExclusiveScanAMD(u16vec2);u16vec3  maxInvocationsExclusiveScanAMD(u16vec3);u16vec4  maxInvocationsExclusiveScanAMD(u16vec4);float addInvocationsAMD(float);vec2  addInvocationsAMD(vec2);vec3  addInvocationsAMD(vec3);vec4  addInvocationsAMD(vec4);int   addInvocationsAMD(int);ivec2 addInvocationsAMD(ivec2);ivec3 addInvocationsAMD(ivec3);ivec4 addInvocationsAMD(ivec4);uint  addInvocationsAMD(uint);uvec2 addInvocationsAMD(uvec2);uvec3 addInvocationsAMD(uvec3);uvec4 addInvocationsAMD(uvec4);double  addInvocationsAMD(double);dvec2   addInvocationsAMD(dvec2);dvec3   addInvocationsAMD(dvec3);dvec4   addInvocationsAMD(dvec4);int64_t addInvocationsAMD(int64_t);i64vec2 addInvocationsAMD(i64vec2);i64vec3 addInvocationsAMD(i64vec3);i64vec4 addInvocationsAMD(i64vec4);uint64_t addInvocationsAMD(uint64_t);u64vec2  addInvocationsAMD(u64vec2);u64vec3  addInvocationsAMD(u64vec3);u64vec4  addInvocationsAMD(u64vec4);float16_t addInvocationsAMD(float16_t);f16vec2   addInvocationsAMD(f16vec2);f16vec3   addInvocationsAMD(f16vec3);f16vec4   addInvocationsAMD(f16vec4);int16_t addInvocationsAMD(int16_t);i16vec2 addInvocationsAMD(i16vec2);i16vec3 addInvocationsAMD(i16vec3);i16vec4 addInvocationsAMD(i16vec4);uint16_t addInvocationsAMD(uint16_t);u16vec2  addInvocationsAMD(u16vec2);u16vec3  addInvocationsAMD(u16vec3);u16vec4  addInvocationsAMD(u16vec4);float addInvocationsInclusiveScanAMD(float);vec2  addInvocationsInclusiveScanAMD(vec2);vec3  addInvocationsInclusiveScanAMD(vec3);vec4  addInvocationsInclusiveScanAMD(vec4);int   addInvocationsInclusiveScanAMD(int);ivec2 addInvocationsInclusiveScanAMD(ivec2);ivec3 addInvocationsInclusiveScanAMD(ivec3);ivec4 addInvocationsInclusiveScanAMD(ivec4);uint  addInvocationsInclusiveScanAMD(uint);uvec2 addInvocationsInclusiveScanAMD(uvec2);uvec3 addInvocationsInclusiveScanAMD(uvec3);uvec4 addInvocationsInclusiveScanAMD(uvec4);double  addInvocationsInclusiveScanAMD(double);dvec2   addInvocationsInclusiveScanAMD(dvec2);dvec3   addInvocationsInclusiveScanAMD(dvec3);dvec4   addInvocationsInclusiveScanAMD(dvec4);int64_t addInvocationsInclusiveScanAMD(int64_t);i64vec2 addInvocationsInclusiveScanAMD(i64vec2);i64vec3 addInvocationsInclusiveScanAMD(i64vec3);i64vec4 addInvocationsInclusiveScanAMD(i64vec4);uint64_t addInvocationsInclusiveScanAMD(uint64_t);u64vec2  addInvocationsInclusiveScanAMD(u64vec2);u64vec3  addInvocationsInclusiveScanAMD(u64vec3);u64vec4  addInvocationsInclusiveScanAMD(u64vec4);float16_t addInvocationsInclusiveScanAMD(float16_t);f16vec2   addInvocationsInclusiveScanAMD(f16vec2);f16vec3   addInvocationsInclusiveScanAMD(f16vec3);f16vec4   addInvocationsInclusiveScanAMD(f16vec4);int16_t addInvocationsInclusiveScanAMD(int16_t);i16vec2 addInvocationsInclusiveScanAMD(i16vec2);i16vec3 addInvocationsInclusiveScanAMD(i16vec3);i16vec4 addInvocationsInclusiveScanAMD(i16vec4);uint16_t addInvocationsInclusiveScanAMD(uint16_t);u16vec2  addInvocationsInclusiveScanAMD(u16vec2);u16vec3  addInvocationsInclusiveScanAMD(u16vec3);u16vec4  addInvocationsInclusiveScanAMD(u16vec4);float addInvocationsExclusiveScanAMD(float);vec2  addInvocationsExclusiveScanAMD(vec2);vec3  addInvocationsExclusiveScanAMD(vec3);vec4  addInvocationsExclusiveScanAMD(vec4);int   addInvocationsExclusiveScanAMD(int);ivec2 addInvocationsExclusiveScanAMD(ivec2);ivec3 addInvocationsExclusiveScanAMD(ivec3);ivec4 addInvocationsExclusiveScanAMD(ivec4);uint  addInvocationsExclusiveScanAMD(uint);uvec2 addInvocationsExclusiveScanAMD(uvec2);uvec3 addInvocationsExclusiveScanAMD(uvec3);uvec4 addInvocationsExclusiveScanAMD(uvec4);double  addInvocationsExclusiveScanAMD(double);dvec2   addInvocationsExclusiveScanAMD(dvec2);dvec3   addInvocationsExclusiveScanAMD(dvec3);dvec4   addInvocationsExclusiveScanAMD(dvec4);int64_t addInvocationsExclusiveScanAMD(int64_t);i64vec2 addInvocationsExclusiveScanAMD(i64vec2);i64vec3 addInvocationsExclusiveScanAMD(i64vec3);i64vec4 addInvocationsExclusiveScanAMD(i64vec4);uint64_t addInvocationsExclusiveScanAMD(uint64_t);u64vec2  addInvocationsExclusiveScanAMD(u64vec2);u64vec3  addInvocationsExclusiveScanAMD(u64vec3);u64vec4  addInvocationsExclusiveScanAMD(u64vec4);float16_t addInvocationsExclusiveScanAMD(float16_t);f16vec2   addInvocationsExclusiveScanAMD(f16vec2);f16vec3   addInvocationsExclusiveScanAMD(f16vec3);f16vec4   addInvocationsExclusiveScanAMD(f16vec4);int16_t addInvocationsExclusiveScanAMD(int16_t);i16vec2 addInvocationsExclusiveScanAMD(i16vec2);i16vec3 addInvocationsExclusiveScanAMD(i16vec3);i16vec4 addInvocationsExclusiveScanAMD(i16vec4);uint16_t addInvocationsExclusiveScanAMD(uint16_t);u16vec2  addInvocationsExclusiveScanAMD(u16vec2);u16vec3  addInvocationsExclusiveScanAMD(u16vec3);u16vec4  addInvocationsExclusiveScanAMD(u16vec4);float minInvocationsNonUniformAMD(float);vec2  minInvocationsNonUniformAMD(vec2);vec3  minInvocationsNonUniformAMD(vec3);vec4  minInvocationsNonUniformAMD(vec4);int   minInvocationsNonUniformAMD(int);ivec2 minInvocationsNonUniformAMD(ivec2);ivec3 minInvocationsNonUniformAMD(ivec3);ivec4 minInvocationsNonUniformAMD(ivec4);uint  minInvocationsNonUniformAMD(uint);uvec2 minInvocationsNonUniformAMD(uvec2);uvec3 minInvocationsNonUniformAMD(uvec3);uvec4 minInvocationsNonUniformAMD(uvec4);double minInvocationsNonUniformAMD(double);dvec2  minInvocationsNonUniformAMD(dvec2);dvec3  minInvocationsNonUniformAMD(dvec3);dvec4  minInvocationsNonUniformAMD(dvec4);int64_t minInvocationsNonUniformAMD(int64_t);i64vec2 minInvocationsNonUniformAMD(i64vec2);i64vec3 minInvocationsNonUniformAMD(i64vec3);i64vec4 minInvocationsNonUniformAMD(i64vec4);uint64_t minInvocationsNonUniformAMD(uint64_t);u64vec2  minInvocationsNonUniformAMD(u64vec2);u64vec3  minInvocationsNonUniformAMD(u64vec3);u64vec4  minInvocationsNonUniformAMD(u64vec4);float16_t minInvocationsNonUniformAMD(float16_t);f16vec2   minInvocationsNonUniformAMD(f16vec2);f16vec3   minInvocationsNonUniformAMD(f16vec3);f16vec4   minInvocationsNonUniformAMD(f16vec4);int16_t minInvocationsNonUniformAMD(int16_t);i16vec2 minInvocationsNonUniformAMD(i16vec2);i16vec3 minInvocationsNonUniformAMD(i16vec3);i16vec4 minInvocationsNonUniformAMD(i16vec4);uint16_t minInvocationsNonUniformAMD(uint16_t);u16vec2  minInvocationsNonUniformAMD(u16vec2);u16vec3  minInvocationsNonUniformAMD(u16vec3);u16vec4  minInvocationsNonUniformAMD(u16vec4);float minInvocationsInclusiveScanNonUniformAMD(float);vec2  minInvocationsInclusiveScanNonUniformAMD(vec2);vec3  minInvocationsInclusiveScanNonUniformAMD(vec3);vec4  minInvocationsInclusiveScanNonUniformAMD(vec4);int   minInvocationsInclusiveScanNonUniformAMD(int);ivec2 minInvocationsInclusiveScanNonUniformAMD(ivec2);ivec3 minInvocationsInclusiveScanNonUniformAMD(ivec3);ivec4 minInvocationsInclusiveScanNonUniformAMD(ivec4);uint  minInvocationsInclusiveScanNonUniformAMD(uint);uvec2 minInvocationsInclusiveScanNonUniformAMD(uvec2);uvec3 minInvocationsInclusiveScanNonUniformAMD(uvec3);uvec4 minInvocationsInclusiveScanNonUniformAMD(uvec4);double minInvocationsInclusiveScanNonUniformAMD(double);dvec2  minInvocationsInclusiveScanNonUniformAMD(dvec2);dvec3  minInvocationsInclusiveScanNonUniformAMD(dvec3);dvec4  minInvocationsInclusiveScanNonUniformAMD(dvec4);int64_t minInvocationsInclusiveScanNonUniformAMD(int64_t);i64vec2 minInvocationsInclusiveScanNonUniformAMD(i64vec2);i64vec3 minInvocationsInclusiveScanNonUniformAMD(i64vec3);i64vec4 minInvocationsInclusiveScanNonUniformAMD(i64vec4);uint64_t minInvocationsInclusiveScanNonUniformAMD(uint64_t);u64vec2  minInvocationsInclusiveScanNonUniformAMD(u64vec2);u64vec3  minInvocationsInclusiveScanNonUniformAMD(u64vec3);u64vec4  minInvocationsInclusiveScanNonUniformAMD(u64vec4);float16_t minInvocationsInclusiveScanNonUniformAMD(float16_t);f16vec2   minInvocationsInclusiveScanNonUniformAMD(f16vec2);f16vec3   minInvocationsInclusiveScanNonUniformAMD(f16vec3);f16vec4   minInvocationsInclusiveScanNonUniformAMD(f16vec4);int16_t minInvocationsInclusiveScanNonUniformAMD(int16_t);i16vec2 minInvocationsInclusiveScanNonUniformAMD(i16vec2);i16vec3 minInvocationsInclusiveScanNonUniformAMD(i16vec3);i16vec4 minInvocationsInclusiveScanNonUniformAMD(i16vec4);uint16_t minInvocationsInclusiveScanNonUniformAMD(uint16_t);u16vec2  minInvocationsInclusiveScanNonUniformAMD(u16vec2);u16vec3  minInvocationsInclusiveScanNonUniformAMD(u16vec3);u16vec4  minInvocationsInclusiveScanNonUniformAMD(u16vec4);float minInvocationsExclusiveScanNonUniformAMD(float);vec2  minInvocationsExclusiveScanNonUniformAMD(vec2);vec3  minInvocationsExclusiveScanNonUniformAMD(vec3);vec4  minInvocationsExclusiveScanNonUniformAMD(vec4);int   minInvocationsExclusiveScanNonUniformAMD(int);ivec2 minInvocationsExclusiveScanNonUniformAMD(ivec2);ivec3 minInvocationsExclusiveScanNonUniformAMD(ivec3);ivec4 minInvocationsExclusiveScanNonUniformAMD(ivec4);uint  minInvocationsExclusiveScanNonUniformAMD(uint);uvec2 minInvocationsExclusiveScanNonUniformAMD(uvec2);uvec3 minInvocationsExclusiveScanNonUniformAMD(uvec3);uvec4 minInvocationsExclusiveScanNonUniformAMD(uvec4);double minInvocationsExclusiveScanNonUniformAMD(double);dvec2  minInvocationsExclusiveScanNonUniformAMD(dvec2);dvec3  minInvocationsExclusiveScanNonUniformAMD(dvec3);dvec4  minInvocationsExclusiveScanNonUniformAMD(dvec4);int64_t minInvocationsExclusiveScanNonUniformAMD(int64_t);i64vec2 minInvocationsExclusiveScanNonUniformAMD(i64vec2);i64vec3 minInvocationsExclusiveScanNonUniformAMD(i64vec3);i64vec4 minInvocationsExclusiveScanNonUniformAMD(i64vec4);uint64_t minInvocationsExclusiveScanNonUniformAMD(uint64_t);u64vec2  minInvocationsExclusiveScanNonUniformAMD(u64vec2);u64vec3  minInvocationsExclusiveScanNonUniformAMD(u64vec3);u64vec4  minInvocationsExclusiveScanNonUniformAMD(u64vec4);float16_t minInvocationsExclusiveScanNonUniformAMD(float16_t);f16vec2   minInvocationsExclusiveScanNonUniformAMD(f16vec2);f16vec3   minInvocationsExclusiveScanNonUniformAMD(f16vec3);f16vec4   minInvocationsExclusiveScanNonUniformAMD(f16vec4);int16_t minInvocationsExclusiveScanNonUniformAMD(int16_t);i16vec2 minInvocationsExclusiveScanNonUniformAMD(i16vec2);i16vec3 minInvocationsExclusiveScanNonUniformAMD(i16vec3);i16vec4 minInvocationsExclusiveScanNonUniformAMD(i16vec4);uint16_t minInvocationsExclusiveScanNonUniformAMD(uint16_t);u16vec2  minInvocationsExclusiveScanNonUniformAMD(u16vec2);u16vec3  minInvocationsExclusiveScanNonUniformAMD(u16vec3);u16vec4  minInvocationsExclusiveScanNonUniformAMD(u16vec4);float maxInvocationsNonUniformAMD(float);vec2  maxInvocationsNonUniformAMD(vec2);vec3  maxInvocationsNonUniformAMD(vec3);vec4  maxInvocationsNonUniformAMD(vec4);int   maxInvocationsNonUniformAMD(int);ivec2 maxInvocationsNonUniformAMD(ivec2);ivec3 maxInvocationsNonUniformAMD(ivec3);ivec4 maxInvocationsNonUniformAMD(ivec4);uint  maxInvocationsNonUniformAMD(uint);uvec2 maxInvocationsNonUniformAMD(uvec2);uvec3 maxInvocationsNonUniformAMD(uvec3);uvec4 maxInvocationsNonUniformAMD(uvec4);double maxInvocationsNonUniformAMD(double);dvec2  maxInvocationsNonUniformAMD(dvec2);dvec3  maxInvocationsNonUniformAMD(dvec3);dvec4  maxInvocationsNonUniformAMD(dvec4);int64_t maxInvocationsNonUniformAMD(int64_t);i64vec2 maxInvocationsNonUniformAMD(i64vec2);i64vec3 maxInvocationsNonUniformAMD(i64vec3);i64vec4 maxInvocationsNonUniformAMD(i64vec4);uint64_t maxInvocationsNonUniformAMD(uint64_t);u64vec2  maxInvocationsNonUniformAMD(u64vec2);u64vec3  maxInvocationsNonUniformAMD(u64vec3);u64vec4  maxInvocationsNonUniformAMD(u64vec4);float16_t maxInvocationsNonUniformAMD(float16_t);f16vec2   maxInvocationsNonUniformAMD(f16vec2);f16vec3   maxInvocationsNonUniformAMD(f16vec3);f16vec4   maxInvocationsNonUniformAMD(f16vec4);int16_t maxInvocationsNonUniformAMD(int16_t);i16vec2 maxInvocationsNonUniformAMD(i16vec2);i16vec3 maxInvocationsNonUniformAMD(i16vec3);i16vec4 maxInvocationsNonUniformAMD(i16vec4);uint16_t maxInvocationsNonUniformAMD(uint16_t);u16vec2  maxInvocationsNonUniformAMD(u16vec2);u16vec3  maxInvocationsNonUniformAMD(u16vec3);u16vec4  maxInvocationsNonUniformAMD(u16vec4);float maxInvocationsInclusiveScanNonUniformAMD(float);vec2  maxInvocationsInclusiveScanNonUniformAMD(vec2);vec3  maxInvocationsInclusiveScanNonUniformAMD(vec3);vec4  maxInvocationsInclusiveScanNonUniformAMD(vec4);int   maxInvocationsInclusiveScanNonUniformAMD(int);ivec2 maxInvocationsInclusiveScanNonUniformAMD(ivec2);ivec3 maxInvocationsInclusiveScanNonUniformAMD(ivec3);ivec4 maxInvocationsInclusiveScanNonUniformAMD(ivec4);uint  maxInvocationsInclusiveScanNonUniformAMD(uint);uvec2 maxInvocationsInclusiveScanNonUniformAMD(uvec2);uvec3 maxInvocationsInclusiveScanNonUniformAMD(uvec3);uvec4 maxInvocationsInclusiveScanNonUniformAMD(uvec4);double maxInvocationsInclusiveScanNonUniformAMD(double);dvec2  maxInvocationsInclusiveScanNonUniformAMD(dvec2);dvec3  maxInvocationsInclusiveScanNonUniformAMD(dvec3);dvec4  maxInvocationsInclusiveScanNonUniformAMD(dvec4);int64_t maxInvocationsInclusiveScanNonUniformAMD(int64_t);i64vec2 maxInvocationsInclusiveScanNonUniformAMD(i64vec2);i64vec3 maxInvocationsInclusiveScanNonUniformAMD(i64vec3);i64vec4 maxInvocationsInclusiveScanNonUniformAMD(i64vec4);uint64_t maxInvocationsInclusiveScanNonUniformAMD(uint64_t);u64vec2  maxInvocationsInclusiveScanNonUniformAMD(u64vec2);u64vec3  maxInvocationsInclusiveScanNonUniformAMD(u64vec3);u64vec4  maxInvocationsInclusiveScanNonUniformAMD(u64vec4);float16_t maxInvocationsInclusiveScanNonUniformAMD(float16_t);f16vec2   maxInvocationsInclusiveScanNonUniformAMD(f16vec2);f16vec3   maxInvocationsInclusiveScanNonUniformAMD(f16vec3);f16vec4   maxInvocationsInclusiveScanNonUniformAMD(f16vec4);int16_t maxInvocationsInclusiveScanNonUniformAMD(int16_t);i16vec2 maxInvocationsInclusiveScanNonUniformAMD(i16vec2);i16vec3 maxInvocationsInclusiveScanNonUniformAMD(i16vec3);i16vec4 maxInvocationsInclusiveScanNonUniformAMD(i16vec4);uint16_t maxInvocationsInclusiveScanNonUniformAMD(uint16_t);u16vec2  maxInvocationsInclusiveScanNonUniformAMD(u16vec2);u16vec3  maxInvocationsInclusiveScanNonUniformAMD(u16vec3);u16vec4  maxInvocationsInclusiveScanNonUniformAMD(u16vec4);float maxInvocationsExclusiveScanNonUniformAMD(float);vec2  maxInvocationsExclusiveScanNonUniformAMD(vec2);vec3  maxInvocationsExclusiveScanNonUniformAMD(vec3);vec4  maxInvocationsExclusiveScanNonUniformAMD(vec4);int   maxInvocationsExclusiveScanNonUniformAMD(int);ivec2 maxInvocationsExclusiveScanNonUniformAMD(ivec2);ivec3 maxInvocationsExclusiveScanNonUniformAMD(ivec3);ivec4 maxInvocationsExclusiveScanNonUniformAMD(ivec4);uint  maxInvocationsExclusiveScanNonUniformAMD(uint);uvec2 maxInvocationsExclusiveScanNonUniformAMD(uvec2);uvec3 maxInvocationsExclusiveScanNonUniformAMD(uvec3);uvec4 maxInvocationsExclusiveScanNonUniformAMD(uvec4);double maxInvocationsExclusiveScanNonUniformAMD(double);dvec2  maxInvocationsExclusiveScanNonUniformAMD(dvec2);dvec3  maxInvocationsExclusiveScanNonUniformAMD(dvec3);dvec4  maxInvocationsExclusiveScanNonUniformAMD(dvec4);int64_t maxInvocationsExclusiveScanNonUniformAMD(int64_t);i64vec2 maxInvocationsExclusiveScanNonUniformAMD(i64vec2);i64vec3 maxInvocationsExclusiveScanNonUniformAMD(i64vec3);i64vec4 maxInvocationsExclusiveScanNonUniformAMD(i64vec4);uint64_t maxInvocationsExclusiveScanNonUniformAMD(uint64_t);u64vec2  maxInvocationsExclusiveScanNonUniformAMD(u64vec2);u64vec3  maxInvocationsExclusiveScanNonUniformAMD(u64vec3);u64vec4  maxInvocationsExclusiveScanNonUniformAMD(u64vec4);float16_t maxInvocationsExclusiveScanNonUniformAMD(float16_t);f16vec2   maxInvocationsExclusiveScanNonUniformAMD(f16vec2);f16vec3   maxInvocationsExclusiveScanNonUniformAMD(f16vec3);f16vec4   maxInvocationsExclusiveScanNonUniformAMD(f16vec4);int16_t maxInvocationsExclusiveScanNonUniformAMD(int16_t);i16vec2 maxInvocationsExclusiveScanNonUniformAMD(i16vec2);i16vec3 maxInvocationsExclusiveScanNonUniformAMD(i16vec3);i16vec4 maxInvocationsExclusiveScanNonUniformAMD(i16vec4);uint16_t maxInvocationsExclusiveScanNonUniformAMD(uint16_t);u16vec2  maxInvocationsExclusiveScanNonUniformAMD(u16vec2);u16vec3  maxInvocationsExclusiveScanNonUniformAMD(u16vec3);u16vec4  maxInvocationsExclusiveScanNonUniformAMD(u16vec4);float addInvocationsNonUniformAMD(float);vec2  addInvocationsNonUniformAMD(vec2);vec3  addInvocationsNonUniformAMD(vec3);vec4  addInvocationsNonUniformAMD(vec4);int   addInvocationsNonUniformAMD(int);ivec2 addInvocationsNonUniformAMD(ivec2);ivec3 addInvocationsNonUniformAMD(ivec3);ivec4 addInvocationsNonUniformAMD(ivec4);uint  addInvocationsNonUniformAMD(uint);uvec2 addInvocationsNonUniformAMD(uvec2);uvec3 addInvocationsNonUniformAMD(uvec3);uvec4 addInvocationsNonUniformAMD(uvec4);double addInvocationsNonUniformAMD(double);dvec2  addInvocationsNonUniformAMD(dvec2);dvec3  addInvocationsNonUniformAMD(dvec3);dvec4  addInvocationsNonUniformAMD(dvec4);int64_t addInvocationsNonUniformAMD(int64_t);i64vec2 addInvocationsNonUniformAMD(i64vec2);i64vec3 addInvocationsNonUniformAMD(i64vec3);i64vec4 addInvocationsNonUniformAMD(i64vec4);uint64_t addInvocationsNonUniformAMD(uint64_t);u64vec2  addInvocationsNonUniformAMD(u64vec2);u64vec3  addInvocationsNonUniformAMD(u64vec3);u64vec4  addInvocationsNonUniformAMD(u64vec4);float16_t addInvocationsNonUniformAMD(float16_t);f16vec2   addInvocationsNonUniformAMD(f16vec2);f16vec3   addInvocationsNonUniformAMD(f16vec3);f16vec4   addInvocationsNonUniformAMD(f16vec4);int16_t addInvocationsNonUniformAMD(int16_t);i16vec2 addInvocationsNonUniformAMD(i16vec2);i16vec3 addInvocationsNonUniformAMD(i16vec3);i16vec4 addInvocationsNonUniformAMD(i16vec4);uint16_t addInvocationsNonUniformAMD(uint16_t);u16vec2  addInvocationsNonUniformAMD(u16vec2);u16vec3  addInvocationsNonUniformAMD(u16vec3);u16vec4  addInvocationsNonUniformAMD(u16vec4);float addInvocationsInclusiveScanNonUniformAMD(float);vec2  addInvocationsInclusiveScanNonUniformAMD(vec2);vec3  addInvocationsInclusiveScanNonUniformAMD(vec3);vec4  addInvocationsInclusiveScanNonUniformAMD(vec4);int   addInvocationsInclusiveScanNonUniformAMD(int);ivec2 addInvocationsInclusiveScanNonUniformAMD(ivec2);ivec3 addInvocationsInclusiveScanNonUniformAMD(ivec3);ivec4 addInvocationsInclusiveScanNonUniformAMD(ivec4);uint  addInvocationsInclusiveScanNonUniformAMD(uint);uvec2 addInvocationsInclusiveScanNonUniformAMD(uvec2);uvec3 addInvocationsInclusiveScanNonUniformAMD(uvec3);uvec4 addInvocationsInclusiveScanNonUniformAMD(uvec4);double addInvocationsInclusiveScanNonUniformAMD(double);dvec2  addInvocationsInclusiveScanNonUniformAMD(dvec2);dvec3  addInvocationsInclusiveScanNonUniformAMD(dvec3);dvec4  addInvocationsInclusiveScanNonUniformAMD(dvec4);int64_t addInvocationsInclusiveScanNonUniformAMD(int64_t);i64vec2 addInvocationsInclusiveScanNonUniformAMD(i64vec2);i64vec3 addInvocationsInclusiveScanNonUniformAMD(i64vec3);i64vec4 addInvocationsInclusiveScanNonUniformAMD(i64vec4);uint64_t addInvocationsInclusiveScanNonUniformAMD(uint64_t);u64vec2  addInvocationsInclusiveScanNonUniformAMD(u64vec2);u64vec3  addInvocationsInclusiveScanNonUniformAMD(u64vec3);u64vec4  addInvocationsInclusiveScanNonUniformAMD(u64vec4);float16_t addInvocationsInclusiveScanNonUniformAMD(float16_t);f16vec2   addInvocationsInclusiveScanNonUniformAMD(f16vec2);f16vec3   addInvocationsInclusiveScanNonUniformAMD(f16vec3);f16vec4   addInvocationsInclusiveScanNonUniformAMD(f16vec4);int16_t addInvocationsInclusiveScanNonUniformAMD(int16_t);i16vec2 addInvocationsInclusiveScanNonUniformAMD(i16vec2);i16vec3 addInvocationsInclusiveScanNonUniformAMD(i16vec3);i16vec4 addInvocationsInclusiveScanNonUniformAMD(i16vec4);uint16_t addInvocationsInclusiveScanNonUniformAMD(uint16_t);u16vec2  addInvocationsInclusiveScanNonUniformAMD(u16vec2);u16vec3  addInvocationsInclusiveScanNonUniformAMD(u16vec3);u16vec4  addInvocationsInclusiveScanNonUniformAMD(u16vec4);float addInvocationsExclusiveScanNonUniformAMD(float);vec2  addInvocationsExclusiveScanNonUniformAMD(vec2);vec3  addInvocationsExclusiveScanNonUniformAMD(vec3);vec4  addInvocationsExclusiveScanNonUniformAMD(vec4);int   addInvocationsExclusiveScanNonUniformAMD(int);ivec2 addInvocationsExclusiveScanNonUniformAMD(ivec2);ivec3 addInvocationsExclusiveScanNonUniformAMD(ivec3);ivec4 addInvocationsExclusiveScanNonUniformAMD(ivec4);uint  addInvocationsExclusiveScanNonUniformAMD(uint);uvec2 addInvocationsExclusiveScanNonUniformAMD(uvec2);uvec3 addInvocationsExclusiveScanNonUniformAMD(uvec3);uvec4 addInvocationsExclusiveScanNonUniformAMD(uvec4);double addInvocationsExclusiveScanNonUniformAMD(double);dvec2  addInvocationsExclusiveScanNonUniformAMD(dvec2);dvec3  addInvocationsExclusiveScanNonUniformAMD(dvec3);dvec4  addInvocationsExclusiveScanNonUniformAMD(dvec4);int64_t addInvocationsExclusiveScanNonUniformAMD(int64_t);i64vec2 addInvocationsExclusiveScanNonUniformAMD(i64vec2);i64vec3 addInvocationsExclusiveScanNonUniformAMD(i64vec3);i64vec4 addInvocationsExclusiveScanNonUniformAMD(i64vec4);uint64_t addInvocationsExclusiveScanNonUniformAMD(uint64_t);u64vec2  addInvocationsExclusiveScanNonUniformAMD(u64vec2);u64vec3  addInvocationsExclusiveScanNonUniformAMD(u64vec3);u64vec4  addInvocationsExclusiveScanNonUniformAMD(u64vec4);float16_t addInvocationsExclusiveScanNonUniformAMD(float16_t);f16vec2   addInvocationsExclusiveScanNonUniformAMD(f16vec2);f16vec3   addInvocationsExclusiveScanNonUniformAMD(f16vec3);f16vec4   addInvocationsExclusiveScanNonUniformAMD(f16vec4);int16_t addInvocationsExclusiveScanNonUniformAMD(int16_t);i16vec2 addInvocationsExclusiveScanNonUniformAMD(i16vec2);i16vec3 addInvocationsExclusiveScanNonUniformAMD(i16vec3);i16vec4 addInvocationsExclusiveScanNonUniformAMD(i16vec4);uint16_t addInvocationsExclusiveScanNonUniformAMD(uint16_t);u16vec2  addInvocationsExclusiveScanNonUniformAMD(u16vec2);u16vec3  addInvocationsExclusiveScanNonUniformAMD(u16vec3);u16vec4  addInvocationsExclusiveScanNonUniformAMD(u16vec4);float swizzleInvocationsAMD(float, uvec4);vec2  swizzleInvocationsAMD(vec2,  uvec4);vec3  swizzleInvocationsAMD(vec3,  uvec4);vec4  swizzleInvocationsAMD(vec4,  uvec4);int   swizzleInvocationsAMD(int,   uvec4);ivec2 swizzleInvocationsAMD(ivec2, uvec4);ivec3 swizzleInvocationsAMD(ivec3, uvec4);ivec4 swizzleInvocationsAMD(ivec4, uvec4);uint  swizzleInvocationsAMD(uint,  uvec4);uvec2 swizzleInvocationsAMD(uvec2, uvec4);uvec3 swizzleInvocationsAMD(uvec3, uvec4);uvec4 swizzleInvocationsAMD(uvec4, uvec4);float swizzleInvocationsMaskedAMD(float, uvec3);vec2  swizzleInvocationsMaskedAMD(vec2,  uvec3);vec3  swizzleInvocationsMaskedAMD(vec3,  uvec3);vec4  swizzleInvocationsMaskedAMD(vec4,  uvec3);int   swizzleInvocationsMaskedAMD(int,   uvec3);ivec2 swizzleInvocationsMaskedAMD(ivec2, uvec3);ivec3 swizzleInvocationsMaskedAMD(ivec3, uvec3);ivec4 swizzleInvocationsMaskedAMD(ivec4, uvec3);uint  swizzleInvocationsMaskedAMD(uint,  uvec3);uvec2 swizzleInvocationsMaskedAMD(uvec2, uvec3);uvec3 swizzleInvocationsMaskedAMD(uvec3, uvec3);uvec4 swizzleInvocationsMaskedAMD(uvec4, uvec3);float writeInvocationAMD(float, float, uint);vec2  writeInvocationAMD(vec2,  vec2,  uint);vec3  writeInvocationAMD(vec3,  vec3,  uint);vec4  writeInvocationAMD(vec4,  vec4,  uint);int   writeInvocationAMD(int,   int,   uint);ivec2 writeInvocationAMD(ivec2, ivec2, uint);ivec3 writeInvocationAMD(ivec3, ivec3, uint);ivec4 writeInvocationAMD(ivec4, ivec4, uint);uint  writeInvocationAMD(uint,  uint,  uint);uvec2 writeInvocationAMD(uvec2, uvec2, uint);uvec3 writeInvocationAMD(uvec3, uvec3, uint);uvec4 writeInvocationAMD(uvec4, uvec4, uint);uint mbcntAMD(uint64_t);\n
uint fragmentMaskFetchAMD(sampler2DMS,       ivec2);uint fragmentMaskFetchAMD(isampler2DMS,      ivec2);uint fragmentMaskFetchAMD(usampler2DMS,      ivec2);uint fragmentMaskFetchAMD(sampler2DMSArray,  ivec3);uint fragmentMaskFetchAMD(isampler2DMSArray, ivec3);uint fragmentMaskFetchAMD(usampler2DMSArray, ivec3);vec4  fragmentFetchAMD(sampler2DMS,       ivec2, uint);ivec4 fragmentFetchAMD(isampler2DMS,      ivec2, uint);uvec4 fragmentFetchAMD(usampler2DMS,      ivec2, uint);vec4  fragmentFetchAMD(sampler2DMSArray,  ivec3, uint);ivec4 fragmentFetchAMD(isampler2DMSArray, ivec3, uint);uvec4 fragmentFetchAMD(usampler2DMSArray, ivec3, uint);\n
struct gl_TextureFootprint2DNV {uvec2 anchor;uvec2 offset;uvec2 mask;uint lod;uint granularity;};struct gl_TextureFootprint3DNV {uvec3 anchor;uvec3 offset;uvec2 mask;uint lod;uint granularity;};bool textureFootprintNV(sampler2D, vec2, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintNV(sampler3D, vec3, int, bool, out gl_TextureFootprint3DNV);bool textureFootprintNV(sampler2D, vec2, int, bool, out gl_TextureFootprint2DNV, float);bool textureFootprintNV(sampler3D, vec3, int, bool, out gl_TextureFootprint3DNV, float);bool textureFootprintClampNV(sampler2D, vec2, float, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintClampNV(sampler3D, vec3, float, int, bool, out gl_TextureFootprint3DNV);bool textureFootprintClampNV(sampler2D, vec2, float, int, bool, out gl_TextureFootprint2DNV, float);bool textureFootprintClampNV(sampler3D, vec3, float, int, bool, out gl_TextureFootprint3DNV, float);bool textureFootprintLodNV(sampler2D, vec2, float, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintLodNV(sampler3D, vec3, float, int, bool, out gl_TextureFootprint3DNV);bool textureFootprintGradNV(sampler2D, vec2, vec2, vec2, int, bool, out gl_TextureFootprint2DNV);bool textureFootprintGradClampNV(sampler2D, vec2, vec2, vec2, float, int, bool, out gl_TextureFootprint2DNV);\n
float16_t radians(float16_t);f16vec2   radians(f16vec2);f16vec3   radians(f16vec3);f16vec4   radians(f16vec4);float16_t degrees(float16_t);f16vec2   degrees(f16vec2);f16vec3   degrees(f16vec3);f16vec4   degrees(f16vec4);float16_t sin(float16_t);f16vec2   sin(f16vec2);f16vec3   sin(f16vec3);f16vec4   sin(f16vec4);float16_t cos(float16_t);f16vec2   cos(f16vec2);f16vec3   cos(f16vec3);f16vec4   cos(f16vec4);float16_t tan(float16_t);f16vec2   tan(f16vec2);f16vec3   tan(f16vec3);f16vec4   tan(f16vec4);float16_t asin(float16_t);f16vec2   asin(f16vec2);f16vec3   asin(f16vec3);f16vec4   asin(f16vec4);float16_t acos(float16_t);f16vec2   acos(f16vec2);f16vec3   acos(f16vec3);f16vec4   acos(f16vec4);float16_t atan(float16_t, float16_t);f16vec2   atan(f16vec2,   f16vec2);f16vec3   atan(f16vec3,   f16vec3);f16vec4   atan(f16vec4,   f16vec4);float16_t atan(float16_t);f16vec2   atan(f16vec2);f16vec3   atan(f16vec3);f16vec4   atan(f16vec4);float16_t sinh(float16_t);f16vec2   sinh(f16vec2);f16vec3   sinh(f16vec3);f16vec4   sinh(f16vec4);float16_t cosh(float16_t);f16vec2   cosh(f16vec2);f16vec3   cosh(f16vec3);f16vec4   cosh(f16vec4);float16_t tanh(float16_t);f16vec2   tanh(f16vec2);f16vec3   tanh(f16vec3);f16vec4   tanh(f16vec4);float16_t asinh(float16_t);f16vec2   asinh(f16vec2);f16vec3   asinh(f16vec3);f16vec4   asinh(f16vec4);float16_t acosh(float16_t);f16vec2   acosh(f16vec2);f16vec3   acosh(f16vec3);f16vec4   acosh(f16vec4);float16_t atanh(float16_t);f16vec2   atanh(f16vec2);f16vec3   atanh(f16vec3);f16vec4   atanh(f16vec4);float16_t pow(float16_t, float16_t);f16vec2   pow(f16vec2,   f16vec2);f16vec3   pow(f16vec3,   f16vec3);f16vec4   pow(f16vec4,   f16vec4);float16_t exp(float16_t);f16vec2   exp(f16vec2);f16vec3   exp(f16vec3);f16vec4   exp(f16vec4);float16_t log(float16_t);f16vec2   log(f16vec2);f16vec3   log(f16vec3);f16vec4   log(f16vec4);float16_t exp2(float16_t);f16vec2   exp2(f16vec2);f16vec3   exp2(f16vec3);f16vec4   exp2(f16vec4);float16_t log2(float16_t);f16vec2   log2(f16vec2);f16vec3   log2(f16vec3);f16vec4   log2(f16vec4);float16_t sqrt(float16_t);f16vec2   sqrt(f16vec2);f16vec3   sqrt(f16vec3);f16vec4   sqrt(f16vec4);float16_t inversesqrt(float16_t);f16vec2   inversesqrt(f16vec2);f16vec3   inversesqrt(f16vec3);f16vec4   inversesqrt(f16vec4);float16_t abs(float16_t);f16vec2   abs(f16vec2);f16vec3   abs(f16vec3);f16vec4   abs(f16vec4);float16_t sign(float16_t);f16vec2   sign(f16vec2);f16vec3   sign(f16vec3);f16vec4   sign(f16vec4);float16_t floor(float16_t);f16vec2   floor(f16vec2);f16vec3   floor(f16vec3);f16vec4   floor(f16vec4);float16_t trunc(float16_t);f16vec2   trunc(f16vec2);f16vec3   trunc(f16vec3);f16vec4   trunc(f16vec4);float16_t round(float16_t);f16vec2   round(f16vec2);f16vec3   round(f16vec3);f16vec4   round(f16vec4);float16_t roundEven(float16_t);f16vec2   roundEven(f16vec2);f16vec3   roundEven(f16vec3);f16vec4   roundEven(f16vec4);float16_t ceil(float16_t);f16vec2   ceil(f16vec2);f16vec3   ceil(f16vec3);f16vec4   ceil(f16vec4);float16_t fract(float16_t);f16vec2   fract(f16vec2);f16vec3   fract(f16vec3);f16vec4   fract(f16vec4);float16_t mod(float16_t, float16_t);f16vec2   mod(f16vec2,   float16_t);f16vec3   mod(f16vec3,   float16_t);f16vec4   mod(f16vec4,   float16_t);f16vec2   mod(f16vec2,   f16vec2);f16vec3   mod(f16vec3,   f16vec3);f16vec4   mod(f16vec4,   f16vec4);float16_t modf(float16_t, out float16_t);f16vec2   modf(f16vec2,   out f16vec2);f16vec3   modf(f16vec3,   out f16vec3);f16vec4   modf(f16vec4,   out f16vec4);float16_t min(float16_t, float16_t);f16vec2   min(f16vec2,   float16_t);f16vec3   min(f16vec3,   float16_t);f16vec4   min(f16vec4,   float16_t);f16vec2   min(f16vec2,   f16vec2);f16vec3   min(f16vec3,   f16vec3);f16vec4   min(f16vec4,   f16vec4);float16_t max(float16_t, float16_t);f16vec2   max(f16vec2,   float16_t);f16vec3   max(f16vec3,   float16_t);f16vec4   max(f16vec4,   float16_t);f16vec2   max(f16vec2,   f16vec2);f16vec3   max(f16vec3,   f16vec3);f16vec4   max(f16vec4,   f16vec4);float16_t clamp(float16_t, float16_t, float16_t);f16vec2   clamp(f16vec2,   float16_t, float16_t);f16vec3   clamp(f16vec3,   float16_t, float16_t);f16vec4   clamp(f16vec4,   float16_t, float16_t);f16vec2   clamp(f16vec2,   f16vec2,   f16vec2);f16vec3   clamp(f16vec3,   f16vec3,   f16vec3);f16vec4   clamp(f16vec4,   f16vec4,   f16vec4);float16_t mix(float16_t, float16_t, float16_t);f16vec2   mix(f16vec2,   f16vec2,   float16_t);f16vec3   mix(f16vec3,   f16vec3,   float16_t);f16vec4   mix(f16vec4,   f16vec4,   float16_t);f16vec2   mix(f16vec2,   f16vec2,   f16vec2);f16vec3   mix(f16vec3,   f16vec3,   f16vec3);f16vec4   mix(f16vec4,   f16vec4,   f16vec4);float16_t mix(float16_t, float16_t, bool);f16vec2   mix(f16vec2,   f16vec2,   bvec2);f16vec3   mix(f16vec3,   f16vec3,   bvec3);f16vec4   mix(f16vec4,   f16vec4,   bvec4);float16_t step(float16_t, float16_t);f16vec2   step(f16vec2,   f16vec2);f16vec3   step(f16vec3,   f16vec3);f16vec4   step(f16vec4,   f16vec4);f16vec2   step(float16_t, f16vec2);f16vec3   step(float16_t, f16vec3);f16vec4   step(float16_t, f16vec4);float16_t smoothstep(float16_t, float16_t, float16_t);f16vec2   smoothstep(f16vec2,   f16vec2,   f16vec2);f16vec3   smoothstep(f16vec3,   f16vec3,   f16vec3);f16vec4   smoothstep(f16vec4,   f16vec4,   f16vec4);f16vec2   smoothstep(float16_t, float16_t, f16vec2);f16vec3   smoothstep(float16_t, float16_t, f16vec3);f16vec4   smoothstep(float16_t, float16_t, f16vec4);bool  isnan(float16_t);bvec2 isnan(f16vec2);bvec3 isnan(f16vec3);bvec4 isnan(f16vec4);bool  isinf(float16_t);bvec2 isinf(f16vec2);bvec3 isinf(f16vec3);bvec4 isinf(f16vec4);float16_t fma(float16_t, float16_t, float16_t);f16vec2   fma(f16vec2,   f16vec2,   f16vec2);f16vec3   fma(f16vec3,   f16vec3,   f16vec3);f16vec4   fma(f16vec4,   f16vec4,   f16vec4);float16_t frexp(float16_t, out int);f16vec2   frexp(f16vec2,   out ivec2);f16vec3   frexp(f16vec3,   out ivec3);f16vec4   frexp(f16vec4,   out ivec4);float16_t ldexp(float16_t, in int);f16vec2   ldexp(f16vec2,   in ivec2);f16vec3   ldexp(f16vec3,   in ivec3);f16vec4   ldexp(f16vec4,   in ivec4);uint    packFloat2x16(f16vec2);f16vec2 unpackFloat2x16(uint);float16_t length(float16_t);float16_t length(f16vec2);float16_t length(f16vec3);float16_t length(f16vec4);float16_t distance(float16_t, float16_t);float16_t distance(f16vec2,   f16vec2);float16_t distance(f16vec3,   f16vec3);float16_t distance(f16vec4,   f16vec4);float16_t dot(float16_t, float16_t);float16_t dot(f16vec2,   f16vec2);float16_t dot(f16vec3,   f16vec3);float16_t dot(f16vec4,   f16vec4);f16vec3 cross(f16vec3, f16vec3);float16_t normalize(float16_t);f16vec2   normalize(f16vec2);f16vec3   normalize(f16vec3);f16vec4   normalize(f16vec4);float16_t faceforward(float16_t, float16_t, float16_t);f16vec2   faceforward(f16vec2,   f16vec2,   f16vec2);f16vec3   faceforward(f16vec3,   f16vec3,   f16vec3);f16vec4   faceforward(f16vec4,   f16vec4,   f16vec4);float16_t reflect(float16_t, float16_t);f16vec2   reflect(f16vec2,   f16vec2);f16vec3   reflect(f16vec3,   f16vec3);f16vec4   reflect(f16vec4,   f16vec4);float16_t refract(float16_t, float16_t, float16_t);f16vec2   refract(f16vec2,   f16vec2,   float16_t);f16vec3   refract(f16vec3,   f16vec3,   float16_t);f16vec4   refract(f16vec4,   f16vec4,   float16_t);f16mat2   matrixCompMult(f16mat2,   f16mat2);f16mat3   matrixCompMult(f16mat3,   f16mat3);f16mat4   matrixCompMult(f16mat4,   f16mat4);f16mat2x3 matrixCompMult(f16mat2x3, f16mat2x3);f16mat2x4 matrixCompMult(f16mat2x4, f16mat2x4);f16mat3x2 matrixCompMult(f16mat3x2, f16mat3x2);f16mat3x4 matrixCompMult(f16mat3x4, f16mat3x4);f16mat4x2 matrixCompMult(f16mat4x2, f16mat4x2);f16mat4x3 matrixCompMult(f16mat4x3, f16mat4x3);f16mat2   outerProduct(f16vec2, f16vec2);f16mat3   outerProduct(f16vec3, f16vec3);f16mat4   outerProduct(f16vec4, f16vec4);f16mat2x3 outerProduct(f16vec3, f16vec2);f16mat3x2 outerProduct(f16vec2, f16vec3);f16mat2x4 outerProduct(f16vec4, f16vec2);f16mat4x2 outerProduct(f16vec2, f16vec4);f16mat3x4 outerProduct(f16vec4, f16vec3);f16mat4x3 outerProduct(f16vec3, f16vec4);f16mat2   transpose(f16mat2);f16mat3   transpose(f16mat3);f16mat4   transpose(f16mat4);f16mat2x3 transpose(f16mat3x2);f16mat3x2 transpose(f16mat2x3);f16mat2x4 transpose(f16mat4x2);f16mat4x2 transpose(f16mat2x4);f16mat3x4 transpose(f16mat4x3);f16mat4x3 transpose(f16mat3x4);float16_t determinant(f16mat2);float16_t determinant(f16mat3);float16_t determinant(f16mat4);f16mat2 inverse(f16mat2);f16mat3 inverse(f16mat3);f16mat4 inverse(f16mat4);bvec2 lessThan(f16vec2, f16vec2);bvec3 lessThan(f16vec3, f16vec3);bvec4 lessThan(f16vec4, f16vec4);bvec2 lessThanEqual(f16vec2, f16vec2);bvec3 lessThanEqual(f16vec3, f16vec3);bvec4 lessThanEqual(f16vec4, f16vec4);bvec2 greaterThan(f16vec2, f16vec2);bvec3 greaterThan(f16vec3, f16vec3);bvec4 greaterThan(f16vec4, f16vec4);bvec2 greaterThanEqual(f16vec2, f16vec2);bvec3 greaterThanEqual(f16vec3, f16vec3);bvec4 greaterThanEqual(f16vec4, f16vec4);bvec2 equal(f16vec2, f16vec2);bvec3 equal(f16vec3, f16vec3);bvec4 equal(f16vec4, f16vec4);bvec2 notEqual(f16vec2, f16vec2);bvec3 notEqual(f16vec3, f16vec3);bvec4 notEqual(f16vec4, f16vec4);\n
int8_t abs(int8_t);i8vec2 abs(i8vec2);i8vec3 abs(i8vec3);i8vec4 abs(i8vec4);int8_t sign(int8_t);i8vec2 sign(i8vec2);i8vec3 sign(i8vec3);i8vec4 sign(i8vec4);int8_t min(int8_t x, int8_t y);i8vec2 min(i8vec2 x, int8_t y);i8vec3 min(i8vec3 x, int8_t y);i8vec4 min(i8vec4 x, int8_t y);i8vec2 min(i8vec2 x, i8vec2 y);i8vec3 min(i8vec3 x, i8vec3 y);i8vec4 min(i8vec4 x, i8vec4 y);uint8_t min(uint8_t x, uint8_t y);u8vec2 min(u8vec2 x, uint8_t y);u8vec3 min(u8vec3 x, uint8_t y);u8vec4 min(u8vec4 x, uint8_t y);u8vec2 min(u8vec2 x, u8vec2 y);u8vec3 min(u8vec3 x, u8vec3 y);u8vec4 min(u8vec4 x, u8vec4 y);int8_t max(int8_t x, int8_t y);i8vec2 max(i8vec2 x, int8_t y);i8vec3 max(i8vec3 x, int8_t y);i8vec4 max(i8vec4 x, int8_t y);i8vec2 max(i8vec2 x, i8vec2 y);i8vec3 max(i8vec3 x, i8vec3 y);i8vec4 max(i8vec4 x, i8vec4 y);uint8_t max(uint8_t x, uint8_t y);u8vec2 max(u8vec2 x, uint8_t y);u8vec3 max(u8vec3 x, uint8_t y);u8vec4 max(u8vec4 x, uint8_t y);u8vec2 max(u8vec2 x, u8vec2 y);u8vec3 max(u8vec3 x, u8vec3 y);u8vec4 max(u8vec4 x, u8vec4 y);int8_t    clamp(int8_t x, int8_t minVal, int8_t maxVal);i8vec2  clamp(i8vec2  x, int8_t minVal, int8_t maxVal);i8vec3  clamp(i8vec3  x, int8_t minVal, int8_t maxVal);i8vec4  clamp(i8vec4  x, int8_t minVal, int8_t maxVal);i8vec2  clamp(i8vec2  x, i8vec2  minVal, i8vec2  maxVal);i8vec3  clamp(i8vec3  x, i8vec3  minVal, i8vec3  maxVal);i8vec4  clamp(i8vec4  x, i8vec4  minVal, i8vec4  maxVal);uint8_t   clamp(uint8_t x, uint8_t minVal, uint8_t maxVal);u8vec2  clamp(u8vec2  x, uint8_t minVal, uint8_t maxVal);u8vec3  clamp(u8vec3  x, uint8_t minVal, uint8_t maxVal);u8vec4  clamp(u8vec4  x, uint8_t minVal, uint8_t maxVal);u8vec2  clamp(u8vec2  x, u8vec2  minVal, u8vec2  maxVal);u8vec3  clamp(u8vec3  x, u8vec3  minVal, u8vec3  maxVal);u8vec4  clamp(u8vec4  x, u8vec4  minVal, u8vec4  maxVal);int8_t  mix(int8_t,  int8_t,  bool);i8vec2  mix(i8vec2,  i8vec2,  bvec2);i8vec3  mix(i8vec3,  i8vec3,  bvec3);i8vec4  mix(i8vec4,  i8vec4,  bvec4);uint8_t mix(uint8_t, uint8_t, bool);u8vec2  mix(u8vec2,  u8vec2,  bvec2);u8vec3  mix(u8vec3,  u8vec3,  bvec3);u8vec4  mix(u8vec4,  u8vec4,  bvec4);bvec2 lessThan(i8vec2, i8vec2);bvec3 lessThan(i8vec3, i8vec3);bvec4 lessThan(i8vec4, i8vec4);bvec2 lessThan(u8vec2, u8vec2);bvec3 lessThan(u8vec3, u8vec3);bvec4 lessThan(u8vec4, u8vec4);bvec2 lessThanEqual(i8vec2, i8vec2);bvec3 lessThanEqual(i8vec3, i8vec3);bvec4 lessThanEqual(i8vec4, i8vec4);bvec2 lessThanEqual(u8vec2, u8vec2);bvec3 lessThanEqual(u8vec3, u8vec3);bvec4 lessThanEqual(u8vec4, u8vec4);bvec2 greaterThan(i8vec2, i8vec2);bvec3 greaterThan(i8vec3, i8vec3);bvec4 greaterThan(i8vec4, i8vec4);bvec2 greaterThan(u8vec2, u8vec2);bvec3 greaterThan(u8vec3, u8vec3);bvec4 greaterThan(u8vec4, u8vec4);bvec2 greaterThanEqual(i8vec2, i8vec2);bvec3 greaterThanEqual(i8vec3, i8vec3);bvec4 greaterThanEqual(i8vec4, i8vec4);bvec2 greaterThanEqual(u8vec2, u8vec2);bvec3 greaterThanEqual(u8vec3, u8vec3);bvec4 greaterThanEqual(u8vec4, u8vec4);bvec2 equal(i8vec2, i8vec2);bvec3 equal(i8vec3, i8vec3);bvec4 equal(i8vec4, i8vec4);bvec2 equal(u8vec2, u8vec2);bvec3 equal(u8vec3, u8vec3);bvec4 equal(u8vec4, u8vec4);bvec2 notEqual(i8vec2, i8vec2);bvec3 notEqual(i8vec3, i8vec3);bvec4 notEqual(i8vec4, i8vec4);bvec2 notEqual(u8vec2, u8vec2);bvec3 notEqual(u8vec3, u8vec3);bvec4 notEqual(u8vec4, u8vec4);  int8_t bitfieldExtract(  int8_t, int8_t, int8_t);i8vec2 bitfieldExtract(i8vec2, int8_t, int8_t);i8vec3 bitfieldExtract(i8vec3, int8_t, int8_t);i8vec4 bitfieldExtract(i8vec4, int8_t, int8_t); uint8_t bitfieldExtract( uint8_t, int8_t, int8_t);u8vec2 bitfieldExtract(u8vec2, int8_t, int8_t);u8vec3 bitfieldExtract(u8vec3, int8_t, int8_t);u8vec4 bitfieldExtract(u8vec4, int8_t, int8_t);  int8_t bitfieldInsert(  int8_t base,   int8_t, int8_t, int8_t);i8vec2 bitfieldInsert(i8vec2 base, i8vec2, int8_t, int8_t);i8vec3 bitfieldInsert(i8vec3 base, i8vec3, int8_t, int8_t);i8vec4 bitfieldInsert(i8vec4 base, i8vec4, int8_t, int8_t); uint8_t bitfieldInsert( uint8_t base,  uint8_t, int8_t, int8_t);u8vec2 bitfieldInsert(u8vec2 base, u8vec2, int8_t, int8_t);u8vec3 bitfieldInsert(u8vec3 base, u8vec3, int8_t, int8_t);u8vec4 bitfieldInsert(u8vec4 base, u8vec4, int8_t, int8_t);  int8_t bitCount(  int8_t);i8vec2 bitCount(i8vec2);i8vec3 bitCount(i8vec3);i8vec4 bitCount(i8vec4);  int8_t bitCount( uint8_t);i8vec2 bitCount(u8vec2);i8vec3 bitCount(u8vec3);i8vec4 bitCount(u8vec4);  int8_t findLSB(  int8_t);i8vec2 findLSB(i8vec2);i8vec3 findLSB(i8vec3);i8vec4 findLSB(i8vec4);  int8_t findLSB( uint8_t);i8vec2 findLSB(u8vec2);i8vec3 findLSB(u8vec3);i8vec4 findLSB(u8vec4);  int8_t findMSB(  int8_t);i8vec2 findMSB(i8vec2);i8vec3 findMSB(i8vec3);i8vec4 findMSB(i8vec4);  int8_t findMSB( uint8_t);i8vec2 findMSB(u8vec2);i8vec3 findMSB(u8vec3);i8vec4 findMSB(u8vec4);int16_t abs(int16_t);i16vec2 abs(i16vec2);i16vec3 abs(i16vec3);i16vec4 abs(i16vec4);int16_t sign(int16_t);i16vec2 sign(i16vec2);i16vec3 sign(i16vec3);i16vec4 sign(i16vec4);int16_t min(int16_t x, int16_t y);i16vec2 min(i16vec2 x, int16_t y);i16vec3 min(i16vec3 x, int16_t y);i16vec4 min(i16vec4 x, int16_t y);i16vec2 min(i16vec2 x, i16vec2 y);i16vec3 min(i16vec3 x, i16vec3 y);i16vec4 min(i16vec4 x, i16vec4 y);uint16_t min(uint16_t x, uint16_t y);u16vec2 min(u16vec2 x, uint16_t y);u16vec3 min(u16vec3 x, uint16_t y);u16vec4 min(u16vec4 x, uint16_t y);u16vec2 min(u16vec2 x, u16vec2 y);u16vec3 min(u16vec3 x, u16vec3 y);u16vec4 min(u16vec4 x, u16vec4 y);int16_t max(int16_t x, int16_t y);i16vec2 max(i16vec2 x, int16_t y);i16vec3 max(i16vec3 x, int16_t y);i16vec4 max(i16vec4 x, int16_t y);i16vec2 max(i16vec2 x, i16vec2 y);i16vec3 max(i16vec3 x, i16vec3 y);i16vec4 max(i16vec4 x, i16vec4 y);uint16_t max(uint16_t x, uint16_t y);u16vec2 max(u16vec2 x, uint16_t y);u16vec3 max(u16vec3 x, uint16_t y);u16vec4 max(u16vec4 x, uint16_t y);u16vec2 max(u16vec2 x, u16vec2 y);u16vec3 max(u16vec3 x, u16vec3 y);u16vec4 max(u16vec4 x, u16vec4 y);int16_t    clamp(int16_t x, int16_t minVal, int16_t maxVal);i16vec2  clamp(i16vec2  x, int16_t minVal, int16_t maxVal);i16vec3  clamp(i16vec3  x, int16_t minVal, int16_t maxVal);i16vec4  clamp(i16vec4  x, int16_t minVal, int16_t maxVal);i16vec2  clamp(i16vec2  x, i16vec2  minVal, i16vec2  maxVal);i16vec3  clamp(i16vec3  x, i16vec3  minVal, i16vec3  maxVal);i16vec4  clamp(i16vec4  x, i16vec4  minVal, i16vec4  maxVal);uint16_t   clamp(uint16_t x, uint16_t minVal, uint16_t maxVal);u16vec2  clamp(u16vec2  x, uint16_t minVal, uint16_t maxVal);u16vec3  clamp(u16vec3  x, uint16_t minVal, uint16_t maxVal);u16vec4  clamp(u16vec4  x, uint16_t minVal, uint16_t maxVal);u16vec2  clamp(u16vec2  x, u16vec2  minVal, u16vec2  maxVal);u16vec3  clamp(u16vec3  x, u16vec3  minVal, u16vec3  maxVal);u16vec4  clamp(u16vec4  x, u16vec4  minVal, u16vec4  maxVal);int16_t  mix(int16_t,  int16_t,  bool);i16vec2  mix(i16vec2,  i16vec2,  bvec2);i16vec3  mix(i16vec3,  i16vec3,  bvec3);i16vec4  mix(i16vec4,  i16vec4,  bvec4);uint16_t mix(uint16_t, uint16_t, bool);u16vec2  mix(u16vec2,  u16vec2,  bvec2);u16vec3  mix(u16vec3,  u16vec3,  bvec3);u16vec4  mix(u16vec4,  u16vec4,  bvec4);float16_t frexp(float16_t, out int16_t);f16vec2   frexp(f16vec2,   out i16vec2);f16vec3   frexp(f16vec3,   out i16vec3);f16vec4   frexp(f16vec4,   out i16vec4);float16_t ldexp(float16_t, int16_t);f16vec2   ldexp(f16vec2,   i16vec2);f16vec3   ldexp(f16vec3,   i16vec3);f16vec4   ldexp(f16vec4,   i16vec4);int16_t halfBitsToInt16(float16_t);i16vec2 halfBitsToInt16(f16vec2);i16vec3 halhBitsToInt16(f16vec3);i16vec4 halfBitsToInt16(f16vec4);uint16_t halfBitsToUint16(float16_t);u16vec2  halfBitsToUint16(f16vec2);u16vec3  halfBitsToUint16(f16vec3);u16vec4  halfBitsToUint16(f16vec4);int16_t float16BitsToInt16(float16_t);i16vec2 float16BitsToInt16(f16vec2);i16vec3 float16BitsToInt16(f16vec3);i16vec4 float16BitsToInt16(f16vec4);uint16_t float16BitsToUint16(float16_t);u16vec2  float16BitsToUint16(f16vec2);u16vec3  float16BitsToUint16(f16vec3);u16vec4  float16BitsToUint16(f16vec4);float16_t int16BitsToFloat16(int16_t);f16vec2   int16BitsToFloat16(i16vec2);f16vec3   int16BitsToFloat16(i16vec3);f16vec4   int16BitsToFloat16(i16vec4);float16_t uint16BitsToFloat16(uint16_t);f16vec2   uint16BitsToFloat16(u16vec2);f16vec3   uint16BitsToFloat16(u16vec3);f16vec4   uint16BitsToFloat16(u16vec4);float16_t int16BitsToHalf(int16_t);f16vec2   int16BitsToHalf(i16vec2);f16vec3   int16BitsToHalf(i16vec3);f16vec4   int16BitsToHalf(i16vec4);float16_t uint16BitsToHalf(uint16_t);f16vec2   uint16BitsToHalf(u16vec2);f16vec3   uint16BitsToHalf(u16vec3);f16vec4   uint16BitsToHalf(u16vec4);int      packInt2x16(i16vec2);uint     packUint2x16(u16vec2);int64_t  packInt4x16(i16vec4);uint64_t packUint4x16(u16vec4);i16vec2  unpackInt2x16(int);u16vec2  unpackUint2x16(uint);i16vec4  unpackInt4x16(int64_t);u16vec4  unpackUint4x16(uint64_t);bvec2 lessThan(i16vec2, i16vec2);bvec3 lessThan(i16vec3, i16vec3);bvec4 lessThan(i16vec4, i16vec4);bvec2 lessThan(u16vec2, u16vec2);bvec3 lessThan(u16vec3, u16vec3);bvec4 lessThan(u16vec4, u16vec4);bvec2 lessThanEqual(i16vec2, i16vec2);bvec3 lessThanEqual(i16vec3, i16vec3);bvec4 lessThanEqual(i16vec4, i16vec4);bvec2 lessThanEqual(u16vec2, u16vec2);bvec3 lessThanEqual(u16vec3, u16vec3);bvec4 lessThanEqual(u16vec4, u16vec4);bvec2 greaterThan(i16vec2, i16vec2);bvec3 greaterThan(i16vec3, i16vec3);bvec4 greaterThan(i16vec4, i16vec4);bvec2 greaterThan(u16vec2, u16vec2);bvec3 greaterThan(u16vec3, u16vec3);bvec4 greaterThan(u16vec4, u16vec4);bvec2 greaterThanEqual(i16vec2, i16vec2);bvec3 greaterThanEqual(i16vec3, i16vec3);bvec4 greaterThanEqual(i16vec4, i16vec4);bvec2 greaterThanEqual(u16vec2, u16vec2);bvec3 greaterThanEqual(u16vec3, u16vec3);bvec4 greaterThanEqual(u16vec4, u16vec4);bvec2 equal(i16vec2, i16vec2);bvec3 equal(i16vec3, i16vec3);bvec4 equal(i16vec4, i16vec4);bvec2 equal(u16vec2, u16vec2);bvec3 equal(u16vec3, u16vec3);bvec4 equal(u16vec4, u16vec4);bvec2 notEqual(i16vec2, i16vec2);bvec3 notEqual(i16vec3, i16vec3);bvec4 notEqual(i16vec4, i16vec4);bvec2 notEqual(u16vec2, u16vec2);bvec3 notEqual(u16vec3, u16vec3);bvec4 notEqual(u16vec4, u16vec4);  int16_t bitfieldExtract(  int16_t, int16_t, int16_t);i16vec2 bitfieldExtract(i16vec2, int16_t, int16_t);i16vec3 bitfieldExtract(i16vec3, int16_t, int16_t);i16vec4 bitfieldExtract(i16vec4, int16_t, int16_t); uint16_t bitfieldExtract( uint16_t, int16_t, int16_t);u16vec2 bitfieldExtract(u16vec2, int16_t, int16_t);u16vec3 bitfieldExtract(u16vec3, int16_t, int16_t);u16vec4 bitfieldExtract(u16vec4, int16_t, int16_t);  int16_t bitfieldInsert(  int16_t base,   int16_t, int16_t, int16_t);i16vec2 bitfieldInsert(i16vec2 base, i16vec2, int16_t, int16_t);i16vec3 bitfieldInsert(i16vec3 base, i16vec3, int16_t, int16_t);i16vec4 bitfieldInsert(i16vec4 base, i16vec4, int16_t, int16_t); uint16_t bitfieldInsert( uint16_t base,  uint16_t, int16_t, int16_t);u16vec2 bitfieldInsert(u16vec2 base, u16vec2, int16_t, int16_t);u16vec3 bitfieldInsert(u16vec3 base, u16vec3, int16_t, int16_t);u16vec4 bitfieldInsert(u16vec4 base, u16vec4, int16_t, int16_t);  int16_t bitCount(  int16_t);i16vec2 bitCount(i16vec2);i16vec3 bitCount(i16vec3);i16vec4 bitCount(i16vec4);  int16_t bitCount( uint16_t);i16vec2 bitCount(u16vec2);i16vec3 bitCount(u16vec3);i16vec4 bitCount(u16vec4);  int16_t findLSB(  int16_t);i16vec2 findLSB(i16vec2);i16vec3 findLSB(i16vec3);i16vec4 findLSB(i16vec4);  int16_t findLSB( uint16_t);i16vec2 findLSB(u16vec2);i16vec3 findLSB(u16vec3);i16vec4 findLSB(u16vec4);  int16_t findMSB(  int16_t);i16vec2 findMSB(i16vec2);i16vec3 findMSB(i16vec3);i16vec4 findMSB(i16vec4);  int16_t findMSB( uint16_t);i16vec2 findMSB(u16vec2);i16vec3 findMSB(u16vec3);i16vec4 findMSB(u16vec4);int16_t  pack16(i8vec2);uint16_t pack16(u8vec2);int32_t  pack32(i8vec4);uint32_t pack32(u8vec4);int32_t  pack32(i16vec2);uint32_t pack32(u16vec2);int64_t  pack64(i16vec4);uint64_t pack64(u16vec4);int64_t  pack64(i32vec2);uint64_t pack64(u32vec2);i8vec2   unpack8(int16_t);u8vec2   unpack8(uint16_t);i8vec4   unpack8(int32_t);u8vec4   unpack8(uint32_t);i16vec2  unpack16(int32_t);u16vec2  unpack16(uint32_t);i16vec4  unpack16(int64_t);u16vec4  unpack16(uint64_t);i32vec2  unpack32(int64_t);u32vec2  unpack32(uint64_t);float64_t radians(float64_t);f64vec2   radians(f64vec2);f64vec3   radians(f64vec3);f64vec4   radians(f64vec4);float64_t degrees(float64_t);f64vec2   degrees(f64vec2);f64vec3   degrees(f64vec3);f64vec4   degrees(f64vec4);float64_t sin(float64_t);f64vec2   sin(f64vec2);f64vec3   sin(f64vec3);f64vec4   sin(f64vec4);float64_t cos(float64_t);f64vec2   cos(f64vec2);f64vec3   cos(f64vec3);f64vec4   cos(f64vec4);float64_t tan(float64_t);f64vec2   tan(f64vec2);f64vec3   tan(f64vec3);f64vec4   tan(f64vec4);float64_t asin(float64_t);f64vec2   asin(f64vec2);f64vec3   asin(f64vec3);f64vec4   asin(f64vec4);float64_t acos(float64_t);f64vec2   acos(f64vec2);f64vec3   acos(f64vec3);f64vec4   acos(f64vec4);float64_t atan(float64_t, float64_t);f64vec2   atan(f64vec2,   f64vec2);f64vec3   atan(f64vec3,   f64vec3);f64vec4   atan(f64vec4,   f64vec4);float64_t atan(float64_t);f64vec2   atan(f64vec2);f64vec3   atan(f64vec3);f64vec4   atan(f64vec4);float64_t sinh(float64_t);f64vec2   sinh(f64vec2);f64vec3   sinh(f64vec3);f64vec4   sinh(f64vec4);float64_t cosh(float64_t);f64vec2   cosh(f64vec2);f64vec3   cosh(f64vec3);f64vec4   cosh(f64vec4);float64_t tanh(float64_t);f64vec2   tanh(f64vec2);f64vec3   tanh(f64vec3);f64vec4   tanh(f64vec4);float64_t asinh(float64_t);f64vec2   asinh(f64vec2);f64vec3   asinh(f64vec3);f64vec4   asinh(f64vec4);float64_t acosh(float64_t);f64vec2   acosh(f64vec2);f64vec3   acosh(f64vec3);f64vec4   acosh(f64vec4);float64_t atanh(float64_t);f64vec2   atanh(f64vec2);f64vec3   atanh(f64vec3);f64vec4   atanh(f64vec4);float64_t pow(float64_t, float64_t);f64vec2   pow(f64vec2,   f64vec2);f64vec3   pow(f64vec3,   f64vec3);f64vec4   pow(f64vec4,   f64vec4);float64_t exp(float64_t);f64vec2   exp(f64vec2);f64vec3   exp(f64vec3);f64vec4   exp(f64vec4);float64_t log(float64_t);f64vec2   log(f64vec2);f64vec3   log(f64vec3);f64vec4   log(f64vec4);float64_t exp2(float64_t);f64vec2   exp2(f64vec2);f64vec3   exp2(f64vec3);f64vec4   exp2(f64vec4);float64_t log2(float64_t);f64vec2   log2(f64vec2);f64vec3   log2(f64vec3);f64vec4   log2(f64vec4);\n
float64_t interpolateAtCentroid(float64_t);f64vec2   interpolateAtCentroid(f64vec2);f64vec3   interpolateAtCentroid(f64vec3);f64vec4   interpolateAtCentroid(f64vec4);float64_t interpolateAtSample(float64_t, int);f64vec2   interpolateAtSample(f64vec2,   int);f64vec3   interpolateAtSample(f64vec3,   int);f64vec4   interpolateAtSample(f64vec4,   int);float64_t interpolateAtOffset(float64_t, f64vec2);f64vec2   interpolateAtOffset(f64vec2,   f64vec2);f64vec3   interpolateAtOffset(f64vec3,   f64vec2);f64vec4   interpolateAtOffset(f64vec4,   f64vec2);\n
vec4 texture2DLod(sampler2D, vec2, float);vec4 texture2DProjLod(sampler2D, vec3, float);vec4 texture2DProjLod(sampler2D, vec4, float);vec4 texture3DLod(sampler3D, vec3, float);vec4 texture3DProjLod(sampler3D, vec4, float);vec4 textureCubeLod(samplerCube, vec3, float);\n
vec4 texture1DLod(sampler1D, float, float);vec4 texture1DProjLod(sampler1D, vec2, float);vec4 texture1DProjLod(sampler1D, vec4, float);vec4 shadow1DLod(sampler1DShadow, vec3, float);vec4 shadow2DLod(sampler2DShadow, vec3, float);vec4 shadow1DProjLod(sampler1DShadow, vec4, float);vec4 shadow2DProjLod(sampler2DShadow, vec4, float);vec4 texture1DGradARB(sampler1D, float, float, float);vec4 texture1DProjGradARB(sampler1D, vec2, float, float);vec4 texture1DProjGradARB(sampler1D, vec4, float, float);vec4 texture2DGradARB(sampler2D, vec2, vec2, vec2);vec4 texture2DProjGradARB(sampler2D, vec3, vec2, vec2);vec4 texture2DProjGradARB(sampler2D, vec4, vec2, vec2);vec4 texture3DGradARB(sampler3D, vec3, vec3, vec3);vec4 texture3DProjGradARB(sampler3D, vec4, vec3, vec3);vec4 textureCubeGradARB(samplerCube, vec3, vec3, vec3);vec4 shadow1DGradARB(sampler1DShadow, vec3, float, float);vec4 shadow1DProjGradARB( sampler1DShadow, vec4, float, float);vec4 shadow2DGradARB(sampler2DShadow, vec3, vec2, vec2);vec4 shadow2DProjGradARB( sampler2DShadow, vec4, vec2, vec2);vec4 texture2DRectGradARB(sampler2DRect, vec2, vec2, vec2);vec4 texture2DRectProjGradARB( sampler2DRect, vec3, vec2, vec2);vec4 texture2DRectProjGradARB( sampler2DRect, vec4, vec2, vec2);vec4 shadow2DRectGradARB( sampler2DRectShadow, vec3, vec2, vec2);vec4 shadow2DRectProjGradARB(sampler2DRectShadow, vec4, vec2, vec2);\n
void memoryBarrierAtomicCounter();void memoryBarrierBuffer();void memoryBarrierImage();
void memoryBarrierShared();void groupMemoryBarrier();
vec4 texture2D(sampler2D, vec2, float);vec4 texture2DProj(sampler2D, vec3, float);vec4 texture2DProj(sampler2D, vec4, float);vec4 texture3D(sampler3D, vec3, float);vec4 texture3DProj(sampler3D, vec4, float);vec4 textureCube(samplerCube, vec3, float);\n
vec4 texture1D(sampler1D, float, float);vec4 texture1DProj(sampler1D, vec2, float);vec4 texture1DProj(sampler1D, vec4, float);vec4 shadow1D(sampler1DShadow, vec3, float);vec4 shadow2D(sampler2DShadow, vec3, float);vec4 shadow1DProj(sampler1DShadow, vec4, float);vec4 shadow2DProj(sampler2DShadow, vec4, float);\n
vec4 texture2DLodEXT(sampler2D, vec2, float);vec4 texture2DProjLodEXT(sampler2D, vec3, float);vec4 texture2DProjLodEXT(sampler2D, vec4, float);vec4 textureCubeLodEXT(samplerCube, vec3, float);\n
float interpolateAtCentroid(float);vec2  interpolateAtCentroid(vec2);vec3  interpolateAtCentroid(vec3);vec4  interpolateAtCentroid(vec4);float interpolateAtSample(float, int);vec2  interpolateAtSample(vec2,  int);vec3  interpolateAtSample(vec3,  int);vec4  interpolateAtSample(vec4,  int);float interpolateAtOffset(float, vec2);vec2  interpolateAtOffset(vec2,  vec2);vec3  interpolateAtOffset(vec3,  vec2);vec4  interpolateAtOffset(vec4,  vec2);\n
void beginInvocationInterlockARB(void);void endInvocationInterlockARB(void);
float interpolateAtVertexAMD(float, uint);vec2  interpolateAtVertexAMD(vec2,  uint);vec3  interpolateAtVertexAMD(vec3,  uint);vec4  interpolateAtVertexAMD(vec4,  uint);int   interpolateAtVertexAMD(int,   uint);ivec2 interpolateAtVertexAMD(ivec2, uint);ivec3 interpolateAtVertexAMD(ivec3, uint);ivec4 interpolateAtVertexAMD(ivec4, uint);uint  interpolateAtVertexAMD(uint,  uint);uvec2 interpolateAtVertexAMD(uvec2, uint);uvec3 interpolateAtVertexAMD(uvec3, uint);uvec4 interpolateAtVertexAMD(uvec4, uint);float16_t interpolateAtVertexAMD(float16_t, uint);f16vec2   interpolateAtVertexAMD(f16vec2,   uint);f16vec3   interpolateAtVertexAMD(f16vec3,   uint);f16vec4   interpolateAtVertexAMD(f16vec4,   uint);\n
float16_t interpolateAtCentroid(float16_t);f16vec2   interpolateAtCentroid(f16vec2);f16vec3   interpolateAtCentroid(f16vec3);f16vec4   interpolateAtCentroid(f16vec4);float16_t interpolateAtSample(float16_t, int);f16vec2   interpolateAtSample(f16vec2,   int);f16vec3   interpolateAtSample(f16vec3,   int);f16vec4   interpolateAtSample(f16vec4,   int);float16_t interpolateAtOffset(float16_t, f16vec2);f16vec2   interpolateAtOffset(f16vec2,   f16vec2);f16vec3   interpolateAtOffset(f16vec3,   f16vec2);f16vec4   interpolateAtOffset(f16vec4,   f16vec2);\n
uvec2 clock2x32ARB();uint64_t clockARB();uvec2 clockRealtime2x32EXT();uint64_t clockRealtimeEXT();\n
uint fragmentMaskFetchAMD(subpassInputMS);uint fragmentMaskFetchAMD(isubpassInputMS);uint fragmentMaskFetchAMD(usubpassInputMS);vec4  fragmentFetchAMD(subpassInputMS,  uint);ivec4 fragmentFetchAMD(isubpassInputMS, uint);uvec4 fragmentFetchAMD(usubpassInputMS, uint);\n
void traceNV(accelerationStructureNV,uint,uint,uint,uint,uint,vec3,float,vec3,float,int);void executeCallableNV(uint, int);\n
bool reportIntersectionNV(float, uint);\n
void ignoreIntersectionNV();void terminateRayNV();\n
void executeCallableNV(uint, int);\n
void writePackedPrimitiveIndices4x8NV(uint, uint);\n
struct gl_DepthRangeParameters {
highp float near;highp float far;highp float diff;
float near;float far;float diff;
};uniform gl_DepthRangeParameters gl_DepthRange;\n
uniform mat4  gl_ModelViewMatrix;uniform mat4  gl_ProjectionMatrix;uniform mat4  gl_ModelViewProjectionMatrix;uniform mat3  gl_NormalMatrix;uniform mat4  gl_ModelViewMatrixInverse;uniform mat4  gl_ProjectionMatrixInverse;uniform mat4  gl_ModelViewProjectionMatrixInverse;uniform mat4  gl_ModelViewMatrixTranspose;uniform mat4  gl_ProjectionMatrixTranspose;uniform mat4  gl_ModelViewProjectionMatrixTranspose;uniform mat4  gl_ModelViewMatrixInverseTranspose;uniform mat4  gl_ProjectionMatrixInverseTranspose;uniform mat4  gl_ModelViewProjectionMatrixInverseTranspose;uniform float gl_NormalScale;struct gl_PointParameters {float size;float sizeMin;float sizeMax;float fadeThresholdSize;float distanceConstantAttenuation;float distanceLinearAttenuation;float distanceQuadraticAttenuation;};uniform gl_PointParameters gl_Point;struct gl_MaterialParameters {vec4  emission;vec4  ambient;vec4  diffuse;vec4  specular;float shininess;};uniform gl_MaterialParameters  gl_FrontMaterial;uniform gl_MaterialParameters  gl_BackMaterial;struct gl_LightSourceParameters {vec4  ambient;vec4  diffuse;vec4  specular;vec4  position;vec4  halfVector;vec3  spotDirection;float spotExponent;float spotCutoff;float spotCosCutoff;float constantAttenuation;float linearAttenuation;float quadraticAttenuation;};struct gl_LightModelParameters {vec4  ambient;};uniform gl_LightModelParameters  gl_LightModel;struct gl_LightModelProducts {vec4  sceneColor;};uniform gl_LightModelProducts gl_FrontLightModelProduct;uniform gl_LightModelProducts gl_BackLightModelProduct;struct gl_LightProducts {vec4  ambient;vec4  diffuse;vec4  specular;};struct gl_FogParameters {vec4  color;float density;float start;float end;float scale;};uniform gl_FogParameters gl_Fog;\n
in    highp uvec3 gl_NumWorkGroups;const highp uvec3 gl_WorkGroupSize = uvec3(1,1,1);in highp uvec3 gl_WorkGroupID;in highp uvec3 gl_LocalInvocationID;in highp uvec3 gl_GlobalInvocationID;in highp uint gl_LocalInvocationIndex;\n
attribute vec4  gl_Color;attribute vec4  gl_SecondaryColor;attribute vec3  gl_Normal;attribute vec4  gl_Vertex;attribute vec4  gl_MultiTexCoord0;attribute vec4  gl_MultiTexCoord1;attribute vec4  gl_MultiTexCoord2;attribute vec4  gl_MultiTexCoord3;attribute vec4  gl_MultiTexCoord4;attribute vec4  gl_MultiTexCoord5;attribute vec4  gl_MultiTexCoord6;attribute vec4  gl_MultiTexCoord7;attribute float gl_FogCoord;\n
        vec4  gl_ClipVertex;varying vec4  gl_FrontColor;varying vec4  gl_BackColor;varying vec4  gl_FrontSecondaryColor;varying vec4  gl_BackSecondaryColor;varying vec4  gl_TexCoord[];varying float gl_FogFragCoord;\n
vec4 gl_Position;float gl_PointSize;
out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];
in int gl_VertexIndex;in int gl_InstanceIndex;
in int gl_BaseVertexARB;in int gl_BaseInstanceARB;in int gl_DrawIDARB;
out int gl_ViewportIndex;out int gl_Layer;
in int gl_BaseVertex;in int gl_BaseInstance;in int gl_DrawID;
out int gl_ViewportMask[];out int gl_SecondaryViewportMaskNV[];out vec4 gl_SecondaryPositionNV;out vec4 gl_PositionPerViewNV[];out int  gl_ViewportMaskPerViewNV[];
highp   vec4  gl_Position;mediump float gl_PointSize;
in highp int gl_VertexID;in highp int gl_InstanceID;
in highp int gl_VertexIndex;in highp int gl_InstanceIndex;
highp vec4  gl_Position;highp float gl_PointSize;
out gl_PerVertex {highp vec4  gl_Position;highp float gl_PointSize;};
in highp int gl_DeviceIndex;in highp int gl_ViewIndex;\n
} gl_in[];in int gl_PrimitiveIDIn;out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];\n
};out int gl_PrimitiveID;out int gl_Layer;
in gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;} gl_in[];\nin highp int gl_PrimitiveIDIn;in highp int gl_InvocationID;\nout gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;};\nout highp int gl_PrimitiveID;out highp int gl_Layer;\n
in int gl_PatchVerticesIn;in int gl_PrimitiveID;in int gl_InvocationID;out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];
float gl_CullDistance[];int  gl_ViewportMask[];vec4 gl_SecondaryPositionNV;int  gl_SecondaryViewportMaskNV[];vec4 gl_PositionPerViewNV[];int  gl_ViewportMaskPerViewNV[];
} gl_out[];patch out float gl_TessLevelOuter[4];patch out float gl_TessLevelInner[2];\n
out int gl_ViewportIndex;out int gl_Layer;\n
in highp int gl_PatchVerticesIn;in highp int gl_PrimitiveID;in highp int gl_InvocationID;out gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;
} gl_out[];patch out highp float gl_TessLevelOuter[4];patch out highp float gl_TessLevelInner[2];patch out highp vec4 gl_BoundingBoxOES[2];patch out highp vec4 gl_BoundingBoxEXT[2];\n
patch out highp vec4 gl_BoundingBox[2];\n
in int gl_PatchVerticesIn;in int gl_PrimitiveID;in vec3 gl_TessCoord;patch in float gl_TessLevelOuter[4];patch in float gl_TessLevelInner[2];out gl_PerVertex {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];
out int  gl_ViewportMask[];out vec4 gl_SecondaryPositionNV;out int  gl_SecondaryViewportMaskNV[];out vec4 gl_PositionPerViewNV[];out int  gl_ViewportMaskPerViewNV[];
in highp int gl_PatchVerticesIn;in highp int gl_PrimitiveID;in highp vec3 gl_TessCoord;patch in highp float gl_TessLevelOuter[4];patch in highp float gl_TessLevelInner[2];out gl_PerVertex {highp vec4 gl_Position;highp float gl_PointSize;
vec4  gl_FragCoord;bool  gl_FrontFacing;float gl_FragDepth;
varying vec4  gl_Color;varying vec4  gl_SecondaryColor;varying vec4  gl_TexCoord[];varying float gl_FogFragCoord;
in float gl_FogFragCoord;in vec4  gl_TexCoord[];in vec4  gl_Color;in vec4  gl_SecondaryColor;
in gl_PerFragment {in float gl_FogFragCoord;in vec4  gl_TexCoord[];in vec4  gl_Color;in vec4  gl_SecondaryColor;};
flat in  int  gl_SampleID;     in  vec2 gl_SamplePosition;flat in  int  gl_SampleMaskIn[];     out int  gl_SampleMask[];
flat in int gl_Layer;flat in int gl_ViewportIndex;
in float gl_CullDistance[];bool gl_HelperInvocation;
flat in ivec2 gl_FragSizeEXT;flat in int   gl_FragInvocationCountEXT;
in vec2 gl_BaryCoordNoPerspAMD;in vec2 gl_BaryCoordNoPerspCentroidAMD;in vec2 gl_BaryCoordNoPerspSampleAMD;in vec2 gl_BaryCoordSmoothAMD;in vec2 gl_BaryCoordSmoothCentroidAMD;in vec2 gl_BaryCoordSmoothSampleAMD;in vec3 gl_BaryCoordPullModelAMD;
in bool gl_FragFullyCoveredNV;
flat in ivec2 gl_FragmentSizeNV;flat in int   gl_InvocationsPerPixelNV;in vec3 gl_BaryCoordNV;in vec3 gl_BaryCoordNoPerspNV;
mediump vec4 gl_FragCoord;        bool gl_FrontFacing;mediump vec4 gl_FragColor;mediump vec2 gl_PointCoord;
highp   vec4  gl_FragCoord;        bool  gl_FrontFacing;mediump vec2  gl_PointCoord;highp   float gl_FragDepth;
bool gl_HelperInvocation;flat in highp int gl_PrimitiveID;flat in highp int gl_Layer;
flat  in lowp     int gl_SampleID;      in mediump vec2 gl_SamplePosition;flat  in highp    int gl_SampleMaskIn[];     out highp    int gl_SampleMask[];
uniform lowp int gl_NumSamples;
flat in ivec2 gl_FragmentSizeNV;flat in int   gl_InvocationsPerPixelNV;
in vec3 gl_BaryCoordNV;in vec3 gl_BaryCoordNoPerspNV;
uniform uint gl_SubGroupSizeARB;in uint     gl_SubGroupInvocationARB;in uint64_t gl_SubGroupEqMaskARB;in uint64_t gl_SubGroupGeMaskARB;in uint64_t gl_SubGroupGtMaskARB;in uint64_t gl_SubGroupLeMaskARB;in uint64_t gl_SubGroupLtMaskARB;\n
uniform uint gl_SubGroupSizeARB;flat in uint     gl_SubGroupInvocationARB;flat in uint64_t gl_SubGroupEqMaskARB;flat in uint64_t gl_SubGroupGeMaskARB;flat in uint64_t gl_SubGroupGtMaskARB;flat in uint64_t gl_SubGroupLeMaskARB;flat in uint64_t gl_SubGroupLtMaskARB;\n
flat in highp int gl_DeviceIndex;flat in highp int gl_ViewIndex;\n
in mediump uint  gl_SubgroupSize;in mediump uint  gl_SubgroupInvocationID;in highp   uvec4 gl_SubgroupEqMask;in highp   uvec4 gl_SubgroupGeMask;in highp   uvec4 gl_SubgroupGtMask;in highp   uvec4 gl_SubgroupLeMask;in highp   uvec4 gl_SubgroupLtMask;in highp   uint  gl_WarpsPerSMNV;in highp   uint  gl_SMCountNV;in highp   uint  gl_WarpIDNV;in highp   uint  gl_SMIDNV;\n
in highp   uint  gl_NumSubgroups;in highp   uint  gl_SubgroupID;\n
flat in mediump uint  gl_SubgroupSize;flat in mediump uint  gl_SubgroupInvocationID;flat in highp   uvec4 gl_SubgroupEqMask;flat in highp   uvec4 gl_SubgroupGeMask;flat in highp   uvec4 gl_SubgroupGtMask;flat in highp   uvec4 gl_SubgroupLeMask;flat in highp   uvec4 gl_SubgroupLtMask;flat in highp   uint  gl_WarpsPerSMNV;flat in highp   uint  gl_SMCountNV;flat in highp   uint  gl_WarpIDNV;flat in highp   uint  gl_SMIDNV;\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchSizeNV;\n
const uint gl_RayFlagsNoneNV = 0U;const uint gl_RayFlagsOpaqueNV = 1U;const uint gl_RayFlagsNoOpaqueNV = 2U;const uint gl_RayFlagsTerminateOnFirstHitNV = 4U;const uint gl_RayFlagsSkipClosestHitShaderNV = 8U;const uint gl_RayFlagsCullBackFacingTrianglesNV = 16U;const uint gl_RayFlagsCullFrontFacingTrianglesNV = 32U;const uint gl_RayFlagsCullOpaqueNV = 64U;const uint gl_RayFlagsCullNoOpaqueNV = 128U;\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchSizeNV;in     int   gl_PrimitiveID;in     int   gl_InstanceID;in     int   gl_InstanceCustomIndexNV;in    vec3   gl_WorldRayOriginNV;in    vec3   gl_WorldRayDirectionNV;in    vec3   gl_ObjectRayOriginNV;in    vec3   gl_ObjectRayDirectionNV;in    float  gl_RayTminNV;in    float  gl_RayTmaxNV;in    mat4x3 gl_ObjectToWorldNV;in    mat4x3 gl_WorldToObjectNV;in    uint   gl_IncomingRayFlagsNV;\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchSizeNV;in     int   gl_PrimitiveID;in     int   gl_InstanceID;in     int   gl_InstanceCustomIndexNV;in    vec3   gl_WorldRayOriginNV;in    vec3   gl_WorldRayDirectionNV;in    vec3   gl_ObjectRayOriginNV;in    vec3   gl_ObjectRayDirectionNV;in    float  gl_RayTminNV;in    float  gl_RayTmaxNV;in    float  gl_HitTNV;in    uint   gl_HitKindNV;in    mat4x3 gl_ObjectToWorldNV;in    mat4x3 gl_WorldToObjectNV;in    uint   gl_IncomingRayFlagsNV;\n
in    uvec3  gl_LaunchIDNV;in    uvec3  gl_LaunchSizeNV;in    vec3   gl_WorldRayOriginNV;in    vec3   gl_WorldRayDirectionNV;in    vec3   gl_ObjectRayOriginNV;in    vec3   gl_ObjectRayDirectionNV;in    float  gl_RayTminNV;in    float  gl_RayTmaxNV;in    uint   gl_IncomingRayFlagsNV;\n
flat in highp uint gl_ViewID_OVR;\n
const int gl_ScopeDevice      = 1;\n
const int gl_ScopeWorkgroup   = 2;\n
const int gl_ScopeSubgroup    = 3;\n
const int gl_ScopeInvocation  = 4;\n
const int gl_ScopeQueueFamily = 5;\n
const int gl_SemanticsRelaxed         = 0x0;\n
const int gl_SemanticsAcquire         = 0x2;\n
const int gl_SemanticsRelease         = 0x4;\n
const int gl_SemanticsAcquireRelease  = 0x8;\n
const int gl_SemanticsMakeAvailable   = 0x2000;\n
const int gl_SemanticsMakeVisible     = 0x4000;\n
const int gl_SemanticsVolatile        = 0x8000;\n
const int gl_StorageSemanticsNone     = 0x0;\n
const int gl_StorageSemanticsBuffer   = 0x40;\n
const int gl_StorageSemanticsShared   = 0x100;\n
const int gl_StorageSemanticsImage    = 0x800;\n
const int gl_StorageSemanticsOutput   = 0x1000;\n
float  fma(float,  float,  float );vec2   fma(vec2,   vec2,   vec2  );vec3   fma(vec3,   vec3,   vec3  );vec4   fma(vec4,   vec4,   vec4  );\n
float frexp(highp float, out highp int);vec2  frexp(highp vec2,  out highp ivec2);vec3  frexp(highp vec3,  out highp ivec3);vec4  frexp(highp vec4,  out highp ivec4);float ldexp(highp float, highp int);vec2  ldexp(highp vec2,  highp ivec2);vec3  ldexp(highp vec3,  highp ivec3);vec4  ldexp(highp vec4,  highp ivec4);\n
double fma(double, double, double);dvec2  fma(dvec2,  dvec2,  dvec2 );dvec3  fma(dvec3,  dvec3,  dvec3 );dvec4  fma(dvec4,  dvec4,  dvec4 );\n
void controlBarrier(int, int, int, int);\nvoid memoryBarrier(int, int, int);\n
in vec4  gl_Color;in vec4  gl_SecondaryColor;in vec3  gl_Normal;in vec4  gl_Vertex;in vec4  gl_MultiTexCoord0;in vec4  gl_MultiTexCoord1;in vec4  gl_MultiTexCoord2;in vec4  gl_MultiTexCoord3;in vec4  gl_MultiTexCoord4;in vec4  gl_MultiTexCoord5;in vec4  gl_MultiTexCoord6;in vec4  gl_MultiTexCoord7;in float gl_FogCoord;\n
    vec4  gl_ClipVertex;out vec4  gl_FrontColor;out vec4  gl_BackColor;out vec4  gl_FrontSecondaryColor;out vec4  gl_BackSecondaryColor;out vec4  gl_TexCoord[];out float gl_FogFragCoord;\n
highp uint packUnorm2x16(vec2);vec2 unpackUnorm2x16(highp uint);\n
highp uint packSnorm2x16(vec2);      vec2 unpackSnorm2x16(highp uint);highp uint packHalf2x16(vec2);\n
mediump vec2 unpackHalf2x16(highp uint);\n
highp uint packSnorm4x8(vec4);highp uint packUnorm4x8(vec4);\n
mediump vec4 unpackSnorm4x8(highp uint);mediump vec4 unpackUnorm4x8(highp uint);\n
vec4 unpackSnorm4x8(highp uint);vec4 unpackUnorm4x8(highp uint);\n
  int bitfieldExtract(  int, int, int);ivec2 bitfieldExtract(ivec2, int, int);ivec3 bitfieldExtract(ivec3, int, int);ivec4 bitfieldExtract(ivec4, int, int); uint bitfieldExtract( uint, int, int);uvec2 bitfieldExtract(uvec2, int, int);uvec3 bitfieldExtract(uvec3, int, int);uvec4 bitfieldExtract(uvec4, int, int);  int bitfieldInsert(  int base,   int, int, int);ivec2 bitfieldInsert(ivec2 base, ivec2, int, int);ivec3 bitfieldInsert(ivec3 base, ivec3, int, int);ivec4 bitfieldInsert(ivec4 base, ivec4, int, int); uint bitfieldInsert( uint base,  uint, int, int);uvec2 bitfieldInsert(uvec2 base, uvec2, int, int);uvec3 bitfieldInsert(uvec3 base, uvec3, int, int);uvec4 bitfieldInsert(uvec4 base, uvec4, int, int);\n
lowp   int findLSB(  int);lowp ivec2 findLSB(ivec2);lowp ivec3 findLSB(ivec3);lowp ivec4 findLSB(ivec4);lowp   int findLSB( uint);lowp ivec2 findLSB(uvec2);lowp ivec3 findLSB(uvec3);lowp ivec4 findLSB(uvec4);\n
 uint uaddCarry(highp  uint, highp  uint, out lowp  uint carry);uvec2 uaddCarry(highp uvec2, highp uvec2, out lowp uvec2 carry);uvec3 uaddCarry(highp uvec3, highp uvec3, out lowp uvec3 carry);uvec4 uaddCarry(highp uvec4, highp uvec4, out lowp uvec4 carry); uint usubBorrow(highp  uint, highp  uint, out lowp  uint borrow);uvec2 usubBorrow(highp uvec2, highp uvec2, out lowp uvec2 borrow);uvec3 usubBorrow(highp uvec3, highp uvec3, out lowp uvec3 borrow);uvec4 usubBorrow(highp uvec4, highp uvec4, out lowp uvec4 borrow);void umulExtended(highp  uint, highp  uint, out highp  uint, out highp  uint lsb);void umulExtended(highp uvec2, highp uvec2, out highp uvec2, out highp uvec2 lsb);void umulExtended(highp uvec3, highp uvec3, out highp uvec3, out highp uvec3 lsb);void umulExtended(highp uvec4, highp uvec4, out highp uvec4, out highp uvec4 lsb);void imulExtended(highp   int, highp   int, out highp   int, out highp   int lsb);void imulExtended(highp ivec2, highp ivec2, out highp ivec2, out highp ivec2 lsb);void imulExtended(highp ivec3, highp ivec3, out highp ivec3, out highp ivec3 lsb);void imulExtended(highp ivec4, highp ivec4, out highp ivec4, out highp ivec4 lsb);  int bitfieldReverse(highp   int);ivec2 bitfieldReverse(highp ivec2);ivec3 bitfieldReverse(highp ivec3);ivec4 bitfieldReverse(highp ivec4); uint bitfieldReverse(highp  uint);uvec2 bitfieldReverse(highp uvec2);uvec3 bitfieldReverse(highp uvec3);uvec4 bitfieldReverse(highp uvec4);\n
lowp   int bitCount(  int);lowp ivec2 bitCount(ivec2);lowp ivec3 bitCount(ivec3);lowp ivec4 bitCount(ivec4);lowp   int bitCount( uint);lowp ivec2 bitCount(uvec2);lowp ivec3 bitCount(uvec3);lowp ivec4 bitCount(uvec4);lowp   int findMSB(highp   int);lowp ivec2 findMSB(highp ivec2);lowp ivec3 findMSB(highp ivec3);lowp ivec4 findMSB(highp ivec4);lowp   int findMSB(highp  uint);lowp ivec2 findMSB(highp uvec2);lowp ivec3 findMSB(highp uvec3);lowp ivec4 findMSB(highp uvec4);\n
void EmitVertex();void EndPrimitive();\n
void coopMatLoadNV(out fcoopmatNV m, volatile coherent float16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent float[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out fcoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent float16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent float[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent float64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(fcoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nfcoopmatNV coopMatMulAddNV(fcoopmatNV A, fcoopmatNV B, fcoopmatNV C);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out icoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatLoadNV(out ucoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(icoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent int64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent ivec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent ivec4[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint8_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint16_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uint64_t[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uvec2[] buf, uint element, uint stride, bool colMajor);\nvoid coopMatStoreNV(ucoopmatNV m, volatile coherent uvec4[] buf, uint element, uint stride, bool colMajor);\nicoopmatNV coopMatMulAddNV(icoopmatNV A, icoopmatNV B, icoopmatNV C);\nucoopmatNV coopMatMulAddNV(ucoopmatNV A, ucoopmatNV B, ucoopmatNV C);\n
out gl_MeshPerVertexNV {vec4 gl_Position;float gl_PointSize;float gl_ClipDistance[];float gl_CullDistance[];perviewNV vec4 gl_PositionPerViewNV[];perviewNV float gl_ClipDistancePerViewNV[][];perviewNV float gl_CullDistancePerViewNV[][];} gl_MeshVerticesNV[];
perprimitiveNV out gl_MeshPerPrimitiveNV {int gl_PrimitiveID;int gl_Layer;int gl_ViewportIndex;int gl_ViewportMask[];perviewNV int gl_LayerPerViewNV[];perviewNV int gl_ViewportMaskPerViewNV[][];} gl_MeshPrimitivesNV[];
out uint gl_PrimitiveCountNV;out uint gl_PrimitiveIndicesNV[];in uint gl_MeshViewCountNV;in uint gl_MeshViewIndicesNV[4];const highp uvec3 gl_WorkGroupSize = uvec3(1,1,1);in highp uvec3 gl_WorkGroupID;in highp uvec3 gl_LocalInvocationID;in highp uvec3 gl_GlobalInvocationID;in highp uint gl_LocalInvocationIndex;\n
out uint gl_TaskCountNV;const highp uvec3 gl_WorkGroupSize = uvec3(1,1,1);in highp uvec3 gl_WorkGroupID;in highp uvec3 gl_LocalInvocationID;in highp uvec3 gl_GlobalInvocationID;in highp uint gl_LocalInvocationIndex;in uint gl_MeshViewCountNV;in uint gl_MeshViewIndicesNV[4];\n
in highp int gl_DeviceIndex;in int gl_DrawIDARB;\n
        vec2 unpackHalf2x16(highp uint);\n
float cubeFaceIndexAMD(vec3);vec2  cubeFaceCoordAMD(vec3);uint64_t timeAMD();in int gl_SIMDGroupSizeAMD;\n
void EmitStreamVertex(int);void EndStreamPrimitive(int);
sparseTextureGradOffsetClampARB
gl_BaryCoordNoPerspCentroidAMD
sparseTextureGatherLodOffsetAMD
sparseTextureGatherLodOffsetsAMD
gl_MaxComputeUniformComponents
gl_MaxComputeTextureImageUnits
gl_MaxComputeAtomicCounterBuffers
minInvocationsInclusiveScanAMD
maxInvocationsInclusiveScanAMD
addInvocationsInclusiveScanAMD
minInvocationsInclusiveScanNonUniformAMD
maxInvocationsInclusiveScanNonUniformAMD
addInvocationsInclusiveScanNonUniformAMD
minInvocationsExclusiveScanAMD
maxInvocationsExclusiveScanAMD
addInvocationsExclusiveScanAMD
minInvocationsExclusiveScanNonUniformAMD
maxInvocationsExclusiveScanNonUniformAMD
addInvocationsExclusiveScanNonUniformAMD
swizzleInvocationsWithPatternAMD
gl_MaxTransformFeedbackBuffers
gl_MaxTransformFeedbackInterleavedComponents
 imageAtomicAdd(volatile coherent 
 imageAtomicMin(volatile coherent 
 imageAtomicMax(volatile coherent 
 imageAtomicAnd(volatile coherent 
 imageAtomicOr(volatile coherent 
 imageAtomicXor(volatile coherent 
 imageAtomicExchange(volatile coherent 
%s     subgroupBroadcast(%s, uint);\n
%s     subgroupBroadcastFirst(%s);\n
%s     subgroupShuffle(%s, uint);\n
%s     subgroupShuffleXor(%s, uint);\n
%s     subgroupShuffleUp(%s, uint delta);\n
%s     subgroupShuffleDown(%s, uint delta);\n
%s     subgroupInclusiveAdd(%s);\n
%s     subgroupInclusiveMul(%s);\n
%s     subgroupInclusiveMin(%s);\n
%s     subgroupInclusiveMax(%s);\n
%s     subgroupInclusiveAnd(%s);\n
%s     subgroupInclusiveOr(%s);\n
%s     subgroupInclusiveXor(%s);\n
%s     subgroupExclusiveAdd(%s);\n
%s     subgroupExclusiveMul(%s);\n
%s     subgroupExclusiveMin(%s);\n
%s     subgroupExclusiveMax(%s);\n
%s     subgroupExclusiveAnd(%s);\n
%s     subgroupExclusiveOr(%s);\n
%s     subgroupExclusiveXor(%s);\n
%s     subgroupClusteredAdd(%s, uint);\n
%s     subgroupClusteredMul(%s, uint);\n
%s     subgroupClusteredMin(%s, uint);\n
%s     subgroupClusteredMax(%s, uint);\n
%s     subgroupClusteredAnd(%s, uint);\n
%s     subgroupClusteredOr(%s, uint);\n
%s     subgroupClusteredXor(%s, uint);\n
%s     subgroupQuadBroadcast(%s, uint);\n
%s     subgroupQuadSwapHorizontal(%s);\n
%s     subgroupQuadSwapVertical(%s);\n
%s     subgroupQuadSwapDiagonal(%s);\n
uvec4  subgroupPartitionNV(%s);\n
%s     subgroupPartitionedAddNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedMulNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedMinNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedMaxNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedAndNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedOrNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedXorNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedInclusiveAddNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedInclusiveMulNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedInclusiveMinNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedInclusiveMaxNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedInclusiveAndNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedInclusiveOrNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedInclusiveXorNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedExclusiveAddNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedExclusiveMulNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedExclusiveMinNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedExclusiveMaxNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedExclusiveAndNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedExclusiveOrNV(%s, uvec4 ballot);\n
%s     subgroupPartitionedExclusiveXorNV(%s, uvec4 ballot);\n
shift-sampler-binding
shift-texture-binding
shift-image-binding
shift-UBO-binding
shift-ssbo-binding
shift-uav-binding
line continuation
not allowed in this version
__LINE__
__VERSION__
geometry shaders
tessellation shaders
compute shaders
task shaders
mesh shaders
can't modify shader input
can't modify gl_PointCoord
can't modify gl_FragCoord
can't modify gl_FrontFace
can't modify gl_VertexID
can't modify gl_InstanceID
 l-value required
"%s" (%s)
compilation terminated
type must be an array:
Invalid semantics value
call argument
 wrong operand type
 wrong operand types:
constant expression required
not allowed in nested scope
illegal use of type 'void'
boolean expression expected
precision
substituting 'mediump'
must be a positive integer
const array
vertex input arrays
array size required
arrays of arrays
variable index
precise
too many storage qualifiers
replicated qualifiers
location qualifier on input
location qualifier on output
can only be used on an output
xfb layout qualifier
can only be used with buffer
component
(using array)
too large for fragment output
overlapping use of location
offset %d in buffer %d
xfb_offset
overlapping offsets at
layout(binding=X) is required
only apply to images
input_attachment_index
constant_id
[][]
can only be used with a block
point_mode
invocations
local_size
local_size id
max_vertices
early_fragment_tests
max_primitives
num_views
uniform block
buffer block
fragment input block
vertex output block
rayPayloadNV block
rayPayloadInNV block
hitAttributeNV block
callableDataNV block
callableDataInNV block
flat/smooth/noperspective
cannot apply to a block
location is too large
can only apply to an output
in for stage inputs
out for stage outputs
nonuniformEXT
%s (%d)
must be less than or equal to
gl_TexCoord array size
gl_MaxTextureCoords
gl_ClipDistance array size
gl_MaxClipDistances
gl_CullDistance array size
gl_MaxCullDistances
arrayed constructor
cannot construct this type
samplerExternalOES
__samplerExternal2DY2YEXT
(...)
non-constant offset argument
offsets argument
component argument
must be 0, 1, 2, or 3:
texel offset
value is out of range:
imageAtomic
with bias argument
payload number
callable data number
interpolant
vertex index
must be in the range [0, 2]
cluster size
argument must be at least 1
argument must be a power of 2
subgroup op
requires SPIR-V 1.3
Internal Error
max_primitives*
can only apply to 'out'
can only apply to 'in'
cannot apply to input
cannot apply to 'out'
cannot apply to:
post_coverage_coverage
cannot be both specified
derivative_group_quadsNV
derivative_group_linearNV
location/component/index
unexpected use of .length()
reference conversion to uvec2
uvec2 conversion to reference
unsupported construction
can't convert
tempReturn
tempArg
undeclared identifier
redefinition
cannot redeclare after use
limitations
initializer list
non-literal layout-id value
cannot be negative
needs a literal integer
uniform buffer-member align
set is too large
descriptor set
binding is too large
component is too large
xfb_
transform feedback qualifier
xfb_buffer
buffer is too large:
internal max is %d
offset is too large:
1/4 stride is too large:
attachment index is too large
secondary_view_offset
stereo view rendering
buffer_reference_align
must be greater than 0
selecting output stream
value must be 0 or 1
local_size_
local_size_y
local_size_z
local_size_x_id
local_size_y_id
local_size_z_id
local_size_x
can't find function
function already has a body
use-storage-buffer
scalar block layout
image load-store format
image load store
geometry shader passthrough
origin_upper_left
pixel_center_integer
post depth coverage
depth layout qualifier
blend_support
override_coverage
sample mask override coverage
viewport_relative
view port array2
shaderrecordnv
derivative_group_
compute shader derivatives
derivative_group_quadsnv
derivative_group_linearnv
unknown blend equation
optimize
#pragma
use_storage_buffer
extra tokens
use_vulkan_memory_model
use-vulkan-memory-model
#pragma use_variable_pointers
use-variable-pointers
not implemented
glslang_binary_double_output
array variable name expected
built-in block redeclaration
gl_PerVertex
gl_PerFragment
gl_MeshPerVertexNV
gl_MeshPerPrimitiveNV
block declaration
cannot redeclare block: 
xfb_stream
duplicate label
duplicated value
switch statements
unknown requalification
buffer reference indexing
.length
cannot apply to an array:
scalar swizzle
does not apply to this type:
no such field in structure
array argument must be sized
16-bit arrays not supported
8-bit arrays not supported
too many arguments
cannot convert a void
wrong number of arguments
cannot convert a sampler
cannot convert an atomic_uint
local function declaration
array in function return type
cannot be bool
must be qualified as flat
fragment-shader struct input
vertex-shader struct output
fragment shader output
cannot be a structure
cannot be a matrix
centroid/sample/patch
shader input/output
image formats must match
built-in function
main(
array initializer
non-constant initializer
array-of-array of block
offset on block member
location on block member
offset/align
expected four type parameters
unexpected type parameters
cannot change the type of
used at end of comment; the following line is still part of the comment
used at end of comment, but this version does not provide line continuation
names beginning with "GL_" can't be (un)defined:
"defined" can't be (un)defined:
predefined names can't be (un)defined:
names containing consecutive underscores are reserved, and an error if version <= 300:
names containing consecutive underscores are reserved:
can't read from explicitly-interpolated object: 
can't modify gl_FragDepth if using early_fragment_tests
 l-value of swizzle cannot have duplicate components
tessellation-control per-vertex output l-value must be indexed with gl_InvocationID
tessellation input array size must be gl_MaxPatchVertices or implicitly sized
inconsistent input primitive for array size of
inconsistent output number of vertices for array size of
 cannot be greater than 3 for pervertexNV
inconsistent output array size of
tessellation control barrier() cannot be placed within flow control
tessellation control barrier() must be in main()
tessellation control barrier() cannot be placed after a return from main()
beginInvocationInterlockARB() must be in a fragment shader
beginInvocationInterlockARB() must be in main()
beginInvocationInterlockARB() cannot be placed after a return from main()
beginInvocationInterlockARB() cannot be placed within flow control
beginInvocationInterlockARB() must only be called once
beginInvocationInterlockARB() must be called before endInvocationInterlockARB()
endInvocationInterlockARB() must be in a fragment shader
endInvocationInterlockARB() must be in main()
endInvocationInterlockARB() cannot be placed after a return from main()
endInvocationInterlockARB() cannot be placed within flow control
endInvocationInterlockARB() must only be called once
gl_SemanticsAcquire must not be used with (image) atomic store
gl_SemanticsRelease must not be used with (image) atomic load
gl_SemanticsAcquireRelease must not be used with (image) atomic load/store
Invalid storage class semantics value
Semantics must include exactly one of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease
Semantics must not include multiple of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease
semUnequal must not include multiple of gl_SemanticsRelease, gl_SemanticsAcquire, or gl_SemanticsAcquireRelease
Storage class semantics must not be zero
semUnequal must not be gl_SemanticsRelease or gl_SemanticsAcquireRelease
gl_SemanticsMakeAvailable requires gl_SemanticsRelease or gl_SemanticsAcquireRelease
gl_SemanticsMakeVisible requires gl_SemanticsAcquire or gl_SemanticsAcquireRelease
gl_SemanticsVolatile must not be used with memoryBarrier or controlBarrier
semEqual and semUnequal must either both include gl_SemanticsVolatile or neither
sampler constructor must appear at point of use
all default precisions are highp; use precision statements to quiet warning, e.g.:\n         "precision mediump int; precision highp float;"
cannot convert from '%s' to '%s'
no operation '%s' exists that takes an operand of type %s (or there is no acceptable conversion)
no operation '%s' exists that takes a left-hand operand of type '%s' and a right operand of type '%s' (or there is no acceptable conversion)
scalar integer expression required
can only apply highp to atomic_uint
cannot apply precision statement to this type; use 'float', 'int' or a sampler type
atomic counters can only be highp
type requires declaration of default precision qualifier
type cannot have precision qualifier
must be a constant integer expression
vertex-shader array-of-array output
vertex-shader array-of-struct output
fragment-shader array-of-array input
fragment-shader array-of-struct input
fragment-shader array-of-array output
only outermost dimension of an array of arrays can be a specialization constant
array initializer must be sized
only outermost dimension of an array of arrays can be implicitly sized
array must be redeclared with a size before being indexed with a variable
mesh view output array size must be gl_MaxMeshViewCountNV or implicitly sized
requires a view array dimension
variables with qualifier 'const' must be initialized
storage qualifier not allowed on function parameter
cannot use auxiliary or interpolation qualifiers on a function parameter
cannot use layout qualifiers on a function parameter
cannot use invariant qualifier on a function parameter
qualifier has no effect on non-output parameters
cannot nest a block definition inside a structure or block
cannot nest a structure definition inside a structure or block
can't use with samplers or structs containing samplers
can't use with reference types
can't use with structs containing float16
can't use with arrays containing float16
can't use with structs containing int16
can't use with arrays containing int16
can't use with structs containing uint16
can't use with arrays containing uint16
can't use with structs containing int8
can't use with arrays containing int8
can't use with structs containing uint8
can't use with arrays containing uint8
cannot use storage or interpolation qualifiers on structure members
cannot use memory qualifiers on structure members
cannot use layout qualifiers on structure members
cannot use invariant qualifier on structure members
can only have one auxiliary qualifier (centroid, patch, and sample)
precise qualifier must appear first
invariant qualifier must appear before interpolation, storage, and precision qualifiers 
interpolation qualifiers must appear before storage and precision qualifiers
precision qualifier must appear as last qualifier
in/out must appear before const
only one precision qualifier allowed
only one coherent/devicecoherent/queuefamilycoherent/workgroupcoherent/subgroupcoherent qualifier allowed
Auxiliary qualifiers (centroid, patch, and sample) must appear before storage and precision qualifiers
can only have one interpolation qualifier (flat, smooth, noperspective, __explicitInterpAMD)
cannot use in a block array where new locations are needed for each block element
location qualifier on uniform or buffer
can only be used with an explicit location
requires uniform or buffer storage qualifier
can only be used with a uniform
cannot be used with push_constant
can only be used with a buffer
cannot be used with shaderRecordNV
cannot apply layout qualifiers to a shared variable
must specify 'location' to use 'component'
matrix or packing qualifiers can only be used on a uniform or buffer
offset/align can only be used on a uniform or buffer
cannot apply layout qualifiers to hitAttributeNV variable
type overflows the available 4 components
doubles cannot start on an odd-numbered component
location qualifier on in/out block
cannot apply to taskNV in/out blocks
cannot apply to uniform or buffer block
can only apply to uniform, buffer, in, or out storage qualifiers
all stride settings must match for xfb buffer
assuming binding count of one for compile-time checking of binding numbers for unsized array
sampler binding not less than gl_MaxCombinedTextureImageUnits
atomic_uint binding is too large; see gl_MaxAtomicCounterBindings
only applies to block members, not blocks
image variables not declared 'writeonly' and without a format layout qualifier
requires an input_attachment_index layout qualifier
can only be used with a subpass
can only be applied to 'const'-qualified scalar
can only be applied to a scalar
cannot be applied to this type
cannot apply to a matrix, structure, or block
type contains double or 64-bit integer; xfb_offset must be a multiple of 8
must be a multiple of size of first component
type contains half float or 16-bit integer; xfb_offset must be a multiple of 2
requires block, or sampler/image, or atomic-counter type
uniform/buffer blocks require layout(binding=X)
sampler/texture/image requires layout(binding=X)
Generating SPIR-V array-of-arrays, but Vulkan only supports single array level for this resource
does not apply to floating point images
does not apply to signed integer images
does not apply to unsigned integer images
format requires readonly or writeonly memory qualifier
fragment outputs sharing the same location must be the same basic type
can only be used on variable declaration
cannot specify matrix layout on a variable declaration
cannot specify packing on a variable declaration
cannot specify on a variable declaration
can only specify on a uniform block
can only specify on a buffer block
SPIR-V requires location for user input/output
can only apply to a standalone qualifier
array must be explicitly sized
atomic counters sharing the same offset:
no matching overloaded function found
atomic_uint binding is too large
useless application of layout qualifier
only uniform, buffer, in, or out blocks are supported
std430 requires the buffer storage qualifier
input blocks cannot be used in a mesh shader
can only use on input blocks in mesh shader
output blocks cannot be used in a task shader
cannot use centroid qualifier on an interface block
cannot use sample qualifier on an interface block
cannot use invariant qualifier on an interface block
cannot use interpolation qualifiers on an interface block
either the block needs a location, or all members need a location, or no members have a location
must be a multiple of the member's alignment
cannot lie in previous members
can only apply to an output, or to an input in a non-vertex stage\n
cannot use 'inout' at global scope
for non-parameter, can only apply to 'in' or no storage qualifier
not allowed on block or structure members
identifiers starting with "gl_" are reserved
identifiers containing consecutive underscores ("__") are reserved, and an error if version <= 300
identifiers containing consecutive underscores ("__") are reserved
gl_ClipDistancePerViewNV array size
gl_CullDistancePerViewNV array size
non-uniform struct contains an atomic_uint:
atomic_uints can only be used in uniform variables or function parameters:
non-uniform struct contains an accelerationStructureNV:
accelerationStructureNV can only be used in uniform variables or function parameters:
sampler-constructor requires two arguments
sampler-constructor cannot make an array of samplers
sampler-constructor first argument must be a scalar textureXXX type
sampler-constructor first argument must match type and dimensionality of constructor type
sampler-constructor second argument must be a scalar type 'sampler'
non-uniform struct contains a sampler or image:
sampler/image types can only be used in uniform variables or function parameters:
must be a compile-time constant:
argument must be compile-time constant
[gl_MinProgramTexelOffset, gl_MaxProgramTexelOffset]
only supported on image with format r32i or r32ui
only supported on integer images
only supported on image with format r32f
textureSamples and imageSamples
components must be in the range [0, 3]
components must be in the range [0, 31]
first argument must be an interpolant, or interpolant-array element
argument must be qualified as __explicitInterpAMD in
built in unary operator function.  Type: %s
ambiguous best function under implicit type conversion
cannot change previously set layout value
cannot change previously set input primitive
cannot change previously set output primitive
cannot change previously set vertex spacing
cannot change previously set vertex order
cannot change previously set size
too large; see gl_MaxComputeWorkGroupSize
too large; see gl_MaxMeshWorkGroupSizeNV
too large; see gl_MaxTaskWorkGroupSizeNV
cannot change previously set fragment shader interlock ordering
derivative_group_quadsNV and derivative_group_linearNV
requires total group size to be multiple of four
cannot use auxiliary, memory, interpolation, or precision qualifier in a default qualifier declaration (declaration with no type)
default qualifier requires 'uniform', 'buffer', 'in', or 'out' storage qualification
cannot declare a default, include a type or full declaration
cannot declare a default, use a full declaration
cannot declare a default, can only be used on a block
cannot declare a default, can only be used on a scalar
requires local_size_x and local_size_y to be multiple of two
cannot use offset or align qualifiers in a default qualifier declaration (declaration with no type)
method does not accept any arguments
array must first be sized by a redeclaration or layout qualifier
array must be declared with a size before using this method
void function cannot return a value
cannot convert return value to function return type
type conversion on return values was not explicitly allowed until version 420
type does not match, or is not convertible to, the function's return type
cannot convert parameter %d from '%s' to '%s'
ambiguous function signature match: multiple signatures match under implicit type conversion
can't use function syntax on variable
(Did you mean gl_VertexIndex?)
(Did you mean gl_InstanceIndex?)
cannot apply layout qualifier to
cannot change storage, memory, or auxiliary qualification of
cannot change interpolation qualification of
cannot change qualification of
can only change layout qualification of
cannot change input storage qualification of
cannot redeclare with different qualification:
cannot change output storage qualification of
all redeclarations must use the same depth layout on
redeclaration only allowed for override_coverage layout
redeclaration only allowed for viewport_relative or secondary_view_offset layout
inductive-loop init-declaration requires the form "type-specifier loop-index = constant-expression"
inductive loop requires a scalar 'int' or 'float' loop index
inductive-loop condition requires the form "loop-index <comparison-op> constant-expression"
inductive-loop termination requires the form "loop-index++, loop-index--, loop-index += constant-expression, or loop-index -= constant-expression"
wrong number of structure members
wrong number of matrix columns:
wrong vector size (or rows in a matrix column):
unexpected initializer-list type:
specialization-constant id is too large
specialization-constant id already used
gl_MaxTransformFeedbackBuffers is %d
gl_MaxTransformFeedbackInterleavedComponents is %d
too large, must be less than gl_MaxGeometryOutputVertices
index layout qualifier on fragment output
too large, must be less than gl_MaxMeshOutputVerticesNV
too large, must be less than gl_MaxMeshOutputPrimitivesNV
there is no such layout identifier for this stage taking an assigned value
function cannot take any parameter(s)
entry point cannot return a value
Source entry point must be "main"
unrecognized layout identifier, or qualifier requires assignment (e.g., binding = 4)
fragment shader interlock layout qualifier
optimize pragma syntax is incorrect
"(" expected after 'optimize' keyword
"on" or "off" expected after '(' for 'optimize' pragma
")" expected to end 'optimize' pragma
debug pragma syntax is incorrect
"(" expected after 'debug' keyword
"on" or "off" expected after '(' for 'debug' pragma
")" expected to end 'debug' pragma
cannot redeclare a user-block member array
redeclaring non-array as array
redeclaration of array with a different array dimensions or sizes
redeclaration of array with a different element type
redeclaration of array with size
no declaration found for redeclaration
can only redeclare a built-in block once, and before any use
cannot redeclare a non block as a block
cannot redeclare block member with a different type
cannot change arrayness of redeclared block member
cannot change array size of redeclared block member
missing perviewNV qualifier to redeclared block member
cannot add perviewNV qualifier to redeclared block member
missing perprimitiveNV qualifier to redeclared block member
cannot add perprimitiveNV qualifier to redeclared block member
cannot add memory qualifier to redeclared block member
cannot add non-XFB layout to redeclared block member
cannot add patch to redeclared block member
block redeclaration has extra members
cannot redeclare a built-in block with a user name
member cannot contradict block (or what block inherited from global)
cannot change arrayness of redeclared block
cannot change array size of redeclared block
cannot have statements before first case/default label
condition must be a scalar integer expression
last case/default label not followed by statements
block name cannot redefine a non-block name
identifier not previously declared
cannot re-qualify a function name
cannot add storage, auxiliary, memory, interpolation, layout, or precision qualifier to an existing variable
cannot change qualification after use
 left of '[' is not of type array, matrix, or vector 
does not operate on types containing float16
does not operate on types containing (u)int16
does not operate on types containing (u)int8
array must be sized by a redeclaration or layout qualifier before being indexed with a variable
variable indexing buffer block array
variable indexing uniform block array
variable indexing fragment shader output array
variable indexing sampler array
does not operate on this type:
cannot apply to a cooperative matrix type:
can't swizzle types containing float16
can't swizzle types containing (u)int16
can't swizzle types containing (u)int8
.length() on vectors and matrices
can't construct structure containing 16-bit type
can't construct structure containing 8-bit type
16-bit vectors only take vector types
8-bit vectors only take vector types
array constructor must have at least one argument
array constructor needs one argument per array element
constructing non-array constituent from array argument
matrix constructed from matrix can only have one argument
constructor argument does not have a type
array constructor argument not correct type to construct array element
constructing matrix from matrix
Number of constructor parameters does not match the number of structure fields
not enough data provided for construction
Cooperative matrix constructor argument must be scalar or cooperative matrix
samplers and atomic_uints cannot be output parameters
float16 types can only be in uniform block or buffer storage
(u)int16 types can only be in uniform block or buffer storage
(u)int8 types can only be in uniform block or buffer storage
overloaded functions must have the same return type
overloaded functions must have the same parameter storage qualifiers for argument
overloaded functions must have the same parameter precision qualifiers for argument
function name is redeclaration of existing name
redefinition of built-in function
multiple prototypes for same function
memory qualifiers cannot be used on this type
can only be applied to a standalone 'out'
cannot use interpolation qualifiers with patch
cannot be a structure or array
vertex-shader `double` type input
vertex input cannot be further qualified
fragment-shader struct input containing structure
fragment-shader struct input containing an array
global storage input qualifier cannot be used in a compute shader
can only use on output in tessellation-control shader
vertex-shader struct output containing structure
vertex-shader struct output containing an array
can't use auxiliary qualifier on a fragment output
can't use interpolation qualifier on a fragment output
cannot contain a double, int64, or uint64
global storage output qualifier cannot be used in a compute shader
can only use on input in tessellation-evaluation shader
buffers can be declared only as blocks
taskNV variables can be declared only as blocks
member of nameless block was not redeclared
cannot be used (maybe an instance name is needed)
cannot construct with these arguments
Non-L-value cannot be passed for 'out' or 'inout' parameters.
argument cannot drop memory qualifier when passed to formal parameter
calling user function from global scope
non-opaque uniforms outside a block
non-opaque uniform variables need a layout(location=L)
can't use with types containing arrays sized with a specialization constant
 cannot initialize this type of qualifier 
uniform initializers must be constant
global const initializers must be constant
non-matching or non-convertible constant type for const initializer
non-constant global initializer (needs GL_EXT_shader_non_constant_global_initializers)
member storage qualifier cannot contradict block storage qualifier
member of uniform or buffer block cannot have an auxiliary or interpolation qualifier
member of block cannot be or contain a sampler, image, or atomic_uint type
member of block cannot be or contain a cooperative matrix type
member cannot contradict block
member of block cannot have a packing layout qualifier
can only use in an in/out block
Cannot reuse block name within the same interface:
nameless block contains a member that already has a name at global scope
block instance name redefinition
can only be used with std140, std430, or scalar layout packing
block name cannot be redefined
expected 16, 32, or 64 bits for first type parameter
initializer requires a variable, not a member
expected 8 or 32 bits for first type parameter
variables with reference type can't have qualifier 'const'
Cooperative matrix types must not be used in shared memory
can only apply origin_upper_left and pixel_center_origin to gl_FragCoord
can only apply depth layout to gl_FragDepth
before
while
superp
demote
varying
subroutine
dmat2x2
dmat3x3
dmat4x4
iimage1D
uimage1D
iimage2D
uimage2D
iimage3D
uimage3D
iimage2DRect
uimage2DRect
iimageCube
uimageCube
iimageBuffer
uimageBuffer
iimage1DArray
uimage1DArray
iimage2DArray
uimage2DArray
iimageCubeArray
uimageCubeArray
iimage2DMS
uimage2DMS
iimage2DMSArray
uimage2DMSArray
i32vec2
i32vec3
i32vec4
uint32_t
u32vec2
u32vec3
u32vec4
f16mat2x2
f16mat3x3
f16mat4x4
float32_t
f32vec2
f32vec3
f32vec4
f32mat2
f32mat3
f32mat4
f32mat2x2
f32mat2x3
f32mat2x4
f32mat3x2
f32mat3x3
f32mat3x4
f32mat4x2
f32mat4x3
f32mat4x4
float64_t
f64vec2
f64vec3
f64vec4
f64mat2
f64mat3
f64mat4
f64mat2x2
f64mat2x3
f64mat2x4
f64mat3x2
f64mat3x3
f64mat3x4
f64mat4x2
f64mat4x3
f64mat4x4
isamplerCubeArray
usamplerCubeArray
isampler2D
isampler3D
isamplerCube
isampler2DArray
usampler2D
usampler3D
usamplerCube
usampler2DArray
isampler1DArray
usampler1D
isampler1D
usampler1DArray
isampler2DRect
usampler2DRect
isamplerBuffer
usamplerBuffer
isampler2DMS
usampler2DMS
isampler2DMSArray
usampler2DMSArray
samplerShadow
itextureCubeArray
utextureCubeArray
itexture1DArray
utexture1D
itexture1D
utexture1DArray
itexture2D
itexture3D
itextureCube
itexture2DArray
utexture2D
utexture3D
utextureCube
utexture2DArray
itexture2DRect
utexture2DRect
itextureBuffer
utextureBuffer
itexture2DMS
utexture2DMS
itexture2DMSArray
utexture2DMSArray
isubpassInput
isubpassInputMS
usubpassInput
usubpassInputMS
f16sampler1D
f16sampler2D
f16sampler3D
f16sampler2DRect
f16samplerCube
f16sampler1DArray
f16sampler2DArray
f16samplerCubeArray
f16samplerBuffer
f16sampler2DMS
f16sampler2DMSArray
f16sampler1DShadow
f16sampler2DShadow
f16sampler2DRectShadow
f16samplerCubeShadow
f16sampler1DArrayShadow
f16sampler2DArrayShadow
f16samplerCubeArrayShadow
f16image1D
f16image2D
f16image3D
f16image2DRect
f16imageCube
f16image1DArray
f16image2DArray
f16imageCubeArray
f16imageBuffer
f16image2DMS
f16image2DMSArray
f16texture1D
f16texture2D
f16texture3D
f16texture2DRect
f16textureCube
f16texture1DArray
f16texture2DArray
f16textureCubeArray
f16textureBuffer
f16texture2DMS
f16texture2DMSArray
f16subpassInput
f16subpassInputMS
fcoopmatNV
icoopmatNV
ucoopmatNV
partition
active
union
enum
typedef
template
goto
noinline
public
extern
interface
fixed
unsigned
hvec2
hvec3
hvec4
fvec2
fvec3
fvec4
sampler3DRect
filter
sizeof
namespace
Reserved word.
using future reserved keyword
using future keyword
using future type keyword
Unknown glslang keyword
unexpected token
future reserved word in ES 300 and keyword in GLSL
using ES precision qualifier keyword
using future non-square matrix type keyword
texture-rectangle sampler keyword
illegal use of escape character
inductive loop index modified
Non-constant-index-expression
#elif
#error
extension name not specified
extension name expected
header name too long
invalid preprocessor command
must occur first in shader
filename-based __FILE__
macro expansion
unexpected '#'
Too few args in Macro
End of input in macro
Too many args in macro
preprocessor evaluation
can't evaluate expression
expected ')'
bad expression
division by 0
#if/#ifdef/#ifndef
#elif after #else
#else after #else
#ifdef
vector::_M_fill_insert
for header name: %s
filename-based #line
bad argument
duplicate macro parameter
missing parenthesis
mismatched statements
invalid directive:
invalid directive
unexpected tokens following directive
':' missing after extension name
behavior for extension not specified
extra tokens -- expected newline
must be followed by macro name
can only be followed by a single macro name
must be followed by version number
bad profile name; use es, core, or compatibility
bad tokens following profile -- expected newline
End of line in macro substitution:
undefined macro in expression not allowed in es profile
nonportable when expanded from macros for preprocessor expression
cannot use in preprocessor expression when expanded from macros
incorrect directive, expected identifier
maximum nesting depth exceeded
unexpected tokens following #ifdef directive - expected a newline
directive must end with a newline
must be followed by a header name
extra content after header name:
Could not process include directive
expected newline after header name:
must by followed by an integral literal
missing space after macro name
Macro redefined; function-like versus object-like:
Macro redefined; different number of arguments:
Macro redefined; different argument names:
Macro redefined; different substitutions:
~!%^&*()-+=|,.<>/?;:[]{}#\
<bad token>
token pasting (##)
_Map_base::at
nterm
%s %s (
syntax error
syntax error, unexpected %s
$undefined
Starting parse\n
Stack size increased to %lu\n
Entering state %d\n
Reading a token: 
Now at end of input.\n
Next token is
Shifting
   $%d = 
unsigned literal
32-bit signed literal
64-bit integer literal
16-bit integer literal
double literal
half float literal
incomplete method syntax
bitwise not
bit shift left
bit shift right
array comparison
bitwise exclusive or
bitwise inclusive or
array assignment
bit-shift left assign
bit-shift right assign
bitwise-and assign
bitwise-xor assign
bitwise-or assign
precision statement
arrayed type
explicit interpolation
fragment shader barycentric
type parameter
8-bit signed integer
8-bit unsigned integer
16-bit signed integer
16-bit unsigned integer
32-bit signed integer
32-bit unsigned integer
64-bit integer
64-bit unsigned integer
double vector
half float vector
float32_t vector
float64_t vector
8-bit signed integer vector
16-bit signed integer vector
32-bit signed integer vector
64-bit integer vector
8-bit unsigned integer vector
double matrix
half float matrix
float32_t matrix
float64_t matrix
atomic counter types
half float sampler
half float texture
half float image
half float subpass input
expected type name
highp precision qualifier
mediump precision qualifier
lowp precision qualifier
duplicate member name:
{ } style initializers
limitation
do-while loops not available
extraneous semicolon
-> $$ =
Stack now
Error: discarding
Error: popping
memory exhausted
Cleanup: discarding lookahead
Cleanup: popping
$end
CONST
BOOL
FLOAT
BVEC2
BVEC3
BVEC4
IVEC2
IVEC3
IVEC4
UVEC2
UVEC3
UVEC4
ISAMPLER2D
ISAMPLER3D
ISAMPLERCUBE
ISAMPLER2DARRAY
USAMPLER2D
USAMPLER3D
USAMPLERCUBE
USAMPLER2DARRAY
ISAMPLERCUBEARRAY
USAMPLERCUBEARRAY
ATTRIBUTE
FLOAT16_T
FLOAT32_T
DOUBLE
FLOAT64_T
UINT64_T
UINT32_T
UINT16_T
UINT8_T
I64VEC2
I64VEC3
I64VEC4
U64VEC2
U64VEC3
U64VEC4
I32VEC2
I32VEC3
I32VEC4
U32VEC2
U32VEC3
U32VEC4
I16VEC2
I16VEC3
I16VEC4
U16VEC2
U16VEC3
U16VEC4
I8VEC2
I8VEC3
I8VEC4
U8VEC2
U8VEC3
U8VEC4
DVEC2
DVEC3
DVEC4
DMAT2
DMAT3
DMAT4
F16VEC2
F16VEC3
F16VEC4
F16MAT2
F16MAT3
F16MAT4
F32VEC2
F32VEC3
F32VEC4
F32MAT2
F32MAT3
F32MAT4
F64VEC2
F64VEC3
F64VEC4
F64MAT2
F64MAT3
F64MAT4
DMAT2X2
DMAT2X3
DMAT2X4
DMAT3X2
DMAT3X3
DMAT3X4
DMAT4X2
DMAT4X3
DMAT4X4
F16MAT2X2
F16MAT2X3
F16MAT2X4
F16MAT3X2
F16MAT3X3
F16MAT3X4
F16MAT4X2
F16MAT4X3
F16MAT4X4
F32MAT2X2
F32MAT2X3
F32MAT2X4
F32MAT3X2
F32MAT3X3
F32MAT3X4
F32MAT4X2
F32MAT4X3
F32MAT4X4
F64MAT2X2
F64MAT2X3
F64MAT2X4
F64MAT3X2
F64MAT3X3
F64MAT3X4
F64MAT4X2
F64MAT4X3
F64MAT4X4
ATOMIC_UINT
ACCSTRUCTNV
FCOOPMATNV
ICOOPMATNV
UCOOPMATNV
ISAMPLER1D
ISAMPLER2DRECT
USAMPLER2DRECT
ISAMPLERBUFFER
USAMPLERBUFFER
ISAMPLER2DMS
USAMPLER2DMS
ISAMPLER2DMSARRAY
USAMPLER2DMSARRAY
SAMPLEREXTERNALOES
SAMPLEREXTERNAL2DY2YEXT
ISAMPLER1DARRAY
USAMPLER1D
USAMPLER1DARRAY
F16SAMPLER1D
F16SAMPLER2D
F16SAMPLER3D
F16SAMPLER2DRECT
F16SAMPLERCUBE
F16SAMPLER1DARRAY
F16SAMPLER2DARRAY
F16SAMPLERCUBEARRAY
F16SAMPLERBUFFER
F16SAMPLER2DMS
F16SAMPLER2DMSARRAY
F16SAMPLER1DSHADOW
F16SAMPLER2DSHADOW
F16SAMPLER1DARRAYSHADOW
F16SAMPLER2DARRAYSHADOW
F16SAMPLER2DRECTSHADOW
F16SAMPLERCUBESHADOW
F16SAMPLERCUBEARRAYSHADOW
IIMAGE1D
UIMAGE1D
IIMAGE2D
UIMAGE2D
IIMAGE3D
UIMAGE3D
IIMAGE2DRECT
UIMAGE2DRECT
IIMAGECUBE
UIMAGECUBE
IIMAGEBUFFER
UIMAGEBUFFER
IIMAGE1DARRAY
UIMAGE1DARRAY
IIMAGE2DARRAY
UIMAGE2DARRAY
IIMAGECUBEARRAY
UIMAGECUBEARRAY
IIMAGE2DMS
UIMAGE2DMS
IIMAGE2DMSARRAY
UIMAGE2DMSARRAY
F16IMAGE1D
F16IMAGE2D
F16IMAGE3D
F16IMAGE2DRECT
F16IMAGECUBE
F16IMAGE1DARRAY
F16IMAGE2DARRAY
F16IMAGECUBEARRAY
F16IMAGEBUFFER
F16IMAGE2DMS
F16IMAGE2DMSARRAY
SAMPLERSHADOW
ITEXTURE1D
ITEXTURE2D
ITEXTURE3D
ITEXTURECUBE
ITEXTURE1DARRAY
ITEXTURE2DARRAY
UTEXTURE1D
UTEXTURE2D
UTEXTURE3D
UTEXTURECUBE
UTEXTURE1DARRAY
UTEXTURE2DARRAY
ITEXTURE2DRECT
UTEXTURE2DRECT
ITEXTUREBUFFER
UTEXTUREBUFFER
ITEXTURECUBEARRAY
UTEXTURECUBEARRAY
ITEXTURE2DMS
UTEXTURE2DMS
ITEXTURE2DMSARRAY
UTEXTURE2DMSARRAY
F16TEXTURE1D
F16TEXTURE2D
F16TEXTURE3D
F16TEXTURE2DRECT
F16TEXTURECUBE
F16TEXTURE1DARRAY
F16TEXTURE2DARRAY
F16TEXTURECUBEARRAY
F16TEXTUREBUFFER
F16TEXTURE2DMS
F16TEXTURE2DMSARRAY
ISUBPASSINPUT
ISUBPASSINPUTMS
USUBPASSINPUT
USUBPASSINPUTMS
F16SUBPASSINPUT
F16SUBPASSINPUTMS
LEFT_OP
RIGHT_OP
INC_OP
DEC_OP
LE_OP
GE_OP
EQ_OP
NE_OP
AND_OP
XOR_OP
MUL_ASSIGN
DIV_ASSIGN
ADD_ASSIGN
MOD_ASSIGN
LEFT_ASSIGN
RIGHT_ASSIGN
AND_ASSIGN
XOR_ASSIGN
SUB_ASSIGN
LEFT_PAREN
RIGHT_PAREN
LEFT_BRACKET
RIGHT_BRACKET
LEFT_BRACE
RIGHT_BRACE
COMMA
SEMICOLON
BANG
DASH
TILDE
PLUS
STAR
SLASH
PERCENT
LEFT_ANGLE
RIGHT_ANGLE
VERTICAL_BAR
CARET
AMPERSAND
QUESTION
INVARIANT
HIGH_PRECISION
MEDIUM_PRECISION
LOW_PRECISION
PACKED
SUPERP
FLOATCONSTANT
UINTCONSTANT
BOOLCONSTANT
IDENTIFIER
TYPE_NAME
CENTROID
INOUT
STRUCT
VOID
WHILE
BREAK
CONTINUE
ELSE
DISCARD
RETURN
SWITCH
CASE
DEFAULT
SHARED
FLAT
SMOOTH
DOUBLECONSTANT
UINT16CONSTANT
FLOAT16CONSTANT
UINT32CONSTANT
UINT64CONSTANT
SUBROUTINE
DEMOTE
PAYLOADNV
PAYLOADINNV
HITATTRNV
CALLDATANV
CALLDATAINNV
PATCH
SAMPLE
NONUNIFORM
VOLATILE
RESTRICT
READONLY
WRITEONLY
DEVICECOHERENT
QUEUEFAMILYCOHERENT
WORKGROUPCOHERENT
SUBGROUPCOHERENT
NONPRIVATE
NOPERSPECTIVE
EXPLICITINTERPAMD
PERVERTEXNV
PERPRIMITIVENV
PERVIEWNV
PERTASKNV
PRECISE
$accept
variable_identifier
primary_expression
postfix_expression
integer_expression
function_call
function_call_or_method
function_call_generic
function_call_header
function_identifier
unary_expression
unary_operator
multiplicative_expression
additive_expression
shift_expression
relational_expression
equality_expression
exclusive_or_expression
inclusive_or_expression
logical_and_expression
logical_xor_expression
logical_or_expression
conditional_expression
assignment_expression
assignment_operator
constant_expression
block_structure
identifier_list
function_prototype
function_declarator
function_header
parameter_declarator
parameter_declaration
parameter_type_specifier
init_declarator_list
single_declaration
fully_specified_type
invariant_qualifier
interpolation_qualifier
layout_qualifier
layout_qualifier_id_list
layout_qualifier_id
precise_qualifier
single_type_qualifier
storage_qualifier
non_uniform_qualifier
type_name_list
array_specifier
type_parameter_specifier_opt
type_parameter_specifier
type_parameter_specifier_list
type_specifier_nonarray
precision_qualifier
struct_specifier
struct_declaration_list
struct_declaration
struct_declarator_list
struct_declarator
initializer_list
declaration_statement
simple_statement
demote_statement
compound_statement
statement_no_new_scope
statement_scoped
expression_statement
selection_statement
selection_rest_statement
switch_statement
switch_statement_list
case_label
iteration_statement
$@10
$@11
$@12
for_init_statement
conditionopt
for_rest_statement
jump_statement
translation_unit
external_declaration
function_definition
$@13
attribute_list
single_attribute
syntax error, unexpected %s, expecting %s
syntax error, unexpected %s, expecting %s or %s
syntax error, unexpected %s, expecting %s or %s or %s
syntax error, unexpected %s, expecting %s or %s or %s or %s
Reducing stack by rule %d (line %lu):\n
64-bit unsigned integer literal
16-bit unsigned integer literal
function call, method, or subroutine call expected
cannot be an argument type except for '(void)'
no qualifiers allowed for function return
16-bit unsigned integer vector
32-bit unsigned integer vector
64-bit unsigned integer vector
cannot appear outside switch statement
cannot be nested inside control flow
continue statement only allowed in loops
break statement only allowed in switch and loops
non-void function must return a value
function does not return a value:
function_call_header_no_parameters
function_call_header_with_parameters
function_header_with_parameters
compound_statement_no_new_scope
selection_statement_nonattributed
switch_statement_nonattributed
iteration_statement_nonattributed
\t!\t&\t+\t0\t6\t;\t@\tF\tK\tP\tU\t[\ta\tg\tm\ts\ty\t
\n"\n'\n,\n1\n7\n<\nA\nF\nL\nQ\nV\n[\n`\ne\nk\np\nv\n{\n
\v"\v(\v-\v2\v7\v=\vB\vG\vL\vR\vW\v\\va\vg\vl\vq\vv\v|\v
\f$\f)\f.\f4\f:\f@\fF\fM\fT\fZ\f`\ff\fl\fr\fx\f
\r \r+\r.\r5\r9\r:\r@\rA\rB\rC\rD\rE\rF\rH\rN\rW\rX\r\\rX\rh\ri\rm\rm\rt\rt\r
expected no arguments
dont_unroll
dependency_infinite
dependency_length
must be positive
min_iterations
max_iterations
iteration_multiple
peel_count
partial_count
branch
dont_flatten
attribute with arguments not recognized, skipping
attribute does not apply to a selection
attribute does not apply to a switch
expected a single integer argument
attribute requires a SPIR-V 1.4 target-env
must be greater than or equal to 1
attribute does not apply to a loop
vector swizzle too long
unknown swizzle selection
can't modify an atomic_uint
can't modify void
can't modify a sampler
can't modify a uniform
can't modify a const
UNIMPLEMENTED: 
NOTE: 
UNKNOWN ERROR: 
' : 
array index out of range '%d'
vector swizzle selection out of range
vector swizzle selectors not from the same set
can't read from writeonly object: 
can't modify a readonly buffer
can't modify accelerationStructureNV
cannot modify hitAttributeNV in this stage
can't modify a shaderrecordnv qualified buffer
failed to insert the global constant buffer
vector index out of range '%d'
matrix index out of range '%d'
Recompile with DUMP_COUNTERS defined to see counters.\n
0x%08x, Revision %d
\t// 
\t #pragma once
const uint32_t 
[] = {
vector<bool>::_M_insert_aux
SPV_NV_mesh_shader
SPV_EXT_shader_stencil_export
SPV_KHR_shader_ballot
SPV_KHR_device_group
SPV_KHR_multiview
SPV_NV_viewport_array2
SPV_NV_stereo_view_rendering
SPV_NV_shading_rate
SPV_NV_shader_sm_builtins
SPV_EXT_descriptor_indexing
SPV_KHR_subgroup_vote
SPV_AMD_shader_ballot
invocation operation
$Global
SPV_NV_cooperative_matrix
SPV_AMD_shader_fragment_mask
SPV_NV_shader_image_footprint
ResType
SPV_AMD_gpu_shader_half_float
SPV_AMD_gcn_shader
unknown glslang unary
param
SPV_KHR_16bit_storage
SPV_KHR_8bit_storage
SPV_KHR_shader_clock
SPV_AMD_gpu_shader_int16
SPV_AMD_shader_trinary_minmax
unknown glslang aggregate
// OpModuleProcessed 
GLSL.std.450
SPV_KHR_vulkan_memory_model
SPV_KHR_post_depth_coverage
SPV_NV_ray_tracing
#line 1\n
ERROR: Failed to open file: %s\n
SPV_AMD_gpu_shader_half_float_fetch
SPV_EXT_shader_viewport_index_layer
SPV_KHR_shader_draw_parameters
SPV_AMD_shader_explicit_vertex_parameter
SPV_EXT_fragment_invocation_density
SPV_NVX_multiview_per_view_attributes
SPV_EXT_fragment_fully_covered
SPV_NV_fragment_shader_barycentric
SPV_EXT_demote_to_helper_invocation
SPV_NV_shader_subgroup_partitioned
SPV_NV_geometry_shader_passthrough
SPV_GOOGLE_hlsl_functionality1
unknown glslang binary operation
SPV_AMD_shader_image_load_store_lod
SPV_AMD_texture_gather_bias_lod
SPV_EXT_physical_storage_buffer
SPV_KHR_physical_storage_buffer
SPV_KHR_storage_buffer_storage_class
Neither a front-end constant nor a spec constant.
SPV_NV_sample_mask_override_coverage
forcing 32-bit vector type to non 64-bit scalar
forcing non 32-bit vector type
missing user function; linker needs to catch that
SPV_KHR_shader_atomic_counter_ops
SPV_EXT_fragment_shader_interlock
unknown operation with no arguments
SPV_NV_compute_shader_derivatives
 @            
  @            
 @            
TBD functionality: 
Missing functionality: 
warning: 
error: 
post-return
post-discard
post-switch-break
post-loop-continue
post-loop-break
indexable
info: 
SPIRV-Tools Validation Errors
Target version for SPIRV-Tools validator
0123456789
unknown op
unknown atomic operation
conditional expression
requires a scalar
cannot apply to 'in'
Invalid texture template type
): error at column 
, HLSL parsing failed.\n
basic_string::basic_string
packoffset
expected number after 'c'
expected 'c'
InterlockedCompareExchange
global binding
input attachment
register
ignoring shader_profile
expected register type
expected spaceN
invalid maxvertexcount
invalid domain
isoline
unsupported domain type
invalid outputtopology
triangle_cw
triangle_ccw
invalid partitioning
fractional_even
fractional_odd
unsupported partitioning type
invalid outputcontrolpoints
unhandled texture constructor
name already defined
unknown variable
SV_TARGET
invalid clip semantic
SV_CULLDISTANCE
invalid cull semantic
SV_STENCILREF
SV_CLIPDISTANCE
vector::_M_insert_aux
@position
pack_matrix
@sampleStructTemp
@sampleResultShadow
coordTemp
storeTemp
storeTempPre
storeTempPost
asdouble
@finitetmp
@gl_SubgroupSize
@gl_SubgroupInvocationID
unable to find texture symbol
byteAddrTemp
@entryPointOutput
flattenTemp
intermVec
flattenShadow
 unknown index type 
sizeQueryTemp
expected: sampler type
@sampleCount
expected: mul arguments
mul() matrix size mismatch
mips
aggShadow
[%d]
scalar expected one element:
scalarCopy
@patchConstantOutput
@patchConstantResult
unterminated mips operator:
operator[] on a non-RW texture must be an r-value
unimplemented: structure type in image or buffer
unknown basic type in image format
array size must be a constant integer expression
array size must be a positive integer
variable with qualifier 'const' not initialized; zero initializing
input primitive geometry redefinition
output primitive geometry redefinition
Arrays not supported in texture template types
Unimplemented: structure template type in subpass input
Invalid texture template struct member type
Too many components in texture template structure type
Texture template structure members must same basic type
Texture template struct return slots exceeded
Invalid member count in texture template structure
expected {x, y, z, w} for component
attribute does not apply to a type
expected register number after register type
ignoring unrecognized register type
cannot change previously set maxvertexcount attribute
invalid patch constant function
cannot change previously set domain
unsupported outputtopology type
cannot change previously set outputtopology
cannot change previously set partitioning
cannot change previously set outputcontrolpoints attribute
attribute does not apply to entry point
unable to locate patch function parameter name
unable to declare patch constant function interface variable
cannot access member variables (static member function?)
expected symbol, not user-defined type
unimplemented; need ARB_shader_stencil_export
unimplemented: clip/cull not currently implemented for this stage
matrix component swizzle has too many components
matrix row component out of range
matrix column component out of range
matrix component swizzle missing
unknown pack_matrix pragma value
patch constant function not found
ambiguous patch constant function
can't use variable in patch constant function
expected: scalar or vector type in texture structure
unimplemented: partial image updates
unknown image type in atomic operation
double2 conversion not implemented
only simple assignment to non-simple matrix swizzle is supported
unable to find output symbol for Append()
Invalid variable index to flattened array
expected: SamplerComparisonState
unimplemented: component-level gather compare
unimplemented: residency status
unexpected texture type for .mips[][] operator:
unexpected operator on texture type:
cannot convert input argument, argument
cannot implicitly initialize opaque members
unimplemented: multiple output patches in patch constant function
unimplemented: PCF input patch without entry point input patch parameter
unable to find patch constant function built-in variable
entry point must return a value for use with patch constant function
unimplemented: entry point outputs in patch constant function invocation
WARNING: AST will form illegal SPIR-V; need to transform to legalize
o@unorm
groupshared
nointerpolation
globallycoherent
triangle
lineadj
triangleadj
PointStream
LineStream
TriangleStream
InputPatch
OutputPatch
dword
min16float
min10float
min16int
min12int
min16uint
bool1
double1
double2
double3
double4
half1
half2
half3
half4
min16float1
min16float2
min16float3
min16float4
min10float1
min10float2
min10float3
min10float4
min16int1
min16int2
min16int3
min16int4
min12int1
min12int2
min12int3
min12int4
min16uint1
min16uint2
min16uint3
min16uint4
bool1x1
bool1x2
bool1x3
bool1x4
bool2x1
bool2x2
bool2x3
bool2x4
bool3x1
bool3x2
bool3x3
bool3x4
bool4x1
bool4x2
bool4x3
bool4x4
uint1x1
uint1x2
uint1x3
uint1x4
uint2x1
uint2x2
uint2x3
uint2x4
uint3x1
uint3x2
uint3x3
uint3x4
uint4x1
uint4x2
uint4x3
uint4x4
float1x1
float1x2
float1x3
float1x4
float2x1
float2x2
float2x3
float2x4
float3x1
float3x2
float3x4
float4x1
float4x2
half1x1
half1x2
half1x3
half1x4
half2x1
half2x2
half2x3
half2x4
half3x1
half3x2
half3x3
half3x4
half4x1
half4x2
half4x3
half4x4
double1x1
double1x2
double1x3
double1x4
double2x1
double2x2
double2x3
double2x4
double3x1
double3x2
double3x3
double3x4
double4x1
double4x2
double4x3
double4x4
sampler_state
SamplerState
SamplerComparisonState
TextureCube
TextureCubeArray
Texture2DMS
Texture2DMSArray
RWTexture1D
RWTexture1DArray
RWTexture2D
RWTexture2DArray
RWTexture3D
SubpassInput
SubpassInputMS
AppendStructuredBuffer
ConsumeStructuredBuffer
RWByteAddressBuffer
RWStructuredBuffer
TextureBuffer
ConstantBuffer
tbuffer
catch
char
const_cast
explicit
friend
mutable
protected
reinterpret_cast
static_cast
throw
typename
virtual
SV_POSITION
SV_VERTEXID
SV_VIEWPORTARRAYINDEX
SV_TESSFACTOR
SV_SAMPLEINDEX
SV_RENDERTARGETARRAYINDEX
SV_PRIMITIVEID
SV_OUTPUTCONTROLPOINTID
SV_ISFRONTFACE
SV_INSTANCEID
SV_INSIDETESSFACTOR
SV_GSINSTANCEID
SV_DISPATCHTHREADID
SV_GROUPTHREADID
SV_GROUPINDEX
SV_GROUPID
SV_DOMAINLOCATION
SV_DEPTH
SV_COVERAGE
SV_DEPTHGREATEREQUAL
SV_DEPTHLESSEQUAL
Expected
Unimplemented
right angle bracket
sampler name
immediate sampler state
unimplemented
minlod
maxlod
addressu
addressv
addressw
texture address mode
lod bias
bordercolor
texture state
maxanisotropy
miplodbias
namespace name
declaration list
function parameter list
can't have an initializer
block initializer
declaration in annotation
member type
member name
member-function definition
struct member declarations
tessellation patch type
basic type in subpass input
basic type in texture
matrix type in buffer
multisample count
texture type for multisample
type for RWTexture/RWBuffer
left angle bracket
@data
type that can be constructed
([]())
unary operator
expression after ?
expression after :
c[subcomponent][.component]
register number description
space identifier
assignment expression
could not create assignment
, or }
one or more arguments
__BI_
attribute identifier
unrecognized attribute
identifier after ::
function call arguments
swizzle or member
function parameters
expression followed by ']'
loop or switch
case expression
stream output type
initialized declaration
while sub-statement
do sub-statement
for sub-statement
then statement
else statement
Direct3D 9 sampler declaration
function body can't be in a declarator list
function body can't be in a typedef
function typedefs not implemented
buffer aliasing not yet supported
struct-member initializers ignored
unorm and snorm only valid in floating point domain
components < 4 in matrix buffer type
scalar, vector, or struct type
non-structure type in ConstantBuffer
parenthesized array constructor not allowed
Could not perform requested binary operation
layout, semantic, packoffset, or register
assignment expression in initializer list
namespace or attribute identifier
invalid default parameter value
attributes don't apply to control declaration
function parameter requires array size
invalid parameter after default value parameters
for-loop initializer statement
AllMemoryBarrier
asfloat
asint
asuint
atan2
countbits
D3DCOLORtoUBYTE4
ddx_coarse
ddx_fine
ddy_coarse
ddy_fine
EvaluateAttributeAtCentroid
EvaluateAttributeAtSample
EvaluateAttributeSnapped
f16tof32
f32tof16
firstbithigh
firstbitlow
fmod
reversebits
tex1D
tex1Dbias
tex1Dgrad
tex1Dlod
tex1Dproj
tex2D
tex2Dbias
tex2Dgrad
tex2Dlod
tex2Dproj
tex3D
tex3Dbias
tex3Dgrad
tex3Dlod
tex3Dproj
texCUBE
texCUBEbias
texCUBEgrad
texCUBElod
texCUBEproj
__BI_Sample
__BI_SampleBias
__BI_SampleCmp
__BI_SampleCmpLevelZero
__BI_SampleGrad
__BI_SampleLevel
__BI_Load
__BI_GetDimensions
__BI_GetSamplePosition
__BI_Gather
__BI_CalculateLevelOfDetail
__BI_Load2
__BI_Load3
__BI_Load4
__BI_Store
__BI_Store2
__BI_Store3
__BI_Store4
__BI_IncrementCounter
__BI_DecrementCounter
__BI_Consume
__BI_InterlockedAdd
__BI_InterlockedAnd
__BI_InterlockedCompareStore
__BI_InterlockedExchange
__BI_InterlockedMax
__BI_InterlockedMin
__BI_InterlockedOr
__BI_InterlockedXor
__BI_GatherRed
__BI_GatherGreen
__BI_GatherBlue
__BI_GatherAlpha
__BI_GatherCmp
__BI_GatherCmpRed
__BI_GatherCmpGreen
__BI_GatherCmpBlue
__BI_GatherCmpAlpha
__BI_Append
__BI_RestartStrip
WaveIsFirstLane
WaveGetLaneCount
WaveGetLaneIndex
WaveActiveAnyTrue
WaveActiveAllTrue
WaveActiveBallot
WaveReadLaneFirst
WaveReadLaneAt
WaveActiveAllEqual
WaveActiveAllEqualBool
WaveActiveCountBits
WaveActiveSum
WaveActiveProduct
WaveActiveBitAnd
WaveActiveBitOr
WaveActiveBitXor
WaveActiveMin
WaveActiveMax
WavePrefixSum
WavePrefixProduct
WavePrefixCountBits
QuadReadAcrossX
QuadReadAcrossY
QuadReadAcrossDiagonal
QuadReadLaneAt
__BI_SubpassLoad
__BI_SubpassLoadMS
UNKNOWN_DIMENSION
UNKNOWN_TYPE
<int
<uint
<float
RWTexture
UNKNOWN_SAMPLER
abort
DFUI
BFIU
SVM,
CheckAccessFullyMapped
SVM,,
SVM,S
SVM,V2
GetRenderTargetSampleCount
GetRenderTargetSamplePosition
SVM,,>
SVM,,,>
UI,,,
SVM,,S
DFUI,,
FIU,
SVM,>
msad4
S,V2,V4
Process2DQuadTessFactorsAvg
V4,V2,>V4,>V2,
F,,,,
Process2DQuadTessFactorsMax
Process2DQuadTessFactorsMin
ProcessIsolineTessFactors
S,,>,>
ProcessQuadTessFactorsAvg
V4,S,>V4,>V2,
ProcessQuadTessFactorsMax
ProcessQuadTessFactorsMin
ProcessTriTessFactorsAvg
V3,S,>V3,>S,
ProcessTriTessFactorsMax
ProcessTriTessFactorsMin
V,V,S
SVM,>,>
S,S,V1,
S,V4
V2,,,
V3,,,
V3,V4
V4,V3
V4,V3,,
FUIB
%@,S,V
FIU,S,F
%@,S,V,
FIU,S,F,I
%@,S,V,S
FIU,S,F,
%@,S,V,S,V
FIU,S,F,,I
FIU,s,F,
FIU,s,F,,I
FIU,s,F,F
FIU,s,F,F,I
%@,S,V,,
FIU,S,F,,
%@,S,V,,,
FIU,S,F,,,I
%@,V
FIU,I
%@,V,V
FIU,I,I
$&,V,S
$&,V,S,V
FIU,I,I,I
!#,V
~*1,V
%@,S,V,V
FUI,S,F
$&2,S
FUI,I
%!~1,>S
FUI,F
%1,S,>S,
FUI,U,,
FUI,U,F,
@#1,>S,
FUI,U,
FUI,F,
@1,S,>S,,
FUI,U,,,
FUI,U,F,,
%!2,>S,
%2,S,>S,,
@#2,>S,,
FUI,F,F,F
@2,S,>S,,,
FUI,U,,,,
FUI,U,F,,,
%!3,>S,,
FUI,F,,
%3,S,>S,,,
%4,>S,
%4,S,>S,,
@4,>S,,
@4,S,>S,,,
$2,>S,,
&2,>S,,,
%@,S,V,,>S
FIU,S,F,I,U
%@,S,V,,,,
FIU,S,F,I,,,
%@,S,V,,,,,S
FIU,S,F,I,,,,U
%@,S,V,S,V,>S
FIU,s,F,,I,U
%@,S,V,S,V,,,
FIU,s,F,,I,,,
%@,S,V,S,V,,V,S
FIU,s,F,,I,,,,U
%@,S,V,S,V,,,,S
SV,S
DFUI,U
GroupMemoryBarrierWithGroupSync
__BI_CalculateLevelOfDetailUnclamped
__BI_InterlockedCompareExchange
CalculateLevelOfDetailUnclamped
,,,,,,,,,,,,,,,,
global_cbuffer_binding
builtin
allow_uav_condition
earlydepthstencil
fastopt
forcecase
instance
maxtessfactor
numthreads
patchconstantfunc
SPV_SUCCESS
SPV_UNSUPPORTED
SPV_END_OF_STREAM
SPV_WARNING
SPV_FAILED_MATCH
SPV_REQUESTED_TERMINATION
SPV_ERROR_INTERNAL
SPV_ERROR_OUT_OF_MEMORY
SPV_ERROR_INVALID_POINTER
SPV_ERROR_INVALID_BINARY
SPV_ERROR_INVALID_TEXT
SPV_ERROR_INVALID_TABLE
SPV_ERROR_INVALID_VALUE
SPV_ERROR_INVALID_DIAGNOSTIC
SPV_ERROR_INVALID_LOOKUP
SPV_ERROR_INVALID_ID
SPV_ERROR_INVALID_CFG
SPV_ERROR_INVALID_LAYOUT
Unknown Error
; SPIR-V\n
; Version: 
; Generator: 
; Bound: 
; Schema: 
 ; 0x
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789
StorageClass
gl_PatchVertices
WorkDim
GlobalSize
EnqueuedWorkgroupSize
GlobalOffset
GlobalLinearId
SubgroupMaxSize
NumEnqueuedSubgroups
SubgroupId
SubgroupLocalInvocationId
SubgroupEqMaskKHR
SubgroupGeMaskKHR
SubgroupGtMaskKHR
SubgroupLeMaskKHR
SubgroupLtMaskKHR
_arr_
_runtimearr_
_ptr_
Opaque_
_struct_
Khronos
LunarG
Valve
Codeplay
NVIDIA
LLVM/SPIR-V Translator
SPIR-V Tools Assembler
Glslang Reference Front End
Qualcomm
Imagination
Google
Google Shaderc over Glslang
Google spiregg
Google rspirv
X-LEGEND
Mesa-IR/SPIR-V Translator
Khronos SPIR-V Tools Linker
Wine
Wine VKD3D Shader Compiler
Clay
Clay Clay Shader Compiler
W3C WebGPU Group
WHLSL Shader Translator
Google Clspv
Google MLIR SPIR-V Serializer
SourceContinued
SourceExtension
MemberName
ExtInstImport
EntryPoint
ExecutionMode
Capability
TypeVoid
TypeBool
TypeInt
TypeFloat
TypeMatrix
TypeImage
TypeSampler
TypeSampledImage
TypeRuntimeArray
TypeStruct
TypeOpaque
TypeEvent
TypeDeviceEvent
TypeReserveId
TypeQueue
TypePipe
TypeForwardPointer
ConstantSampler
ConstantNull
SpecConstantTrue
SpecConstantFalse
SpecConstant
SpecConstantComposite
SpecConstantOp
FunctionParameter
FunctionEnd
FunctionCall
ImageTexelPointer
CopyMemory
CopyMemorySized
InBoundsAccessChain
ArrayLength
GenericPtrMemSemantics
InBoundsPtrAccessChain
DecorationGroup
GroupDecorate
GroupMemberDecorate
VectorExtractDynamic
VectorInsertDynamic
VectorShuffle
CompositeConstruct
CompositeExtract
CompositeInsert
CopyObject
Transpose
ImageSampleImplicitLod
ImageSampleExplicitLod
ImageSampleDrefImplicitLod
ImageSampleDrefExplicitLod
ImageSampleProjImplicitLod
ImageSampleProjExplicitLod
ImageGather
ImageDrefGather
ImageRead
ImageWrite
ImageQueryFormat
ImageQueryOrder
ImageQuerySizeLod
ImageQuerySize
ImageQueryLod
ImageQueryLevels
ImageQuerySamples
ConvertFToU
ConvertFToS
ConvertSToF
ConvertUToF
UConvert
SConvert
FConvert
QuantizeToF16
ConvertPtrToU
SatConvertSToU
SatConvertUToS
ConvertUToPtr
PtrCastToGeneric
GenericCastToPtr
GenericCastToPtrExplicit
Bitcast
SNegate
FNegate
FSub
UDiv
SDiv
FDiv
UMod
SRem
SMod
FRem
FMod
VectorTimesScalar
MatrixTimesScalar
VectorTimesMatrix
MatrixTimesVector
MatrixTimesMatrix
OuterProduct
IAddCarry
ISubBorrow
UMulExtended
SMulExtended
IsNan
IsInf
IsFinite
IsNormal
SignBitSet
LessOrGreater
Ordered
Unordered
LogicalEqual
LogicalNotEqual
LogicalNot
Select
IEqual
INotEqual
UGreaterThan
SGreaterThan
UGreaterThanEqual
SGreaterThanEqual
ULessThan
SLessThan
ULessThanEqual
SLessThanEqual
FOrdEqual
FUnordEqual
FOrdNotEqual
FUnordNotEqual
FOrdLessThan
FUnordLessThan
FOrdGreaterThan
FUnordGreaterThan
FOrdLessThanEqual
FUnordLessThanEqual
FOrdGreaterThanEqual
FUnordGreaterThanEqual
ShiftRightLogical
ShiftRightArithmetic
ShiftLeftLogical
BitFieldInsert
BitFieldSExtract
BitFieldUExtract
BitReverse
DPdx
DPdy
Fwidth
DPdxFine
DPdyFine
FwidthFine
DPdxCoarse
DPdyCoarse
FwidthCoarse
ControlBarrier
AtomicCompareExchange
AtomicCompareExchangeWeak
AtomicIIncrement
AtomicIDecrement
AtomicIAdd
AtomicISub
AtomicSMin
AtomicUMin
AtomicSMax
AtomicUMax
LoopMerge
SelectionMerge
BranchConditional
Switch
ReturnValue
Unreachable
LifetimeStart
LifetimeStop
GroupAsyncCopy
GroupWaitEvents
GroupAll
GroupAny
GroupBroadcast
GroupIAdd
GroupFAdd
GroupFMin
GroupUMin
GroupSMin
GroupFMax
GroupUMax
GroupSMax
ReservedReadPipe
ReservedWritePipe
IsValidReserveId
GetNumPipePackets
GetMaxPipePackets
GroupReserveReadPipePackets
GroupReserveWritePipePackets
GroupCommitReadPipe
GroupCommitWritePipe
EnqueueMarker
EnqueueKernel
GetKernelNDrangeSubGroupCount
GetKernelWorkGroupSize
RetainEvent
ReleaseEvent
CreateUserEvent
IsValidEvent
SetUserEventStatus
CaptureEventProfilingInfo
GetDefaultQueue
BuildNDRange
ImageSparseSampleImplicitLod
ImageSparseSampleExplicitLod
ImageSparseFetch
ImageSparseGather
ImageSparseDrefGather
ImageSparseTexelsResident
NoLine
AtomicFlagTestAndSet
AtomicFlagClear
SizeOf
TypePipeStorage
ConstantPipeStorage
CreatePipeFromPipeStorage
GetKernelMaxNumSubgroups
TypeNamedBarrier
NamedBarrierInitialize
MemoryNamedBarrier
ModuleProcessed
ExecutionModeId
DecorateId
GroupNonUniformElect
GroupNonUniformAll
GroupNonUniformAny
GroupNonUniformAllEqual
GroupNonUniformBroadcast
GroupNonUniformBroadcastFirst
GroupNonUniformBallot
GroupNonUniformInverseBallot
GroupNonUniformBallotBitCount
GroupNonUniformBallotFindLSB
GroupNonUniformBallotFindMSB
GroupNonUniformShuffle
GroupNonUniformShuffleXor
GroupNonUniformShuffleUp
GroupNonUniformShuffleDown
GroupNonUniformIAdd
GroupNonUniformFAdd
GroupNonUniformIMul
GroupNonUniformFMul
GroupNonUniformSMin
GroupNonUniformUMin
GroupNonUniformFMin
GroupNonUniformSMax
GroupNonUniformUMax
GroupNonUniformFMax
GroupNonUniformBitwiseAnd
GroupNonUniformBitwiseOr
GroupNonUniformBitwiseXor
GroupNonUniformLogicalAnd
GroupNonUniformLogicalOr
GroupNonUniformLogicalXor
GroupNonUniformQuadBroadcast
GroupNonUniformQuadSwap
CopyLogical
PtrEqual
PtrNotEqual
PtrDiff
SubgroupBallotKHR
SubgroupFirstInvocationKHR
SubgroupAllKHR
SubgroupAnyKHR
SubgroupAllEqualKHR
SubgroupReadInvocationKHR
GroupIAddNonUniformAMD
GroupFAddNonUniformAMD
GroupFMinNonUniformAMD
GroupUMinNonUniformAMD
GroupSMinNonUniformAMD
GroupFMaxNonUniformAMD
GroupUMaxNonUniformAMD
GroupSMaxNonUniformAMD
FragmentMaskFetchAMD
FragmentFetchAMD
ReadClockKHR
ImageSampleFootprintNV
GroupNonUniformPartitionNV
ReportIntersectionNV
IgnoreIntersectionNV
TerminateRayNV
TraceNV
TypeAccelerationStructureNV
ExecuteCallableNV
TypeCooperativeMatrixNV
CooperativeMatrixMulAddNV
CooperativeMatrixLengthNV
BeginInvocationInterlockEXT
EndInvocationInterlockEXT
DemoteToHelperInvocationEXT
IsHelperInvocationEXT
SubgroupShuffleINTEL
SubgroupShuffleDownINTEL
SubgroupShuffleUpINTEL
SubgroupShuffleXorINTEL
SubgroupBlockReadINTEL
SubgroupBlockWriteINTEL
SubgroupImageBlockReadINTEL
SubgroupImageBlockWriteINTEL
UCountLeadingZerosINTEL
UCountTrailingZerosINTEL
AbsISubINTEL
AbsUSubINTEL
IAddSatINTEL
UAddSatINTEL
IAverageINTEL
UAverageINTEL
IAverageRoundedINTEL
UAverageRoundedINTEL
ISubSatINTEL
USubSatINTEL
IMul32x16INTEL
UMul32x16INTEL
MemberDecorateString
MemberDecorateStringGOOGLE
TypeVmeImageINTEL
TypeAvcImePayloadINTEL
TypeAvcRefPayloadINTEL
TypeAvcSicPayloadINTEL
TypeAvcMcePayloadINTEL
TypeAvcMceResultINTEL
TypeAvcImeResultINTEL
TypeAvcRefResultINTEL
TypeAvcSicResultINTEL
SubgroupAvcImeInitializeINTEL
SubgroupAvcFmeInitializeINTEL
SubgroupAvcBmeInitializeINTEL
SubgroupAvcSicInitializeINTEL
Khronos LLVM/SPIR-V Translator
Khronos SPIR-V Tools Assembler
Khronos Glslang Reference Front End
X-LEGEND Mesa-IR/SPIR-V Translator
W3C WebGPU Group WHLSL Shader Translator
ImageSampleProjDrefImplicitLod
ImageSampleProjDrefExplicitLod
GetKernelNDrangeMaxSubGroupSize
GetKernelPreferredWorkGroupSizeMultiple
ImageSparseSampleDrefImplicitLod
ImageSparseSampleDrefExplicitLod
ImageSparseSampleProjImplicitLod
ImageSparseSampleProjExplicitLod
ImageSparseSampleProjDrefImplicitLod
ImageSparseSampleProjDrefExplicitLod
GetKernelLocalSizeForSubgroupCount
GroupNonUniformBallotBitExtract
WritePackedPrimitiveIndices4x8NV
SubgroupImageMediaBlockReadINTEL
SubgroupImageMediaBlockWriteINTEL
TypeAvcImeResultSingleReferenceStreamoutINTEL
TypeAvcImeResultDualReferenceStreamoutINTEL
TypeAvcImeSingleReferenceStreaminINTEL
TypeAvcImeDualReferenceStreaminINTEL
SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL
SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL
SubgroupAvcMceGetDefaultInterShapePenaltyINTEL
SubgroupAvcMceSetInterShapePenaltyINTEL
SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL
SubgroupAvcMceSetInterDirectionPenaltyINTEL
SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL
SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL
SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL
SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL
SubgroupAvcMceSetMotionVectorCostFunctionINTEL
SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL
SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL
SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL
SubgroupAvcMceSetAcOnlyHaarINTEL
SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL
SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL
SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL
SubgroupAvcMceConvertToImePayloadINTEL
SubgroupAvcMceConvertToImeResultINTEL
SubgroupAvcMceConvertToRefPayloadINTEL
SubgroupAvcMceConvertToRefResultINTEL
SubgroupAvcMceConvertToSicPayloadINTEL
SubgroupAvcMceConvertToSicResultINTEL
SubgroupAvcMceGetMotionVectorsINTEL
SubgroupAvcMceGetInterDistortionsINTEL
SubgroupAvcMceGetBestInterDistortionsINTEL
SubgroupAvcMceGetInterMajorShapeINTEL
SubgroupAvcMceGetInterMinorShapeINTEL
SubgroupAvcMceGetInterDirectionsINTEL
SubgroupAvcMceGetInterMotionVectorCountINTEL
SubgroupAvcMceGetInterReferenceIdsINTEL
SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL
SubgroupAvcImeSetSingleReferenceINTEL
SubgroupAvcImeSetDualReferenceINTEL
SubgroupAvcImeRefWindowSizeINTEL
SubgroupAvcImeAdjustRefOffsetINTEL
SubgroupAvcImeConvertToMcePayloadINTEL
SubgroupAvcImeSetMaxMotionVectorCountINTEL
SubgroupAvcImeSetUnidirectionalMixDisableINTEL
SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL
SubgroupAvcImeSetWeightedSadINTEL
SubgroupAvcImeEvaluateWithSingleReferenceINTEL
SubgroupAvcImeEvaluateWithDualReferenceINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL
SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL
SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL
SubgroupAvcImeConvertToMceResultINTEL
SubgroupAvcImeGetSingleReferenceStreaminINTEL
SubgroupAvcImeGetDualReferenceStreaminINTEL
SubgroupAvcImeStripSingleReferenceStreamoutINTEL
SubgroupAvcImeStripDualReferenceStreamoutINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL
SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL
SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL
SubgroupAvcImeGetBorderReachedINTEL
SubgroupAvcImeGetTruncatedSearchIndicationINTEL
SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL
SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL
SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL
SubgroupAvcRefConvertToMcePayloadINTEL
SubgroupAvcRefSetBidirectionalMixDisableINTEL
SubgroupAvcRefSetBilinearFilterEnableINTEL
SubgroupAvcRefEvaluateWithSingleReferenceINTEL
SubgroupAvcRefEvaluateWithDualReferenceINTEL
SubgroupAvcRefEvaluateWithMultiReferenceINTEL
SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL
SubgroupAvcRefConvertToMceResultINTEL
SubgroupAvcSicConfigureSkcINTEL
SubgroupAvcSicConfigureIpeLumaINTEL
SubgroupAvcSicConfigureIpeLumaChromaINTEL
SubgroupAvcSicGetMotionVectorMaskINTEL
SubgroupAvcSicConvertToMcePayloadINTEL
SubgroupAvcSicSetIntraLumaShapePenaltyINTEL
SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL
SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL
SubgroupAvcSicSetBilinearFilterEnableINTEL
SubgroupAvcSicSetSkcForwardTransformEnableINTEL
SubgroupAvcSicSetBlockBasedRawSkipSadINTEL
SubgroupAvcSicEvaluateIpeINTEL
SubgroupAvcSicEvaluateWithSingleReferenceINTEL
SubgroupAvcSicEvaluateWithDualReferenceINTEL
SubgroupAvcSicEvaluateWithMultiReferenceINTEL
SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL
SubgroupAvcSicConvertToMceResultINTEL
SubgroupAvcSicGetIpeLumaShapeINTEL
SubgroupAvcSicGetBestIpeLumaDistortionINTEL
SubgroupAvcSicGetBestIpeChromaDistortionINTEL
SubgroupAvcSicGetPackedIpeLumaModesINTEL
SubgroupAvcSicGetIpeChromaModeINTEL
SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL
SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL
SubgroupAvcSicGetInterRawSadsINTEL
[1;30m
[31m
[32m
[33m
[34m
SPIR-V 1.0
SPIR-V 1.1
SPIR-V 1.2
SPIR-V 1.4
SPIR-V 1.5
OpenCL
WebGPU
Universal
vulkan1.1spv1.4
spv1.0
spv1.1
spv1.2
spv1.3
spv1.5
opencl1.2embedded
opencl1.2
opencl2.0embedded
opencl2.0
opencl2.1embedded
opencl2.1
opencl2.2embedded
opencl2.2
opengl4.0
opengl4.1
opengl4.2
opengl4.3
opengl4.5
webgpu0
SPIR-V 1.0 (under Vulkan 1.0 semantics)
SPIR-V 1.0 (under OpenCL 1.2 Full Profile semantics)
SPIR-V 1.0 (under OpenCL 1.2 Embedded Profile semantics)
SPIR-V 1.0 (under OpenCL 2.0 Full Profile semantics)
SPIR-V 1.0 (under OpenCL 2.0 Embedded Profile semantics)
SPIR-V 1.0 (under OpenCL 2.1 Full Profile semantics)
SPIR-V 1.0 (under OpenCL 2.1 Embedded Profile semantics)
SPIR-V 1.2 (under OpenCL 2.2 Full Profile semantics)
SPIR-V 1.2 (under OpenCL 2.2 Embedded Profile semantics)
SPIR-V 1.0 (under OpenGL 4.0 semantics)
SPIR-V 1.0 (under OpenGL 4.1 semantics)
SPIR-V 1.0 (under OpenGL 4.2 semantics)
SPIR-V 1.0 (under OpenGL 4.3 semantics)
SPIR-V 1.0 (under OpenGL 4.5 semantics)
SPIR-V 1.3 (under Vulkan 1.1 semantics)
SPIR-V 1.3 (under WIP WebGPU semantics)
SPIR-V 1.4 (under Vulkan 1.1 semantics)
--max-struct-members
--max-struct_depth
--max-local-variables
--max-global-variables
--max-switch-branches
--max-function-args
--max-access-chain-indexes
--max-id-bound
--max-control-flow-nesting-depth
Invalid immediate integer: !
Expected id to start with %.
Invalid ID 
Invalid 
Type for 
Invalid literal string '
 operand '
 not allowed before =.
'=' expected after result id.
Invalid Opcode prefix '
Invalid Opcode name '
Cannot set ID 
 because 
Instruction too long: 
 words, but the limit is 
Missing assembly text.
Invalid extended instruction import Id 
Invalid extended instruction name '
OpSpecConstant opcode table out of sync
 must be a scalar floating point or integer type
The selector operand for OpSwitch must be the result of an instruction that generates an integer scalar
Expected literal string, found literal number '
Invalid extended instruction import '
Invalid word following !<integer>: 
Expected <opcode> or <result-id> at the beginning of an instruction, found '
Expected '=', found end of stream.
Expected opcode, found end of stream.
Expected <result-id> at the beginning of an instruction, found '
 does not produce a result ID.
Expected operand, found end of stream.
Expected operand, found next instruction instead.
 words.
Value 
Invalid OpTypeInt instruction
Unexpected numeric literal type
Unexpected result code from ParseAndEncodeNumber()
Instruction too long: more than 
 has already been used to generate a type
Invalid OpTypeFloat instruction
Value is being defined a second time
Import Id is being defined a second time
vector::reserve
Invalid SPIR-V magic number.
Invalid SPIR-V header.
 for target environment 
Entry point name "
A function (
WebGPU requires SPIR-V to be little endian.
Invalid SPIR-V binary version 
Invalid SPIR-V.  The id bound is larger than the max id bound 
2 Entry points cannot share the same name and ExecutionMode.
A FunctionCall must happen within a function body.
For WebGPU, functions need to be defined before being called.
Missing OpFunctionEnd at end of module.
The following forward referenced IDs have not been defined:\n
Entry points may not have a call graph with cycles.
" is not unique, which is not allow in WebGPU env.
Missing required OpMemoryModel instruction.
No OpEntryPoint instruction was found. This is only allowed if the Linkage capability is being used.
) may not be targeted by both an OpEntryPoint instruction and an OpFunctionCall instruction.
OpPhi must appear within a non-entry block before all 
(except for OpLine, which can be mixed with OpPhi).
OpLoopMerge must immediately precede either an 
OpBranch or OpBranchConditional instruction. 
OpLoopMerge must be the second-to-last instruction in 
OpSelectionMerge must immediately precede either an 
OpBranchConditional or OpSwitch instruction. 
OpSelectionMerge must be the second-to-last 
All OpVariable instructions in a function must be the first instructions in the first block.
non-OpPhi instructions 
instruction in its block.
Decorations that don't take ID parameters may not be used with OpDecorateId
OpDecorationGroup is not allowed in the WebGPU execution 
Result id of OpDecorationGroup can only 
be targeted by OpName, OpGroupDecorate, 
OpDecorate, OpDecorateId, and OpGroupMemberDecorate
 provided in OpMemberDecorate for struct <id> 
 is out of bounds. The structure has 
 members. Largest valid index is 
OpMemberDecorate decoration  '
' is not valid for the WebGPU execution environment.
OpMemberDecorate Structure type <id> '
OpGroupDecorate is not allowed in the WebGPU execution 
OpGroupDecorate Decoration group <id> '
OpGroupDecorate may not target OpDecorationGroup <id> '
OpGroupMemberDecorate is not allowed in the WebGPU execution 
 provided in OpGroupMemberDecorate for struct <id> 
OpGroupMemberDecorate Decoration group <id> '
OpGroupMemberDecorate Structure type <id> '
OpDecorate SpecId decoration target <id> '
' is not a scalar specialization constant.
Decorations taking ID parameters may not be used with OpDecorateId
Index 
' is not a struct type.
' is not a decoration group.
RelaxedPrecision
BufferBlock
RowMajor
ColMajor
ArrayStride
MatrixStride
GLSLShared
GLSLPacked
CPacked
BuiltIn
NoPerspective
Flat
Invariant
Restrict
Aliased
Coherent
NonWritable
NonReadable
SaturatedConversion
Location
Binding
DescriptorSet
XfbBuffer
XfbStride
FuncParamAttr
FPRoundingMode
FPFastMathMode
LinkageAttributes
NoContraction
InputAttachmentIndex
Alignment
MaxByteOffset
AlignmentId
MaxByteOffsetId
NoSignedWrap
NoUnsignedWrap
ExplicitInterpAMD
SecondaryViewportRelativeNV
PerTaskNV
RestrictPointerEXT
AliasedPointerEXT
HlslCounterBufferGOOGLE
HlslSemanticGOOGLE
OpDecorate decoration '
Expected arithmetic operands to be of Result Type: 
Expected arithmetic operands to have the same dimension 
Expected arithmetic operands to have the same bit width 
Expected float scalar type as Result Type: 
Expected component type to be equal to Result Type: 
Expected operands to have the same number of componenets: 
Expected float vector type as Result Type: 
Expected vector operand type to be equal to Result Type: 
Expected scalar operand type to be equal to the component 
Expected matrix operand type to be equal to Result Type: 
Expected component types of Result Type and vector to be 
Expected float matrix type as right operand: 
Expected component types of Result Type and matrix to be 
Expected number of columns of the matrix to be equal to 
Expected number of rows of the matrix to be equal to the 
Expected float matrix type as left operand: 
Expected column type of the matrix to be equal to Result Type: 
Expected component types of the operands to be equal: 
Expected number of columns of the matrix to be equal to the 
Expected float matrix type as Result Type: 
Expected column types of Result Type and left matrix to be 
Expected component types of Result Type and right matrix to be 
Expected number of columns of Result Type and right matrix to 
Expected number of columns of left matrix and number of rows 
Expected column type of Result Type to be equal to the type 
vector size of the right operand: 
Expected a struct as Result Type: 
Expected Result Type struct to have two members: 
Expected Result Type struct member types to be identical: 
Expected cooperative matrix type as A Type: 
Expected cooperative matrix type as B Type: 
Expected cooperative matrix type as C Type: 
Expected cooperative matrix type as Result Type: 
Cooperative matrix 'M' mismatch: 
Expected floating scalar or vector type as Result Type: 
Expected unsigned int scalar or vector type as Result Type: 
Expected int scalar or vector type as Result Type: 
Expected int scalar or vector type as operand: 
Expected float vector as operand: 
Expected float vector type as left operand: 
Expected float vector type as right operand: 
Expected Result Type struct member types to be integer scalar 
Expected Result Type struct member types to be unsigned 
Expected both operands to be of Result Type member type: 
Cooperative matrix scopes must match: 
Cooperative matrix 'N' mismatch: 
Cooperative matrix 'K' mismatch: 
 operand index 
type of the vector operand: 
type of the matrix operand: 
Result Type vector size: 
vector operand size: 
of right matrix to be equal: 
of the left operand: 
integer scalar or vector: 
: expected Result Type to be int or float scalar type
: expected Result Type to be bool scalar type
: expected Result Type to be int scalar type
: according to the Vulkan spec atomic Result Type needs to be a 32-bit int scalar type
: expected Pointer to be of type OpTypePointer
: storage class forbidden by universal validation rules.
: Function storage class forbidden when the Shader capability is declared.
: storage class must be Function, Workgroup, CrossWorkGroup or Generic in the OpenCL environment.
Storage class cannot be Generic in OpenCL 1.2 environment
: expected Pointer to point to a value of 32-bit int type
: expected Pointer to be a pointer to int or float 
: expected Pointer to point to a value of type Result Type
Volatile mask setting must match for Equal and Unequal memory semantics
: expected Value type and the type pointed to by Pointer to be the same
: expected Value to be of type Result Type
: expected Comparator to be of type Result Type
: 64-bit atomics require the Int64Atomics capability
OpControlBarrier requires one of the following Execution Models: TessellationControl, GLCompute or Kernel
: expected Result Type to be OpTypeNamedBarrier
: expected Subgroup Count to be a 32-bit int
: expected Named Barrier to be of type OpTypeNamedBarrier
Expected Base to be int scalar or vector: 
Expected Base to have the same dimension 
Expected Base to have the same bit width 
Expected Shift to have the same dimension 
Expected operands to have the same dimension 
Expected operands to have the same bit width 
Expected Base Type to be equal to Result Type: 
Expected Insert Type to be equal to Result Type: 
Expected Base Type to be int scalar or vector: 
Expected Base dimension to be equal to Result Type dimension: 
Expected Shift to be int scalar or vector: 
Expected int scalar or vector as operand: 
Expected Offset Type to be int scalar: 
Expected Count Type to be int scalar: 
According to the 
 spec BuiltIn 
> (Op
 uses storage class 
Member #
 of struct ID <
 is not an array.
 components.
 is not a float vector.
 is not a float scalar.
 has bit width 
 is not an int scalar.
 is referencing 
 which is dependent on 
 in function <
 called with execution model 
 is not an int vector.
 is not a bool scalar.
Vulkan spec allows BuiltIn 
 depends on 
 Id <
> is later referenced by 
Using BuiltIn 
 is not a constant.
According to the Vulkan spec BuiltIn InvocationId variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn HelperInvocation variable needs to be a bool scalar. 
According to the Vulkan spec BuiltIn Position variable needs to be a 4-component 32-bit float vector. 
According to the WebGPU spec BuiltIn Position variable needs to be a 4-component 32-bit float vector. 
According to the Vulkan spec BuiltIn PatchVertices variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn PointCoord variable needs to be a 2-component 32-bit float vector. 
According to the Vulkan spec BuiltIn PointSize variable needs to be a 32-bit float scalar. 
According to the Vulkan spec BuiltIn PrimitiveId variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn SampleId variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn SampleMask variable needs to be a 32-bit int array. 
According to the WebGPU spec BuiltIn LocalInvocationIndex variable needs to be a 32-bit int.
According to the Vulkan spec BuiltIn SamplePosition variable needs to be a 2-component 32-bit float vector. 
According to the Vulkan spec BuiltIn TessCoord variable needs to be a 3-component 32-bit float vector. 
According to the Vulkan spec BuiltIn TessLevelOuter variable needs to be a 4-component 32-bit float array. 
According to the Vulkan spec BuiltIn TessLevelOuter variable needs to be a 2-component 32-bit float array. 
 spec BuiltIn FrontFacing variable needs to be a bool scalar. 
 spec BuiltIn InstanceIndex variable needs to be a 32-bit int scalar. 
 spec BuiltIn FragCoord variable needs to be a 4-component 32-bit float vector. 
 spec BuiltIn WorkgroupSize variable needs to be a 3-component 32-bit int vector. 
 spec BuiltIn VertexIndex variable needs to be a 32-bit int scalar. 
 spec BuiltIn FragDepth variable needs to be a 32-bit float scalar. 
variable needs to be a 32-bit int scalar. 
According to the Vulkan spec BuiltIn 
 variable needs to be a 32-bit float array. 
 variable needs to be a 32-bit int. 
 variable needs to be a 32-bit int vector. 
 variable needs to be a 4-component 32-bit int vector. 
 variable needs to be a 3-component 32-bit int vector. 
 components are not float scalar.
 has components with bit width 
 which is decorated with BuiltIn 
Attempted to get underlying data type via member index for non-struct type.
 did not find an member index to get underlying data type for struct type.
 is decorated with BuiltIn. BuiltIn decoration should only be applied to struct types, variables and constants.
 to be only used for variables with Input or Output storage class. 
Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be used for variables with Input storage class if execution model is Vertex.
Vulkan spec doesn't allow BuiltIn ClipDistance/CullDistance to be used for variables with Output storage class if execution model is Fragment.
 to be used only with Fragment, Vertex, TessellationControl, TessellationEvaluation or Geometry execution models. 
> which is called with execution model 
 spec allows BuiltIn FragCoord to be only used for variables with Input storage class. 
 spec allows BuiltIn FragCoord to be used only with Fragment execution model. 
 spec allows BuiltIn FragDepth to be only used for variables with Output storage class. 
 spec allows BuiltIn FragDepth to be used only with Fragment execution model. 
 spec requires DepthReplacing execution mode to be declared when using BuiltIn FragDepth. 
 spec allows BuiltIn FrontFacing to be only used for variables with Input storage class. 
 spec allows BuiltIn FrontFacing to be used only with Fragment execution model. 
 to be used only with GLCompute execution model. 
Vulkan spec allows BuiltIn HelperInvocation to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn HelperInvocation to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn InvocationId to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn InvocationId to be used only with TessellationControl or Geometry execution models. 
 spec allows BuiltIn InstanceIndex to be only used for variables with Input storage class. 
 spec allows BuiltIn InstanceIndex to be used only with Vertex execution model. 
Vulkan spec doesn't allow BuiltIn Layer and ViewportIndex to be used for variables with Input storage class if execution model is Vertex, TessellationEvaluation, or Geometry.
Vulkan spec doesn't allow BuiltIn Layer and ViewportIndex to be used for variables with Output storage class if execution model is Fragment.
 in Vertex or Tessellation execution model requires the ShaderViewportIndexLayerEXT capability.
 to be used only with Vertex, TessellationEvaluation, Geometry, or Fragment execution models. 
Vulkan spec allows BuiltIn PatchVertices to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn PatchVertices to be used only with TessellationControl or TessellationEvaluation execution models. 
Vulkan spec allows BuiltIn PointCoord to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn PointCoord to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn PointSize to be only used for variables with Input or Output storage class. 
Vulkan spec doesn't allow BuiltIn PointSize to be used for variables with Input storage class if execution model is Vertex.
Vulkan spec allows BuiltIn PointSize to be used only with Vertex, TessellationControl, TessellationEvaluation or Geometry execution models. 
Vulkan spec allows BuiltIn Position to be only used for variables with Input or Output storage class. 
Vulkan spec doesn't allow BuiltIn Position to be used for variables with Input storage class if execution model is Vertex.
Vulkan spec allows BuiltIn Position to be used only with Vertex, TessellationControl, TessellationEvaluation or Geometry execution models. 
WebGPU spec allows BuiltIn Position to be only used for variables with Output storage class. 
WebGPU spec allows BuiltIn Position to be used only with the Vertex execution model. 
Vulkan spec allows BuiltIn PrimitiveId to be only used for variables with Input or Output storage class. 
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is TessellationControl.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is TessellationEvaluation.
Vulkan spec doesn't allow BuiltIn PrimitiveId to be used for variables with Output storage class if execution model is Fragment.
Vulkan spec allows BuiltIn PrimitiveId to be used only with Fragment, TessellationControl, TessellationEvaluation or Geometry execution models. 
Vulkan spec allows BuiltIn SampleId to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn SampleId to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn SampleMask to be only used for variables with Input or Output storage class. 
Vulkan spec allows BuiltIn SampleMask to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn SamplePosition to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn SamplePosition to be used only with Fragment execution model. 
Vulkan spec allows BuiltIn TessCoord to be only used for variables with Input storage class. 
Vulkan spec allows BuiltIn TessCoord to be used only with TessellationEvaluation execution model. 
Vulkan spec doesn't allow TessLevelOuter/TessLevelInner to be used for variables with Input storage class if execution model is TessellationControl.
Vulkan spec doesn't allow TessLevelOuter/TessLevelInner to be used for variables with Output storage class if execution model is TessellationEvaluation.
 spec allows BuiltIn VertexIndex to be only used for variables with Input storage class. 
 spec allows BuiltIn VertexIndex to be used only with Vertex execution model. 
Vulkan spec allows BuiltIn InstanceId to be used only with IntersectionNV, ClosestHitNV and AnyHitNV execution models. 
WebGPU spec allows BuiltIn LocalInvocationIndex to be only used for variables with Input storage class. 
WebGPU spec allows BuiltIn VertexIndex to be used only with GLCompute execution model. 
 components are not int scalar.
 cannot be used as a member decoration 
BuiltIns can only target variables, structs or constants
WebGPU does not allow BuiltIn 
Vulkan spec requires BuiltIn WorkgroupSize to be a constant. 
Vulkan spec doesn't allow BuiltIn VertexId/InstanceId to be used.
Full
Capability 
 (or requires extension)
 Profile specification
 is not allowed by Vulkan 1.0 specification
 is not allowed by Vulkan 1.1 specification
 is not allowed by OpenCL 1.2 
 (or requires extension or capability)
 is not allowed by OpenCL 2.0/2.1 
 is not allowed by OpenCL 2.2 
 is not allowed by WebGPU specification
'Target Label' operands for OpSwitch must be IDs of an OpLabel instruction
'Target Label' operands for OpBranch must be the ID of an OpLabel instruction
 is already a merge block for another header
OpBranchConditional requires either 3 or 5 parameters
Condition operand for OpBranchConditional must be of boolean type
The 'True Label' operand for OpBranchConditional must be the ID of an OpLabel instruction
The 'False Label' operand for OpBranchConditional must be the ID of an OpLabel instruction
Merge Block may not be the block containing the OpLoopMerge\n
Merge Block and Continue Target must be different ids
Unroll and DontUnroll loop controls must not both be specified
PeelCount and DontUnroll loop controls must not both be specified
PartialCount and DontUnroll loop controls must not both be specified
IterationMultiple loop control operand must be greater than zero
OpReturnValue value's type <id> '
' is a pointer, which is invalid in the Logical addressing model.
's type does not match OpFunction's return type.
For WebGPU, unreachable merge-blocks must be referenced by a reachable merge instruction.
For WebGPU, unreachable merge-blocks must terminate with OpUnreachable.
For WebGPU, unreachable merge-blocks must only contain an OpLabel and OpUnreachable instruction.
For WebGPU, unreachable merge-blocks cannot be the target of a branch.
For WebGPU, unreachable continue-target must be referenced by a loop instruction.
For WebGPU, unreachable continue-target must be referenced by a reachable loop instruction.
For WebGPU, unreachable continue-target must terminate with OpBranch.
For WebGPU, unreachable continue-target must only contain an OpLabel and an OpBranch instruction.
For WebGPU, unreachable continue-target cannot be the target of a branch.
For WebGPU, unreachable continue-target must only have a back edge to a single reachable loop instruction.
For WebGPU, all blocks must be reachable, unless they are 
degenerate cases of merge-block or continue-target.
 has branches to multiple other case construct targets 
 (not another case construct, corresponding merge, outer loop merge or outer loop continue)
Multiple case constructs have branches to the case construct that targets 
 does not dominate its case construct 
 has branches to the case construct that targets 
, but does not immediately precede it in the OpSwitch's target list
) can only be formed between a block and a loop header.
 back-edge blocks but the standard requires exactly one
. This may be a bug in the validator.
, but not via a structured exit
OpReturn can only be called from a function with void 
OpKill requires Fragment execution model
OpPhi does not have an equal number of incoming values and basic blocks.
OpPhi's number of incoming blocks (
) does not match block's predecessor count (
 does not match incoming value <id> 
OpPhi's incoming basic block <id> 
Using pointers with OpPhi requires capability 
VariablePointers or VariablePointersStorageBuffer
 is not a predecessor of <id> 
 are referenced but not defined in function 
Maximum Control Flow nesting depth exceeded.
 appears in the binary before its dominator 
First block 
 of function 
 is targeted by block 
Merge Block 
 must be an OpLabel
Continue Target 
OpReturnValue Value <id> '
' does not represent a value.
' is missing or void.
 is dominated by: 
selection header
merge block
loop header
continue target
back-edge block
case entry block
case exit block
The 
 construct with the 
Case construct that targets 
 and 
 has invalid branch to block 
Selection header 
Back-edges (
Loop header 
 is targeted by 
Construct 
 does not have a 
does not dominate
is not post dominated by
block <ID> 
 exits the 
 headed by <ID> 
 branches to the 
 construct, but not to the 
does not strictly dominate
OpPhi's result type <id> 
 is not an OpLabel.
Block(s) 
Expected Result Type and Operand type to be the same
Result Type must not equal the Operand type
Result Type does not logically match the Operand type
Cannot copy composites of 8- or 16-bit types
Expected Result Type to be a scalar type
Expected Vector type to be OpTypeVector
Expected Vector component type to be equal to Result Type
Expected Index to be int scalar
Cannot extract from a vector of 8- or 16-bit types
Expected Result Type to be OpTypeVector
Expected Vector type to be equal to Result Type
Expected Component type to be equal to Result Type 
Cannot insert into a vector of 8- or 16-bit types
Expected Result Type to be a matrix type
Expected Matrix to be of type OpTypeMatrix
Expected component types of Matrix and Result Type to be 
Expected number of columns and the column size of Matrix 
to be the reverse of those of Result Type
Cannot transpose matrices of 16-bit floats
Expected number of constituents to be at least 2
Expected total number of given components to be equal 
to the size of Result Type vector
Expected total number of Constituents to be equal 
to the number of columns of Result Type matrix
Expected Constituent type to be equal to the column 
to the number of elements of Result Type array
to the number of members of Result Type struct
Expected Constituent type to be equal to the 
corresponding member type of Result Type struct
Expected Constituent type to be equal to the component type
Expected Result Type to be a composite type
Expected Constituents to be scalars or vectors of
 the same type as Result Type components
Cannot create a composite containing 8- or 16-bit types
Expected Composite to be an object of composite type
Vector access is out of bounds, vector size is 
Matrix access is out of bounds, matrix has 
 columns, but access index is 
Array access is out of bounds, array size is 
Index is out of bounds, can not find index 
Reached non-composite type while indexes still remain to be traversed.
The Result Type must be the same as Composite type in Op
) does not match the type that results from indexing into the Composite (Op
Cannot insert into a composite of 8- or 16-bit types
) does not match the type that results from indexing into the composite (Op
Cannot extract from a composite of 8- or 16-bit types
OpVectorShuffle component literals count does not match Result Type <id> '
The Component Type of Vector 1 must be the same as ResultType.
The Component Type of Vector 2 must be the same as ResultType.
combined (Vector1 + Vector2) size of 
 cannot be 0xFFFFFFFF in WebGPU execution environment.
The Result Type of OpVectorShuffle must be
The type of Vector 1 must be OpTypeVector.
The type of Vector 2 must be OpTypeVector.
Cannot shuffle a vector of 8- or 16-bit types
component type
identical
type Result Type matrix
type Result Type array
Expected single constituent
The number of indexes in Op
 may not exceed 
. Found 
 indexes.
, but access index is 
 in the structure <id> '
'. This structure has 
 yielding Result Id 
The Object type (Op
Result type (Op
's vector component count.
Component index 
 is out of bounds for 
Component literal at operand 
 OpTypeVector. Found Op
's matrix column count.
Column type is not defined.
Result type is not defined.
 Constituent <id> '
's matrix column type.
Element type is not defined.
Length is not defined.
's array length.
's array element type.
's struct member count.
' count must be one.
' is not a composite type.
' is not a constant or undef.
's vector element type.
's member type.
's component type.
' is not a boolean type.
 requires Shader capability
 requires Kernel capability
' is not a sampler type.
' cannot have a null value.
 Constituent <id> count does not match Result Type <id> '
Component type is not defined.
' type does not match Result Type <id> '
' component type does not match Result Type <id> '
's matrix column component type.
' vector component count does not match Result Type <id> '
 Constituent count does not match Result Type <id> '
's type does not match Result Type <id> '
' count does not match Result Type <id> '
' type does not match the Result Type <id> '
Specialization constant must be an integer or floating-point number.
Specialization constant operation 
OpConstantSampler Result Type <id> '
OpConstantNull Result Type <id> '
Prior to SPIR-V 1.4, specialization constant operation UConvert requires Kernel capability or extension SPV_AMD_gpu_shader_int16
Cannot form constants of 8- or 16-bit types
Expected input to have the same dimension as Result Type: 
Expected input to have different bit width from Result Type: 
Expected input type to be equal to Result Type: 
Expected unsigned int scalar type as Result Type: 
Expected input to be a pointer: 
Logical addressing not supported: 
Pointer storage class must be PhysicalStorageBufferEXT: 
Expected Result Type to be a pointer: 
Expected Result Type to have storage class Generic: 
Expected input to have storage class Workgroup, 
Expected input and Result Type to point to the same type: 
Expected Result Type to have storage class Workgroup, 
Expected input to have storage class Generic: 
Expected Result Type to be of target storage class: 
Expected target storage class to be Workgroup, 
Expected input to have a type: 
Expected input to be a pointer, int scalar or 32-bit int vector if Result Type is pointer: 
Pointer can only be converted to another pointer, int scalar or 32-bit int vector: 
Expected input to be a pointer or int scalar if Result Type is pointer: 
Pointer can only be converted to another pointer or int scalar: 
Expected input to have the same total bit width as 
Expected input to be float scalar or vector: 
Expected float scalar or vector type as Result Type: 
Expected input to be int scalar or vector: 
Expected 32-bit float scalar or vector type as Result Type: 
Expected int scalar or vector as input: 
Expected int scalar as input: 
Expected Result Type to be a pointer or int or float vector 
Expected input to be a pointer or int or float vector 
8- or 16-bit types can only be used with width-only conversions
CrossWorkgroup or Function: 
or scalar type: 
or scalar: 
' index is larger than Type <id> '
Debugging instructions are not allowed in the WebGPU execution 
OpMemberName Member <id> '
's member count.
OpMemberName Type <id> '
OpLine Target <id> '
' is not an OpString.
or storage buffer
UniformId
 and ending with 
 gets larger than 3
Function declaration (id 
Function definition (id 
 decoration targeting 
 (member index 
uniform buffer
scalar 
relaxed 
standard 
Structure id 
 decorated as 
 for variable in 
 storage class must follow 
 layout rules: member 
at offset 
 is not aligned to 
is a matrix with stride 
 not satisfying alignment to 
ID '
' decorated with 
' decorated with both 
 is not allowed.
', member '
Storage Buffer
PushConstant
Entry point id '
From ARB_gl_spirv extension:\n
Storage buffer id '
PushConstant id '
StorageBuffer id '
Uniform id '
UniformConstant id '
 for Entry Point id 
A BuiltIn variable (id 
 decoration may not be applied to 
storage buffer, or variable in Private or Function storage class
Target of NonWritable decoration must be a memory object declaration (a variable or a function parameter)
Target of NonWritable decoration is invalid: must point to a storage image, uniform block, 
 decoration applied to a value with void type
 decoration applied to an object with invalid type
 decoration applied to a non-object
Target of Component decoration must be a memory object declaration (a variable or a function parameter)
Target of Component decoration is invalid: must point to a Storage Class of Input(1) or Output(3). Found Storage Class 
Sequence of components starting with 
Component decoration specified for type 
 that is not a scalar or vector
FPRoundingMode decoration can be applied only to a width-only conversion instruction for floating-point object.
FPRoundingMode decoration can be applied only to the Object operand of an OpStore.
FPRoundingMode decoration can be applied only to the Object operand of an OpStore in the StorageBuffer, PhysicalStorageBufferEXT, Uniform, PushConstant, Input, or Output Storage Classes.
FPRoundingMode decoration can be applied only to the Object operand of an OpStore storing through a pointer to a 16-bit floating-point scalar or vector object.
A module-scope OpVariable with initialization value cannot be marked with the Import Linkage Type.
) must have a LinkageAttributes decoration with the Import Linkage type.
) may not be decorated with Import Linkage type.
 is banned when using the Vulkan memory model.
is missing an Offset decoration
 is not aligned to scalar element size 
 overlaps previous member ending at offset 
is an improperly straddling vector at offset 
contains an array with stride 
 multiple times is not allowed.
' uses more than one PushConstant interface.\n
From Vulkan spec, section 14.5.1:\n
There must be no more than one push constant block 
statically used per shader entry point.
' is missing Binding decoration.\n
Uniform and shader storage block variables must 
also be decorated with a *Binding*.
 In Vulkan, BufferBlock is disallowed on variables in the StorageBuffer storage class
' is missing Block decoration.\n
Such variables must be identified with a Block decoration
From Vulkan spec, section 14.5.2:\n
' is missing Block or BufferBlock decoration.\n
Such variables must be identified with a Block or BufferBlock decoration
 must be explicitly laid out with Offset decorations.
 must not use GLSLShared decoration.
 must not use GLSLPacked decoration.
 must be explicitly laid out with ArrayStride decorations.
 must be explicitly laid out with MatrixStride decorations.
' is missing DescriptorSet decoration.\n
These variables must have DescriptorSet and Binding decorations specified
OpEntryPoint interfaces should only list global variables
Non-unique OpEntryPoint interface 
OpEntryPoint interfaces must be OpVariables with Storage Class of Input(1) or Output(3). Found Storage Class 
There must be at most one object per Storage Class that can contain a structure type containing members decorated with BuiltIn, consumed per entry-point. Entry Point id 
 does not meet this requirement.
The LinkageAttributes Decoration (Linkage name: 
) cannot be applied to function id 
 because it is targeted by an OpEntryPoint instruction.
Interfaces passed to OpEntryPoint must be of type OpTypeVariable. Found Op
) cannot have any Location or Component decorations
Derivative instructions require Fragment or GLCompute execution model: 
Derivative instructions require DerivativeGroupQuadsNV or DerivativeGroupLinearNV execution mode for GLCompute execution model: 
Expected Result Type to be float scalar or vector type: 
Expected P type and Result Type to be the same: 
Unknown ExtInst
16-bit or 32-bit 
int scalar or vector type
number as Result Type
of Result Type struct
For WebGPU, the only valid parameter to OpExtInstImport is "GLSL.std.450".
For WebGPU, the only valid parameter to OpExtension is 
expected Result Type to be a float scalar or vector type
expected types of all operands to be equal to Result Type
expected Result Type to be an int scalar or vector type
expected all operands to be int scalars or vectors
expected all operands to have the same dimension as 
expected all operands to have the same bit width as 
this instruction is currently limited to 32-bit width 
expected Result Type to be a 16 or 32-bit scalar or vector float type
expected operand X component type to be equal to 
expected operand X type to be equal to Result Type
expected Result Type to be a scalar or vector float type
expected operand I to be a pointer
expected operand I data type to be equal to Result Type
expected Result Type to be a struct with two identical 
scalar or vector float type members
expected operand X type to be equal to members of 
expected operand Exp to be a pointer
expected operand Exp data type to be a 
expected operand Exp data type to have the same component 
expected operand Exp to be a 32-bit int scalar 
expected operand Exp to have the same component 
expected Result Type to be a struct with two members, 
first member a float scalar or vector, second member a 
int scalar or vector with the same number of 
components as the first member
expected operand X type to be equal to the first member 
expected operand V to be a 32-bit float vector of size 2
expected operand V to be a 32-bit int vector of size 2
expected operand P to be a 32-bit int scalar
expected Result Type to be a float scalar type
expected operand X to be of float scalar or vector type
expected operand X component type to be equal to Result Type
expected operand P0 to be of float scalar or vector type
expected operand P0 component type to be equal to 
expected operand P1 to be of float scalar or vector type
expected operand P1 component type to be equal to 
expected operands P0 and P1 to have the same number of 
expected Result Type to be a float vector type
expected Result Type to have 3 components
expected operand Y type to be equal to Result Type
expected operand I to be of type equal to Result Type
expected operand N to be of type equal to Result Type
expected operand Eta to be a float scalar
 requires capability InterpolationFunction
expected Interpolant to be a pointer
expected Interpolant data type to be equal to Result Type
expected Interpolant storage class to be Input
 requires Fragment execution model
Extended instruction GLSLstd450IMix is not supported
Encountered extended instruction GLSLstd450Bad
expected Result Type to be a scalar or a vector with 2, 3, 4, 8 or 16 components
expected type of operand X to be equal to Result Type
expected the last operand to be a pointer
expected data type of the pointer to be equal to Result Type
expected type of operand Y to be equal to Result Type
expected data type of the pointer to be a 32-bit int scalar or vector type
expected data type of the pointer to have the same number of components as Result Type
expected operand X to be a float scalar or vector
expected operand X to have the same number of components as Result Type
expected the exponent to have the same number of components as Result Type
expected Nancode to be an int scalar or vector type
expected Nancode to have the same number of components as Result Type
expected Nancode to have the same bit width as Result Type
expected bit width of Result Type components to be 16, 32 or 64
expected Hi and Lo operands to have the same type
expected Hi and Lo operands to have the same number of components as Result Type
expected bit width of components of Hi and Lo operands to be half of the bit width of components of Result Type
expected Result Type to have 3 or 4 components
expected operand P0 to have no more than 4 components
expected operands P0 and P1 to be of the same type
expected operand P to be a float scalar or vector
expected operand P to have no more than 4 components
expected operand P component type to be equal to Result Type
expected Result Type to have no more than 4 components
expected operand P type to be equal to Result Type
expected operand A type to be equal to Result Type
expected operand B type to be equal to Result Type
expected operand C to be an int scalar or vector
expected operand C to have the same number of components as Result Type
expected operand C to have the same bit width as Result Type
expected Result Type to have 2, 3, 4, 8 or 16 components
expected operand Offset to be of type size_t (
-bit integer for the addressing model used in the module)
expected operand P to be a pointer
expected operand P data type to be equal to component type of Result Type
expected literal N to be equal to the number of components of Result Type
: expected Result Type to be void
expected Data to have 2, 3, 4, 8 or 16 components
 can only be used with physical addressing models
expected operand P data type to be equal to the type of operand Data components
expected operand P data type to be 16-bit float scalar
expected Result Type to have 2, 4, 8 or 16 components
expected operands X and Y to be of the same type
expected operand X to have 2, 4, 8 or 16 components
expected operand X and Result Type to have equal component types
expected operand Shuffle Mask to be an int vector
expected operand Shuffle Mask to have the same number of components as Result Type
expected operand Shuffle Mask components to have the same bit width as Result Type components
expected operand Format to be a pointer
expected Format storage class to be UniformConstant
expected operand Ptr to be a pointer
expected operand Ptr storage class to be CrossWorkgroup
expected operand X to be a square matrix
expected Result Type to be a square matrix
expected Result Type to be 32-bit int scalar type
expected operand V to be a 32-bit float vector of size 4
expected Result Type to be 64-bit float scalar type
expected Result Type to be a 32-bit float vector of size 4
expected Result Type to be a 32-bit float vector of size 2
expected Result Type to be a 32-bit int vector of size 2
expected operand V to be a 64-bit float scalar
expected Result Type to be a 32-bit float scalar 
expected Sample to be 32-bit integer
expected Offset to be a vector of 2 32-bit floats
expected storage class of the pointer to be Generic, CrossWorkgroup, Workgroup or Function
expected Result Type to be a 32-bit int scalar or vector type
expected the exponent to be a 32-bit int scalar or vector
expected Result Type to be an int or float scalar or vector type
expected Result Type to be an int or float vector type
expected operand P storage class to be UniformConstant, Generic, CrossWorkgroup, Workgroup or Function
expected Data to be an int or float vector
expected operand P storage class to be Generic, CrossWorkgroup, Workgroup or Function
expected Data to be a 32 or 64-bit float scalar
expected Data to be a 32 or 64-bit float vector
expected operand X to be an int or float vector
expected Result Type to be a 32-bit int type
expected Format data type to be 8-bit int
expected Ptr data type to be int or float scalar or vector
expected operand Num Elements to be of type size_t (
Internal error: missing function id 
Internal error: empty execution models for function id 
OpEntryPoint Entry Point <id> '
's callgraph contains function <id> 
, which cannot be used with the current execution model:\n
, which cannot be used with the current execution modes:\n
' does not match the Function Type's return type <id> '
Invalid use of function result id 
OpFunction Function Type <id> '
Function parameter cannot be the first instruction.
Function parameter must be preceded by a function.
Missing function type definition.
Too many OpFunctionParameters for 
: expected Aliased or Restrict for PhysicalStorageBufferEXT pointer.
: can't specify both Aliased and Restrict for PhysicalStorageBufferEXT pointer.
: expected AliasedPointerEXT or RestrictPointerEXT for PhysicalStorageBufferEXT pointer.
: can't specify both AliasedPointerEXT and RestrictPointerEXT for PhysicalStorageBufferEXT pointer.
OpFunctionParameter Result Type <id> '
' does not match the OpTypeFunction parameter type of the same index.
OpFunctionCall Function <id>'s parameter count does not match the argument count.
StorageBuffer pointer operand 
 requires a variable pointers capability
Invalid storage class for pointer operand 
 must be a memory object declaration
OpFunctionCall Function <id> '
OpFunctionCall Result Type <id> '
's type does not match Function <id> '
OpFunctionCall Argument <id> '
OpFunction Result Type <id> '
' is not a function type.
: expected 
 based on the function's type
OpFunctionParameter 
Missing argument 
 type definition.
Pointer operand 
' is not a function.
's return type.
's parameter type.
 has not been defined
 is not a type id
Operand 
 cannot be a type
 requires a type
 defined in block 
 used in function 
In OpPhi instruction 
, ID 
 requires a previous definition
 does not dominate its use in block 
 is used outside of it's defining function 
 definition does not dominate its parent 
Expected Result Type to be int scalar type
Expected operand to be of type OpTypeImage
OpImageQueryLod requires Fragment or GLCompute execution model
ImplicitLod instructions require Fragment or GLCompute execution model: 
OpImageQueryLod requires DerivativeGroupQuadsNV or DerivativeGroupLinearNV execution mode for GLCompute execution model
Expected Result Type to be bool scalar type
Expected Resident Code to be int scalar
ImplicitLod instructions require DerivativeGroupQuadsNV or DerivativeGroupLinearNV execution mode for GLCompute execution model: 
Expected Result Type to be OpTypeStruct
Expected Result Type to be a struct containing an int scalar and a texel
Expected Result Type to be OpTypeImage
Expected Sample Image to be of type OpTypeSampleImage
Expected Sample Image image type to be equal to Result Type
Expected Image 'Dim' parameter to be 1D, 2D, 3D or Rect
Image Image 'MS' parameter to be 0
Image Image 'arrayed' parameter to be 0
Expected Image 'Sampled' parameter to be 0 or 2
Capability Image1D is required to access storage image
Capability ImageRect is required to access storage image
Capability ImageBuffer is required to access storage image
Capability ImageCubeArray is required to access 
Expected Image to be of type OpTypeImage
Image 'Dim' must be 1D, 2D, 3D or Cube
Expected Result Type to be int scalar or vector type
Image 'Dim' must be 1D, Buffer, 2D, Cube, 3D or Rect
Image must have either 'MS'=1 or 'Sampled'=0 or 'Sampled'=2
Expected Level of Detail to be int scalar
Sampled Type must be OpTypeVoid in the OpenCL environment.
Expected Sampled Type to be either void or
In the OpenCL environment, Arrayed may only be set to 1 
MS must be 0 in the OpenCL environement.
Sampled must be 0 in the OpenCL environment.
Dim SubpassData requires Sampled to be 2
Dim SubpassData requires format Unknown
In the OpenCL environment, the optional Access Qualifier
Expected Sampled Type to be a 32-bit int or float scalar type for Vulkan environment
Expected Result Type to be float vector type
Expected Result Type to have 2 components
Expected Image operand to be of type OpTypeSampledImage
Expected Coordinate to be float scalar or vector
Expected Coordinate to have at least 
Expected Coordinate to be int or float scalar or vector
Expected Result Type to be OpTypeSampledImage.
Expected Image to be of type OpTypeImage.
Expected Image 'Sampled' parameter to be 1 
Expected Image 'Sampled' parameter to be 0 or 1
Expected Image 'Dim' parameter to be not SubpassData.
Expected Sampler to be of type OpTypeSampler
All OpSampledImage instructions must be in the same block in which their Result <id> are consumed. OpSampledImage Result Type <id> '
' has a consumer in a different basic block. The consumer instruction <id> is '
Result <id> from OpSampledImage instruction must not appear as operands of Op
, since it is not specificed as taking an 
Result <id> from OpSampledImage instruction must not appear as operand for Op
Number of image operand ids doesn't correspond to the bit mask
Image Operands Offset, ConstOffset, ConstOffsets cannot be used 
Image Operand Bias can only be used with ImplicitLod opcodes
Expected Image Operand Bias to be float scalar
Image Operand Bias requires 'Dim' parameter to be 1D, 2D, 3D or Cube
Image Operand Bias requires 'MS' parameter to be 0
Image Operand Lod can only be used with ExplicitLod opcodes 
Image Operand bits Lod and Grad cannot be set at the same time
Expected Image Operand Lod to be float scalar when used 
Expected Image Operand Lod to be int scalar when used with 
Image Operand Lod requires 'Dim' parameter to be 1D, 2D, 3D or Cube
Image Operand Lod requires 'MS' parameter to be 0
Image Operand Grad can only be used with ExplicitLod opcodes
Expected Image Operand Grad dx to have 
Expected Image Operand Grad dy to have 
Image Operand Grad requires 'MS' parameter to be 0
Image Operand ConstOffset cannot be used with Cube Image 'Dim'
Expected Image Operand ConstOffset to be int scalar or 
Expected Image Operand ConstOffset to be a const object
Expected Image Operand ConstOffset to have 
Image Operand Offset cannot be used with Cube Image 'Dim'
Expected Image Operand Offset to be int scalar or 
Expected Image Operand Offset to have 
Image Operand ConstOffsets can only be used with OpImageGather and OpImageDrefGather
Image Operand ConstOffsets cannot be used with Cube Image 'Dim'
Expected Image Operand ConstOffsets to be an array of size 4
Expected Image Operand ConstOffsets to be a const object
Image Operand Sample can only be used with OpImageFetch, 
OpImageRead, OpImageWrite, OpImageSparseFetch and 
Image Operand Sample requires non-zero 'MS' parameter
Expected Image Operand Sample to be int scalar
Image Operand MinLod can only be used with ImplicitLod 
opcodes or together with Image Operand Grad
Expected Image Operand MinLod to be float scalar
Image Operand MinLod requires 'Dim' parameter to be 1D, 2D, 3D or Cube
Image Operand MinLod requires 'MS' parameter to be 0
Image Operand MakeTexelAvailableKHR can only be used with Op
Image Operand MakeTexelAvailableKHR requires NonPrivateTexelKHR is also specified: Op
Image Operand MakeTexelVisibleKHR can only be used with Op
Image Operand MakeTexelVisibleKHR requires NonPrivateTexelKHR is also specified: Op
Expected both Image Operand Grad ids to be float scalars or 
Expected Image Operand ConstOffsets array componenets to be int vectors of size 2
Image 'Dim' cannot be SubpassData
Expected Coordinate to be int scalar or vector
Expected Image 'Sampled Type' to be the same as Texel 
Optional Image Operands are not allowed in the OpenCL 
Expected Texel to be int or float vector or scalar
Capability StorageImageWriteWithoutFormat is required to write 
 to be int or float scalar type
Expected Sampled Image to be of type OpTypeSampledImage
Expected Image 'Sampled Type' to be the same as 
Expected Dref to be of 32-bit float type
 to be int or float vector type
Expected Image 'Dim' cannot be Cube
Expected Component to be 32-bit int scalar
Expected Result Type to be OpTypePointer
Expected Result Type to be OpTypePointer whose Storage Class operand is Image
Expected Result Type to be OpTypePointer whose Type operand must be a scalar numerical type or OpTypeVoid
Expected Image to be OpTypePointer with Type OpTypeImage
Expected Image 'Sampled Type' to be the same as the Type pointed to by Result Type
Image Dim SubpassData cannot be used with OpImageTexelPointer
Expected Image 'Dim' must be one of 1D, 2D, or Cube when Arrayed is 1
Expected Image to be OpTypePointer
Expected Coordinate to be integer scalar or vector
Expected Sample to be integer scalar
Expected Sample for Image with MS 0 to be a valid <id> for the value 0
Expected Image 'Sampled' parameter to be 1
ConstOffset image operand not allowed 
 to be int or float scalar or vector type
Image Dim SubpassData cannot be used with ImageSparseRead
Dim SubpassData requires Fragment execution model: 
Capability StorageImageReadWithoutFormat is required to 
Instruction reserved for future use, use of this instruction 
Image 'Dim' must be 2D
Image 'MS' must be 1
Corrupt image type definition
Result Type has 
 components, 
but 
Image 'MS' must be 0
 numerical scalar type
Invalid Depth 
 (must be 0, 1 or 2)
Invalid Arrayed 
 (must be 0 or 1)
when Dim is either 1D or 2D.
Invalid MS 
Invalid Sampled 
 must be present.
 components, but given only 
for Vulkan environment.
 Found result <id> '
' as an operand of <id> '
OpTypeSampledImage.
together
and OpImageFetch
with ExplicitLod
 components, but given 
OpImageSparseRead
 or Op
vectors
to storage image
Result Type's second member
Expected 
 to have 4 components
Expected Coordinate to have 
Image 'Dim' cannot be Cube
in the OpenCL environment.
read storage image
Interface variable id <
> is used by entry point '
' id <
>, but is not listed as an interface
 operand of 
: operand 
) requires SPIR-V version 
 or earlier
 or later
Found unrecognized extension 
Invalid Opcode name 'Op
Opcode 
Result <id> '
) has exceeded the limit (
) exceeds the limit (
 is reserved for future use.
 requires 
 at minimum.
 requires one of these capabilities: 
) requires one of these extensions: 
Number of local variables ('Function' Storage Class) exceeded the valid limit (
Number of Global Variables (Storage Class other than 'Function') exceeded the valid limit (
' must be less than the ID bound '
Number of OpTypeStruct members (
Structure Nesting Depth may not be larger than 
Number of (literal, label) pairs in OpSwitch (
 requires one of the following extensions: 
 at minimum or one of the following extensions: 
OpMemoryModel should only be provided once.
Cannot declare a function in a function body
Function parameter instructions must be in a function body
Function parameters must only appear immediately after the function definition
Function end instructions must be in a function body
Function end cannot be called in blocks
Label instructions must be in a function body
A block must end with a branch instruction.
 cannot appear in a function declaration
Function declarations must appear before function definitions.
A function must begin with a label
 cannot appear before the memory model instruction
 must appear in a block
The high-order bits of a literal number in instruction <id> 
 must be 0 for a floating-point type, 
or 0 for an integer type with Signedness of 0, 
or sign extended when Signedness is 1
Expected scalar or 
 type as Result Type: 
Expected bool scalar type as Result Type: 
Expected vector sizes of Result Type and the operand to be equal: 
Expected operands to be scalar or vector float: 
Expected vector sizes of Result Type and the operands to be equal: 
Expected left and right operands to have the same type: 
Expected operand to be of Result Type: 
Expected both objects to be of Result Type: 
Expected vector sizes of Result Type and the operands to be
Expected both operands to have the same component bit width: 
Expected operand to be vector bool: 
Expected bool scalar or vector type as Result Type: 
Expected operand to be scalar or vector float: 
Expected both operands to be of Result Type: 
Using pointers with OpSelect requires capability 
Expected bool scalar or vector type as condition: 
Expected vector sizes of Result Type and the condition to be equal: 
Expected operands to be scalar or vector int: 
Cannot use a pointer in the PhysicalStorageBuffer storage class
Instruction cannot be used without a variable pointers capability
Result Type must be an integer scalar
Result Type must be OpTypeBool
The types of Operand 1 and Operand 2 must match
Operand type must be a pointer
Workgroup storage class pointer requires VariablePointers capability to be specified
' must be OpTypeCooperativeMatrixNV.
' must be OpTypeInt with width 32 and signedness 0.
Memory accesses with PhysicalStorageBufferEXT must use Aligned.
NonPrivatePointerKHR must be specified if MakePointerAvailableKHR is specified.
NonPrivatePointerKHR must be specified if 
MakePointerVisibleKHR is specified.
MakePointerAvailableKHR cannot be used with OpLoad.
MakePointerVisibleKHR cannot be used with OpStore.
NonPrivatePointerKHR requires a pointer in Uniform, 
Workgroup, CrossWorkgroup, Generic, Image or StorageBuffer 
OpLoad type for pointer <id> '
' does not match Pointer <id> '
8- or 16-bit loads must be a scalar, vector or matrix type
' must be OpTypePointer. Found Op
The result pointer storage class and base pointer storage class in 
 to index into a structure must be an OpConstant.
 reached non-composite type while indexes still remain to be traversed.
) does not match the type that results from indexing into the base <id> (Op
 instruction must be a pointer.
Generating variable pointers requires capability 
' must be a pointer to an OpTypeStruct.
The Struture's last member in 
' must be an OpTypeRuntimeArray.
' must be an the last member of the struct.
SpvOpCooperativeMatrixLoadNV Result Type <id> '
' is not a cooperative matrix type.
SpvOpCooperativeMatrixStoreNV Object type <id> '
 storage class for pointer type <id> '
' is not Workgroup or StorageBuffer.
's Type must be a scalar or vector type.
' must be a scalar integer type.
' must be a boolean constant instruction.
's type does not match Source <id> '
Target memory access must not include MakePointerVisibleKHR
Source memory access must not include MakePointerAvailableKHR
 with two memory access operands requires SPIR-V 1.4 or later
' cannot have the sign bit set to 1.
Cannot copy memory of objects containing 8- or 16-bit types
In the Vulkan environment, cannot store to Uniform Blocks
OpStore type for pointer <id> '
's type does not match Object <id> '
's layout does not match Object <id> '
8- or 16-bit stores must be a scalar, vector or matrix type
' is not a constant or module-scope variable.
Initializer type must match the type pointed to by the Result Type
If OpTypeBool is stored in conjunction with OpVariable, it 
can only be used with non-externally visible shader Storage 
Classes: Workgroup, CrossWorkgroup, Private, and Function
Invalid storage class for target environment
OpVariable storage class cannot be Generic
From SPIR-V spec, section 3.32.8 on OpVariable:\n
Its Storage Class operand must be the same as the Storage Class 
In Logical addressing, variables may not allocate a pointer 
In Logical addressing with variable pointers, variables 
that allocate pointers must be in Function or Private 
PushConstant OpVariable <id> '
Such variables must be typed as OpTypeStruct, 
UniformConstant OpVariable <id> '
Variables identified with the UniformConstant storage class 
are used only as handles to refer to opaque resources. Such 
variables must be typed as OpTypeImage, OpTypeSampler, 
OpTypeSampledImage, OpTypeAccelerationStructureNV, 
or an array of one of these types.
Variables identified with the Uniform storage class are 
used to access transparent buffer backed resources. Such 
variables must be typed as OpTypeStruct, or an array of 
StorageBuffer OpVariable <id> '
Variables identified with the StorageBuffer storage class are used to access transparent buffer backed resources. Such variables must be typed as OpTypeStruct, or an array of this type
', has a disallowed initializer & storage class 
Variable declarations that include initializers must have 
one of the following storage classes: Output, Private, or 
PhysicalStorageBufferEXT must not be used with OpVariable.
: expected AliasedPointerEXT or RestrictPointerEXT for 
PhysicalStorageBufferEXT pointer.
: can't specify both AliasedPointerEXT and 
', is attempting to create memory for an illegal type, 
OpTypeRuntimeArray.\nFor Vulkan OpTypeRuntimeArray can only 
appear as the final member of an OpTypeStruct, thus cannot 
be instantiated via OpVariable
For Vulkan with RuntimeDescriptorArrayEXT, a variable 
containing OpTypeRuntimeArray must have storage class of 
StorageBuffer, Uniform, or UniformConstant.
For Vulkan, an OpTypeStruct variable containing an 
OpTypeRuntimeArray must be decorated with Block if it 
has storage class StorageBuffer.
OpTypeRuntimeArray must be decorated with BufferBlock 
if it has storage class Uniform.
For Vulkan, OpTypeStruct variables containing 
OpTypeRuntimeArray must have storage class of 
For WebGPU, an OpTypeStruct variable containing an 
For WebGPU, OpTypeStruct variables containing 
Cannot allocate a variable containing a 16-bit type in 
Allocating a variable containing a 16-bit element in 
 storage class requires an additional capability
Cannot allocate a variable containing a 8-bit type in 
Allocating a variable containing a 8-bit element in 
Variables must have a function[7] storage class inside of a function
Variables can not have a function[7] storage class outside of a function
From WebGPU execution environment spec:\n
All variables in the following storage classes must have an 
initializer: Output, Private, or Function
OpTypeRuntimeArray.\nFor WebGPU OpTypeRuntimeArray can only 
Cooperative matrix types (or types containing them) can only be allocated 
in Function or Private storage classes or as function parameters
Invalid pointer storage class
The type in 
The Result Type of 
storage classes.
OpLoad Result Type <id> '
' is not defined.
OpLoad Pointer <id> '
' is not a logical pointer.
' is not a pointer type.
's type.
 do not match.
The number of indexes in 
The <id> passed to 
Index is out of bounds: 
 can not find index 
 into the structure <id> '
 result type (Op
The Base <id> '
' in 
Indexes passed to 
 must be of type integer.
The Struture's type in 
The array member in 
SpvOpCooperativeMatrixLoadNV
SpvOpCooperativeMatrixStoreNV
 type for pointer <id> '
Stride operand <id> '
Column Major operand <id> '
Target operand <id> '
Source operand <id> '
Size operand <id> '
' cannot be a constant zero.
' is not a pointer.
' cannot be a void pointer.
OpStore Pointer <id> '
' is not pointer type
' storage class is read-only
's type is void.
OpStore Object <id> '
' is not an object.
's layout.
OpVariable Initializer <id> '
operand of the result type.
storage classes
' has illegal type.\n
or an array of this type
Uniform OpVariable <id> '
OpVariable, <id> '
combination.\n
From 
 spec:\n
OpVariable 
StorageBuffer or Uniform.
OpVariable Result Type <id> '
', must have an initializer.\n
: expected Memory Semantics to be a 32-bit int
Memory Semantics ids must be OpConstant when Shader capability is present
Memory Semantics must be a constant instruction when CooperativeMatrixNV capability is present
For WebGPU, AcquireRelease must be set for Memory Semantics of OpControlBarrier.
For WebGPU, WorkgroupMemory must be set for Memory Semantics of OpControlBarrier.
For WebGPU only WorkgroupMemory and AcquireRelease may be set for Memory Semantics of OpControlBarrier.
For WebGPU, ImageMemory must be set for Memory Semantics of OpMemoryBarrier.
For WebGPU only ImageMemory may be set for Memory Semantics of OpMemoryBarrier.
For WebGPU Memory no bits may be set for Memory Semantics of OpAtomic* instructions.
: Memory Semantics can have at most one of the following bits set: Acquire, Release, AcquireRelease or SequentiallyConsistent
: Memory Semantics MakeAvailableKHR requires capability 
: Memory Semantics MakeVisibleKHR requires capability 
: Memory Semantics OutputMemoryKHR requires capability 
: Memory Semantics Volatile requires capability VulkanMemoryModelKHR
Memory Semantics Volatile can only be used with atomic instructions
: Memory Semantics UniformMemory requires capability Shader
: expected Memory Semantics to include a storage class
: MakeVisibleKHR Memory Semantics also requires either Acquire or AcquireRelease Memory Semantics
: MakeAvailableKHR Memory Semantics also requires either Release or AcquireRelease Memory Semantics
: Vulkan specification requires Memory Semantics to have one of the following bits set: Acquire, Release, AcquireRelease or SequentiallyConsistent
: expected Memory Semantics to include a Vulkan-supported storage class
Memory Semantics Acquire and AcquireRelease cannot be used with 
: Memory Semantics Release and AcquireRelease cannot be used for operand Unequal
Vulkan spec disallows OpAtomicLoad with Memory Semantics Release, AcquireRelease and SequentiallyConsistent
Vulkan spec disallows OpAtomicStore with Memory Semantics Acquire, AcquireRelease and SequentiallyConsistent
SequentiallyConsistent memory semantics cannot be used with the VulkanKHR memory model.
VulkanMemoryModelKHR
OpBeginInvocationInterlockEXT/OpEndInvocationInterlockEXT require a fragment shader interlock execution mode.
OpBeginInvocationInterlockEXT/OpEndInvocationInterlockEXT require Fragment execution model
OpDemoteToHelperInvocationEXT requires Fragment execution model
OpIsHelperInvocationEXT requires Fragment execution model
Cannot create undefined values with 8- or 16-bit types
Expected Value to be a vector of two components of unsigned integer or 64bit unsigned integer
OpUndef is disallowed
Addressing model must be Logical for WebGPU environment.
Memory model must be VulkanKHR for WebGPU environment.
Memory model must be OpenCL in the OpenCL environment.
Addressing model must be Physical32 or Physical64 
VulkanMemoryModelKHR capability must only be specified if the VulkanKHR memory model is used.
OpExecutionMode Entry Point <id> '
' is not the Entry Point operand of an OpEntryPoint.
OpExecutionModeId is only valid when the Mode operand is an execution mode that takes Extra Operands that are id operands.
For OpExecutionModeId all Extra Operand ids must be constant instructions.
OpExecutionMode is only valid when the Mode operand is an execution mode that takes no Extra Operands, or takes Extra Operands that are not id operands.
Execution mode can only be used with the Geometry execution model.
Execution mode can only be used with a Geometry or tessellation execution model.
Execution mode can only be used with a Kernel or GLCompute execution model.
In the Vulkan environment, the OriginLowerLeft execution mode must not be used.
In the Vulkan environment, the PixelCenterInteger execution mode must not be used.
Execution mode must be one of OriginUpperLeft, DepthReplacing, DepthGreater, DepthLess, DepthUnchanged, LocalSize, or LocalSizeHint for WebGPU environment.
Execution mode can only be used with the Geometry or MeshNV execution model.
Execution mode can only be used with a Geometry, tessellation or MeshNV execution model.
Execution mode can only be used with a Kernel, GLCompute, MeshNV, or TaskNV execution model.
Execution mode can only be used with a tessellation execution model.
Execution mode can only be used with the Fragment execution model.
Execution mode can only be used with the Kernel execution model.
Fragment execution model entry points can only specify one of OriginUpperLeft or OriginLowerLeft execution modes.
Fragment execution model entry points require either an OriginUpperLeft or OriginLowerLeft execution mode.
In the Vulkan environment, GLCompute execution model entry points require either the LocalSize execution mode or an object decorated with WorkgroupSize must be specified.
's function parameter count is not zero.
's function return type is not void.
Fragment execution model entry points can specify at most one of DepthGreater, DepthLess or DepthUnchanged execution modes.
Fragment execution model entry points can specify at most one fragment shader interlock execution mode.
Tessellation execution model entry points can specify at most one of SpacingEqual, SpacingFractionalOdd or SpacingFractionalEven execution modes.
Tessellation execution model entry points can specify at most one of Triangles, Quads or Isolines execution modes.
Tessellation execution model entry points can specify at most one of VertexOrderCw or VertexOrderCcw execution modes.
Geometry execution model entry points must specify exactly one of InputPoints, InputLines, InputLinesAdjacency, Triangles or InputTrianglesAdjacency execution modes.
Geometry execution model entry points must specify exactly one of OutputPoints, OutputLineStrip or OutputTriangleStrip execution modes.
Expected Result Type to be an unsigned integer type scalar.
Expected Value to be a vector of four components of integer type scalar
 instructions require Geometry execution model
: expected Stream to be int scalar
: expected Stream to be constant instruction
in Vulkan evironment, OpControlBarrier execution scope must be Subgroup for Fragment, Vertex, Geometry and TessellationEvaluation execution models
: expected Execution Scope to be a 32-bit int
Scope ids must be OpConstant when Shader capability is 
Scope ids must be constant or specialization constant when 
CooperativeMatrixNV capability is present
: in Vulkan environment Execution scope is limited to 
: in Vulkan environment Execution Scope is limited to 
: in WebGPU environment Execution Scope is limited to 
: Execution scope is limited to Subgroup or Workgroup
: expected Memory Scope to be a 32-bit int
: Memory Scope QueueFamilyKHR requires capability 
Use of device scope with VulkanKHR memory model requires the 
VulkanMemoryModelDeviceScopeKHR capability
: in Vulkan environment, Memory Scope cannot be CrossDevice
: in Vulkan 1.0 environment Memory Scope is limited to 
Device, Workgroup and Invocation
: in Vulkan 1.1 environment Memory Scope is limited to 
: in WebGPU environment Memory Scope is limited to 
Workgroup for OpControlBarrier
QueueFamilyKHR for OpAtomic* operations
Workgroup, Invocation, and QueueFamilyKHR
Workgroup and Subgroup
Invalid scope value:\n 
Workgroup for OpMemoryBarrier
Invalid use of 8- or 16-bit result
Duplicate non-aggregate type declarations are not allowed. Opcode: 
Matrix types can only be parameterized with floating-point types.
Matrix types can only be parameterized as having only 2, 3, or 4 columns.
Columns in a matrix must be of type vector.
Pointer type in OpTypeForwardPointer is not a pointer type.
Storage class in OpTypeForwardPointer does not match the 
Forward pointers must point to a structure
Using a 16-bit floating point 
type requires the Float16 or Float16Buffer capability, or an extension that explicitly enables 16-bit floating point.
Using a 64-bit floating point 
type requires the Float64 capability.
Using an 8-bit integer type requires the Int8 capability, or an extension that explicitly enables 8-bit integers.
Using a 16-bit integer type requires the Int16 capability, or an extension that explicitly enables 16-bit integers.
Using a 64-bit integer type requires the Int64 capability.
OpTypeInt has invalid signedness:
The Signedness in OpTypeInt must always be 0 when Kernel capability is used.
 requires the Vector16 capability
Illegal number of components (
OpTypeVector Component Type <id> '
OpTypeRuntimeArray Element Type <id> '
OpTypeFunction Parameter Type <id> '
OpTypeFunction may not take more than 
 arguments. OpTypeFunction <id> '
OpTypeFunction Return Type <id> '
Invalid use of function type result id 
OpTypeCooperativeMatrixNV Component Type <id> '
' is not a scalar numerical type.
OpTypeCooperativeMatrixNV Scope <id> '
' is not a constant instruction with scalar integer type.
OpTypeCooperativeMatrixNV Rows <id> '
OpTypeCooperativeMatrixNV Cols <id> '
OpTypeArray Element Type <id> '
' default value must be at least 1.
' is not a scalar constant type.
' is not a constant integer type.
Structure members may not be self references
Structures cannot contain a void type.
 contains members with BuiltIn decoration. Therefore this 
structure may not be contained as a member of another 
, OpTypeRuntimeArray must only be used for the last member of an OpTypeStruct
When BuiltIn decoration is applied to a structure-type member, 
all members of that structure type must also be decorated with 
BuiltIn (No allowed mixing of built-in variables and 
non-built-in variables within a single structure). Structure id 
OpTypeStruct Member Type <id> '
rules: A Block or BufferBlock cannot be nested within another Block or BufferBlock. 
, OpTypeStruct must not contain an opaque type.
 id: 
pointer definition.
Invalid number of bits (
) used for OpTypeFloat.
) used for OpTypeInt.
Having 
 components for 
) for 
' is not a scalar type.
' is a void type.
' is not a type.
' is not valid in 
 environments.
' cannot be OpTypeVoid.
' has 
 arguments.
OpTypeArray Length <id> '
structure 
type. Structure <id> 
 contains structure <id> 
OpTypePointer Type <id> '
%s: __position (which is %zu) >= _Nb (which is %zu)
bitset::test
Other warnings have been suppressed.\n
Expected scopes of Matrix and Result Type to be 
Expected rows of Matrix type and Result Type to be 
Expected columns of Matrix type and Result Type to be 
Expected cooperative matrix types
The given text is a nullptr
Unsupported 
-bit integer literals
Integer 
 does not fit in a 
abcdef
ABCDEF
-bit float literals
The expected type is not a integer type
Cannot put a negative number in an unsigned literal
Invalid signed integer literal: 
Invalid unsigned integer literal: 
The expected type is not a float type
Invalid 16-bit float literal: 
Invalid 32-bit float literal: 
Invalid 64-bit float literal: 
The expected type is not a integer or float type
: truncated 
: missing 
 starting at word 
 operand at word offset 
Type Id 
 is not a type
 is not a scalar numeric type
Missing module.
 words instead of 
Invalid SPIR-V magic number '
Invalid opcode: 
Invalid instruction Op
Error: Type Id is 0
Error: Result Id is 0
 is defined more than once
OpExtInst set Id 
 is a type, not a value
 is not a scalar integer
 words: 
 words long
 has invalid mask component 
Invalid word count: Op
 says it has 
 words, but found 
 words instead.
 has no type
End of input reached while decoding Op
Module has incomplete header: only 
Internal error: unhandled header parse failure
Invalid instruction word count: 
: expected no more operands after 
 words, but stated word count is 
 does not reference an OpExtInstImport result Id
Invalid extended instruction number: 
Invalid OpSwitch: selector id 
Literal string is longer than 
Internal error: Unhandled operand type: 
: expected more operands after 
SPV_GOOGLE_decorate_string
SPV_GOOGLE_user_type
SPV_INTEL_media_block_io
SPV_INTEL_subgroups
SPV_KHR_float_controls
SPV_KHR_variable_pointers
Geometry
Tessellation
Addresses
Linkage
Vector16
Float16Buffer
Float64
Int64Atomics
ImageBasic
ImageReadWrite
ImageMipmap
Pipes
DeviceEnqueue
LiteralSampler
AtomicStorage
TessellationPointSize
GeometryPointSize
ImageGatherExtended
StorageImageMultisample
ImageCubeArray
SampleRateShading
ImageRect
SampledRect
GenericPointer
InputAttachment
SparseResidency
MinLod
Sampled1D
Image1D
SampledCubeArray
SampledBuffer
ImageBuffer
ImageMSArray
StorageImageExtendedFormats
ImageQuery
DerivativeControl
InterpolationFunction
TransformFeedback
GeometryStreams
StorageImageReadWithoutFormat
MultiViewport
SubgroupDispatch
GroupNonUniform
GroupNonUniformVote
GroupNonUniformArithmetic
GroupNonUniformClustered
GroupNonUniformQuad
ShaderLayer
ShaderViewportIndex
DrawParameters
SubgroupVoteKHR
StorageBuffer16BitAccess
StoragePushConstant16
StorageInputOutput16
DeviceGroup
MultiView
VariablePointersStorageBuffer
VariablePointers
AtomicStorageOps
SampleMaskPostDepthCoverage
StorageBuffer8BitAccess
StoragePushConstant8
DenormPreserve
DenormFlushToZero
SignedZeroInfNanPreserve
RoundingModeRTE
RoundingModeRTZ
Float16ImageAMD
ImageGatherBiasLodAMD
FragmentMaskAMD
StencilExportEXT
ImageReadWriteLodAMD
ShaderClockKHR
SampleMaskOverrideCoverageNV
GeometryShaderPassthroughNV
ShaderViewportIndexLayerEXT
ShaderViewportMaskNV
ShaderStereoViewNV
PerViewAttributesNV
FragmentFullyCoveredEXT
MeshShadingNV
ImageFootprintNV
FragmentBarycentricNV
ComputeDerivativeGroupQuadsNV
FragmentDensityEXT
GroupNonUniformPartitionedNV
ShaderNonUniform
RuntimeDescriptorArray
RayTracingNV
VulkanMemoryModel
VulkanMemoryModelDeviceScope
ShaderSMBuiltinsNV
SubgroupBufferBlockIOINTEL
SubgroupImageBlockIOINTEL
IntegerFunctions2INTEL
SPV_INTEL_device_side_avc_motion_estimation
SPV_INTEL_shader_integer_functions2
SPV_KHR_no_integer_wrap_decoration
SPV_VALIDATOR_ignore_type_decl_unique
UniformBufferArrayDynamicIndexing
SampledImageArrayDynamicIndexing
StorageBufferArrayDynamicIndexing
StorageImageArrayDynamicIndexing
StorageImageWriteWithoutFormat
GroupNonUniformShuffleRelative
UniformAndStorageBuffer16BitAccess
UniformAndStorageBuffer8BitAccess
InputAttachmentArrayDynamicIndexing
UniformTexelBufferArrayDynamicIndexing
StorageTexelBufferArrayDynamicIndexing
UniformBufferArrayNonUniformIndexing
SampledImageArrayNonUniformIndexing
StorageBufferArrayNonUniformIndexing
StorageImageArrayNonUniformIndexing
InputAttachmentArrayNonUniformIndexing
UniformTexelBufferArrayNonUniformIndexing
StorageTexelBufferArrayNonUniformIndexing
PhysicalStorageBufferAddresses
ComputeDerivativeGroupLinearNV
FragmentShaderSampleInterlockEXT
FragmentShaderShadingRateInterlockEXT
FragmentShaderPixelInterlockEXT
SubgroupImageMediaBlockIOINTEL
SubgroupAvcMotionEstimationINTEL
SubgroupAvcMotionEstimationIntraINTEL
SubgroupAvcMotionEstimationChromaINTEL
OpenCL.std
DebugInfo
FMin3AMD
UMin3AMD
SMin3AMD
FMax3AMD
UMax3AMD
SMax3AMD
FMid3AMD
UMid3AMD
SMid3AMD
InterpolateAtVertexAMD
SwizzleInvocationsAMD
SwizzleInvocationsMaskedAMD
WriteInvocationAMD
MbcntAMD
CubeFaceIndexAMD
CubeFaceCoordAMD
TimeAMD
acospi
asinpi
atanpi
atan2pi
cbrt
copysign
erfc
expm1
fabs
fdim
fmax
fmin
hypot
ilogb
lgamma
lgamma_r
log1p
maxmag
minmag
nextafter
pown
remainder
remquo
rootn
tgamma
half_cos
half_divide
half_exp
half_exp2
half_exp10
half_log
half_log2
half_log10
half_powr
half_recip
half_rsqrt
half_sin
half_sqrt
half_tan
native_cos
native_divide
native_exp
native_exp2
native_exp10
native_log
native_log2
native_log10
native_powr
native_recip
native_rsqrt
native_sin
native_sqrt
native_tan
fclamp
fmax_common
fmin_common
fast_distance
fast_length
fast_normalize
s_abs
s_abs_diff
s_add_sat
u_add_sat
s_hadd
u_hadd
s_rhadd
u_rhadd
s_clamp
u_clamp
s_mad_hi
u_mad_sat
s_mad_sat
s_max
u_max
s_min
u_min
s_mul_hi
rotate
s_sub_sat
u_sub_sat
u_upsample
s_upsample
popcount
s_mad24
u_mad24
s_mul24
u_mul24
vloadn
vstoren
vload_half
vload_halfn
vstore_half
vstore_half_r
vstore_halfn
vstore_halfn_r
vloada_halfn
vstorea_halfn
vstorea_halfn_r
shuffle2
printf
prefetch
bitselect
u_abs
u_abs_diff
u_mul_hi
u_mad_hi
Round
RoundEven
Trunc
FAbs
SAbs
FSign
SSign
Ceil
Fract
Radians
Degrees
Asin
Acos
Atan
Sinh
Cosh
Tanh
Asinh
Acosh
Atanh
Atan2
Exp2
InverseSqrt
Determinant
MatrixInverse
Modf
ModfStruct
FClamp
UClamp
SClamp
FMix
IMix
SmoothStep
Frexp
FrexpStruct
Ldexp
PackSnorm2x16
PackUnorm2x16
PackHalf2x16
UnpackSnorm2x16
UnpackUnorm2x16
UnpackHalf2x16
Cross
Normalize
FaceForward
Reflect
Refract
FindILsb
FindSMsb
FindUMsb
InterpolateAtCentroid
InterpolateAtSample
InterpolateAtOffset
NMin
NMax
NClamp
DebugInfoNone
DebugCompilationUnit
DebugTypeBasic
DebugTypePointer
DebugTypeQualifier
DebugTypeArray
DebugTypeVector
DebugTypedef
DebugTypeFunction
DebugTypeEnum
DebugTypeComposite
DebugTypeMember
DebugTypeInheritance
DebugTypePtrToMember
DebugTypeTemplate
DebugTypeTemplateParameter
DebugGlobalVariable
DebugFunctionDeclaration
DebugFunction
DebugLexicalBlock
DebugScope
DebugNoScope
DebugInlinedAt
DebugLocalVariable
DebugInlinedVariable
DebugDeclare
DebugValue
DebugOperation
DebugExpression
DebugMacroDef
DebugMacroUndef
DebugTypeTemplateTemplateParameter
DebugTypeTemplateParameterPack
DebugLexicalBlockDiscriminator
ERROR_not_op_extension
type ID
result ID
literal number
extension instruction number
OpSpecConstantOp opcode
literal string
source language
execution model
addressing model
memory model
execution mode
dimensionality
sampler addressing mode
sampler filter mode
image format
floating-point fast math mode
floating-point rounding mode
linkage type
access qualifier
function parameter attribute
decoration
built-in
selection control
loop control
function control
memory semantics ID
memory access
scope ID
group operation
kernel enqeue flags
kernel profiling info
context-insensitive value
debug info flags
debug base type encoding
debug composite type
debug type qualifier
debug operation
image channel order
image channel data type
Deref
Plus
Minus
PlusUconst
BitPiece
Xderef
StackValue
Constu
ConstType
VolatileType
RestrictType
Structure
Union
Unspecified
Address
Boolean
Signed
SignedChar
Unsigned
UnsignedChar
FlagIsProtected
FlagIsPrivate
FlagIsPublic
FlagIsLocal
FlagIsDefinition
FlagFwdDecl
FlagArtificial
FlagExplicit
FlagPrototyped
FlagObjectPointer
FlagStaticMember
FlagIndirectVariable
FlagLValueReference
FlagRValueReference
FlagIsOptimized
StorageUniformBufferBlock16
StorageUniform16
ShaderViewportIndexLayerNV
ShadingRateNV
ShaderNonUniformEXT
RuntimeDescriptorArrayEXT
NoWait
WaitKernel
WaitWorkGroup
ClusteredReduce
PartitionedReduceNV
PartitionedInclusiveScanNV
PartitionedExclusiveScanNV
CrossDevice
QueueFamily
QueueFamilyKHR
PrimitiveId
NumWorkgroups
GlobalInvocationId
DrawIndex
BaryCoordNoPerspCentroidAMD
FragStencilRefEXT
SpecId
RestrictPointer
AliasedPointer
CounterBuffer
UserSemantic
UserTypeGOOGLE
Zext
Sext
ByVal
Sret
NoAlias
NoCapture
NoWrite
NoReadWrite
ReadOnly
WriteOnly
Export
SnormInt8
SnormInt16
UnormInt8
UnormInt16
UnormShort565
UnormShort555
UnormInt101010
SignedInt8
SignedInt16
SignedInt32
UnsignedInt8
UnsignedInt16
UnsignedInt32
HalfFloat
UnormInt24
UnormInt101010_2
ARGB
Intensity
Luminance
DepthStencil
sRGBx
sRGBA
sBGRA
ABGR
Rgba32f
Rgba16f
R32f
Rgba8
Rgba8Snorm
Rg32f
Rg16f
R11fG11fB10f
R16f
Rgba16
Rgb10A2
Rg16
Rgba16Snorm
Rg16Snorm
Rg8Snorm
R16Snorm
R8Snorm
Rgba32i
Rgba16i
Rgba8i
R32i
Rg32i
Rg16i
Rg8i
R16i
Rgba32ui
Rgba16ui
Rgba8ui
R32ui
Rgb10a2ui
Rg32ui
Rg16ui
Rg8ui
R16ui
R8ui
Nearest
ClampToEdge
Repeat
RepeatMirrored
SubpassData
UniformConstant
CrossWorkgroup
IncomingCallableDataNV
HitAttributeNV
IncomingRayPayloadNV
ShaderRecordBufferNV
PhysicalStorageBuffer
PhysicalStorageBufferEXT
SpacingEqual
SpacingFractionalEven
SpacingFractionalOdd
VertexOrderCw
VertexOrderCcw
PixelCenterInteger
OriginUpperLeft
OriginLowerLeft
EarlyFragmentTests
PointMode
DepthReplacing
DepthGreater
DepthLess
DepthUnchanged
LocalSize
LocalSizeHint
InputPoints
InputLines
InputLinesAdjacency
Triangles
InputTrianglesAdjacency
Quads
Isolines
OutputVertices
OutputPoints
OutputLineStrip
OutputTriangleStrip
VecTypeHint
ContractionOff
Initializer
Finalizer
SubgroupsPerWorkgroup
SubgroupsPerWorkgroupId
LocalSizeId
LocalSizeHintId
StencilRefReplacingEXT
OutputLinesNV
DerivativeGroupLinearNV
OutputTrianglesNV
PixelInterlockOrderedEXT
PixelInterlockUnorderedEXT
SampleInterlockOrderedEXT
SampleInterlockUnorderedEXT
GLSL450
VulkanKHR
Physical32
Physical64
PhysicalStorageBuffer64
PhysicalStorageBuffer64EXT
TessellationControl
TessellationEvaluation
GLCompute
MeshNV
RayGenerationNV
AnyHitNV
ClosestHitNV
MissNV
ESSL
GLSL
OpenCL_C
OpenCL_CPP
HLSL
CmdExecTime
Nontemporal
MakePointerAvailable
MakePointerAvailableKHR
MakePointerVisible
MakePointerVisibleKHR
NonPrivatePointer
NonPrivatePointerKHR
SequentiallyConsistent
UniformMemory
SubgroupMemory
CrossWorkgroupMemory
AtomicCounterMemory
OutputMemory
OutputMemoryKHR
MakeAvailableKHR
MakeVisibleKHR
DontInline
Pure
Const
DependencyInfinite
DependencyLength
MinIterations
MaxIterations
IterationMultiple
PeelCount
PartialCount
NotNaN
NotInf
AllowRecip
Fast
ConstOffset
ConstOffsets
MakeTexelAvailable
MakeTexelAvailableKHR
MakeTexelVisible
MakeTexelVisibleKHR
NonPrivateTexel
NonPrivateTexelKHR
VolatileTexel
VolatileTexelKHR
SignExtend
ZeroExtend
possibly multi-word literal integer
possibly multi-word literal number
InputAttachmentArrayDynamicIndexingEXT
UniformTexelBufferArrayDynamicIndexingEXT
StorageTexelBufferArrayDynamicIndexingEXT
UniformBufferArrayNonUniformIndexingEXT
SampledImageArrayNonUniformIndexingEXT
StorageBufferArrayNonUniformIndexingEXT
StorageImageArrayNonUniformIndexingEXT
InputAttachmentArrayNonUniformIndexingEXT
UniformTexelBufferArrayNonUniformIndexingEXT
StorageTexelBufferArrayNonUniformIndexingEXT
VulkanMemoryModelDeviceScopeKHR
PhysicalStorageBufferAddressesEXT
ShadingRateInterlockOrderedEXT
ShadingRateInterlockUnorderedEXT
scalar-replacement=
cannot compose log message
strip-atomic-counter-memory
strip-debug
strip-reflect
set-spec-const-default-value
if-conversion
freeze-spec-const
inline-entry-points-opaque
combine-access-chains
convert-local-access-chains
descriptor-scalar-replacement
propagate-line-info
eliminate-redundant-line-info
eliminate-insert-extract
eliminate-local-single-block
eliminate-local-single-store
merge-blocks
merge-return
eliminate-dead-branches
eliminate-dead-functions
eliminate-local-multi-store
eliminate-dead-const
eliminate-dead-inserts
eliminate-dead-variables
eliminate-dead-members
fold-spec-const-op-composite
loop-unswitch
strength-reduction
unify-const
flatten-decorations
compact-ids
cfg-cleanup
local-redundancy-elimination
loop-invariant-code-motion
reduce-load-size
private-to-local
remove-duplicates
workaround-1209
replace-invalid-opcode
inst-bindless-check
inst-desc-idx-check
inst-buff-addr-check
convert-relaxed-to-half
relax-float-ops
simplify-instructions
ssa-rewrite
copy-propagate-arrays
loop-fission
loop-fusion
loop-unroll
upgrade-memory-model
vector-dce
loop-unroll-partial
loop-peeling
loop-peeling-threshold
code-sink
fix-storage-class
legalize-hlsl
generate-webgpu-initializers
legalize-vector-shuffle
split-invalid-unreachable
graphics-robust-access
wrap-opkill
amd-ext-to-khr
%s is not a valid flag.  Flag passes should have the form '--pass_name[=pass_args]'. Special flag names also accepted: -O and -Os.
Invalid argument for --set-spec-const-default-value: %s
Invalid spec constant value string '%s'. Expected a string of <spec id>:<default value> pairs.
inline-entry-points-exhaustive
eliminate-dead-code-aggressive
--scalar-replacement must have no arguments or a non-negative integer argument
--loop-fission must have a positive integer argument
--loop-fusion must have a positive integer argument
--loop-unroll-partial must have a positive integer argument
--loop-peeling-threshold must have a positive integer argument
decompose-initialized-variables
Unknown flag '--%s'. Use --help for a list of valid flags
ID overflow. Try running compact-ids.
; IR before pass 
Validation failed after pass 
; IR after last pass
propagate-lines
?convert-to-half-pass
Removing 
 instruction because of incompatible execution model.
  [INCOMPLETE]
  [COMPLETE]
 = Phi[%
, BB %
, bb(%
  [COPY OF 
\nLoad replacement table\n
 -> %
\nPhi candidates:\n
\tBB %
named_barrier
pipe_storage
reserve_id
device_event
unimplemented: unhandled type
/data/data/source2_main/src/thirdparty/glslang/External/spirv-tools/source/opt/type_manager.cpp
unimplemented: OpMemberDecorate non-struct type
pipe(
opaque('
sampled_image(
forward_pointer(
, id(
), words(
) -> 
map::at
Basic block #
Variable cannot be replaced: invalid instruction
Variable cannot be replaced: invalid index
"];\n
digraph {\n
Function #
Member index 
\nin access chain: 
Can only process Shader modules
Addressing model must be Logical.  Found 
Can't process modules with VariablePointers capability
Can't process modules with VariablePointersStorageBuffer capability
Can't process modules with RuntimeDescriptorArrayEXT capability
Unhandled access chain in logical addressing mode passes through 
Can't handle indices wider than 64 bits, found constant index with 
 is out of bounds for struct type: 
 Unhandled pointee type for access chain 
Member index into struct is not a constant integer: 
GLSL.std.450
inst-bindless-check-pass
Instruction #
Predecessors for 
 are different:\n
Real:
Recorded:
<instruction>
function inside function
OpLabel outside function
OpLabel inside basic block
OpFunctionEnd without corresponding OpFunction
OpFunctionEnd inside basic block
terminator instruction outside function
terminator instruction outside basic block
Non-OpFunctionParameter (opcode: %d) found inside function but outside basic block
Unhandled inst type (opcode: %d) found outside function definition.
Module contains unreachable blocks during merge return.  Run dead branch elimination before merge return.
Varying
Interesting
Not interesting
RecurrentAddExpr
Negative
Multiply
Value Unknown
Can not compute
 [label="
\nwith value: 
Performing ZIVTest
ZIVTest found EQ dependence.
ZIVTest found independence.
Performing StrongSIVTest.
\n\tcoefficient value: 
StrongSIVTest found bounds.
\n\tdistance: 
\n\tupper bound value: 
\n\tdistance value: 
Found a ZIV subscript pair
Found a SIV subscript pair.
Found a MIV subscript pair.
Performing SymbolicStrongSIVTest.
SymbolicStrongSIVTest proved independence through loop bounds.
SymbolicStrongSIVTest was unable to determine any dependence information.
StrongSIVTest could not collect the constant terms of either source or destination so will exit.
StrongSIVTest found delta value and coefficient value as constants with values:\n\tdelta value: 
StrongSIVTest proved independence through distance not being an integer.
StrongSIV test found distance as 
StrongSIVTest could not produce a distance. Must exit.
StrongSIVTest found upper_bound - lower_bound as a constant with value 
StrongSIVTest proved independence through distance escaping the loop bounds.
StrongSIVTest was unable to gather lower and upper bounds.
StrongSIVTest could not prove independence. Gathering direction information.
StrongSIVTest found symbolics. Will attempt SymbolicStrongSIVTest.
StrongSIVTest could not simplify source and destination to SERecurrentNodes so will exit.
Performing WeakZeroSourceSIVTest.
WeakZeroSourceSIVTest folding delta and coefficient to constants.
WeakZeroSourceSIVTest proved independence through distance not being an integer.
WeakZeroSourceSIVTest calculated distance with the following values\n\tdelta value: 
WeakZeroSourceSIVTest was unable to fold delta and coefficient to constants.
WeakZeroSourceSIVTest found bounds as SEConstantNodes.
WeakZeroSourceSIVTest proved independence through distance escaping the loop bounds.
Bound values were as follow\n\tlower bound value: 
WeakZeroSourceSIVTest was unable to find lower and upper bound as SEConstantNodes.
WeakZeroSourceSIVTest built first_trip_SENode.
WeakZeroSourceSIVTest has found first_trip_SENode as an SEConstantNode with value: 
WeakZeroSourceSIVTest has found peeling first iteration will break dependency
WeakZeroSourceSIVTest was unable to build first_trip_SENode
WeakZeroSourceSIVTest built final_trip_SENode.
WeakZeroSourceSIVTest has found final_trip_SENode as an SEConstantNode with value: 
WeakZeroSourceSIVTest has found peeling final iteration will break dependency
WeakZeroSourceSIVTest was unable to build final_trip_SENode
WeakZeroSourceSIVTest was unable to determine any dependence information.
Performing WeakZeroDestinationSIVTest.
WeakZeroDestinationSIVTest folding delta and coefficient to constants.
WeakZeroDestinationSIVTest proved independence through distance not being an integer.
WeakZeroDestinationSIVTest calculated distance with the following values\n\tdelta value: 
WeakZeroDestinationSIVTest was unable to fold delta and coefficient to constants.
WeakZeroDestinationSIVTest found bounds as SEConstantNodes.
WeakZeroDestinationSIVTest proved independence through distance escaping the loop bounds.
Bound values were as follows\n\tlower bound value: 
WeakZeroDestinationSIVTest was unable to find lower and upper bound as SEConstantNodes.
WeakZeroDestinationSIVTest built first_trip_SENode.
WeakZeroDestinationSIVTest has found first_trip_SENode as an SEConstantNode with value: 
WeakZeroDestinationSIVTest has found peeling first iteration will break dependency
WeakZeroDestinationSIVTest was unable to build first_trip_SENode
WeakZeroDestinationSIVTest built final_trip_SENode.
WeakZeroDestinationSIVTest has found final_trip_SENode as an SEConstantNode with value: 
WeakZeroDestinationSIVTest has found peeling final iteration will break dependency
WeakZeroDestinationSIVTest was unable to build final_trip_SENode
WeakZeroDestinationSIVTest was unable to determine any dependence information.
Performing WeakCrossingSIVTest.
WeakCrossingSIVTest folding offset_delta and coefficient to constants.
WeakCrossingSIVTest proved independence through distance escaping the loop bounds.
WeakCrossingSIVTest found EQ dependence.
WeakCrossingSIVTest was unable to fold offset_delta and coefficient to constants.
WeakCrossingSIVTest was unable to determine any dependence information.
WeakCrossingSIVTest found source or destination != SERecurrentNode. Exiting
SIVTest could not find a DistanceEntry for subscript_pair. Exiting
Found source has no induction variable.
Proved independence with WeakZeroSourceSIVTest.
Found destination has no induction variable.
Proved independence with WeakZeroDestinationSIVTest.
Found source and destination share coefficient.
Proved independence with StrongSIVTest
Found source coefficient = -destination coefficient.
Proved independence with WeakCrossingSIVTest
Found source and destination have 1 induction variable.
Proved independence through different arrays.
Couldn't prove independence.\nAll possible direction information has been collected in the input DistanceVector.
GetDependence found an unsupported loop form. Assuming <=> for loop.
Proved independence with ZIVTest.
Proved independence with SIVTest.
Proved independence with the GCD test.
GetDependence found source_node || destination_node as CanNotCompute. Abandoning evaluation for this subscript.
IsProvablyOutsideOfLoopBounds could not reduce coefficient to a SEConstantNode so must exit.
IsProvablyOutsideOfLoopBounds could not get both the lower and upper bounds so must exit.
IsProvablyOutsideOfLoopBounds found coefficient >= 0.\nUsing bounds as upper - lower.
IsProvablyOutsideOfLoopBounds found coefficient < 0.\nUsing bounds as lower - upper.
IsProvablyOutsideOfLoopBounds found distance - bounds as a SEConstantNode with value 
IsProvablyOutsideOfLoopBounds found distance escaped the loop bounds.
GetLoopForSubscriptPair found loops.size() != 1.
%016lx
Shader module
Pipeline layout
Descriptor set layout
Render pass
 (pNext->sType chain: [
Fossilize ERROR: Error: %s\n
application
hash
Immutable sampler
descriptorCount
descriptorType
stageFlags
finalLayout
initialLayout
loadOp
storeOp
stencilLoadOp
stencilStoreOp
samples
dependencyFlags
dstAccessMask
srcAccessMask
dstStageMask
srcStageMask
srcSubpass
dstSubpass
constantID
inputRate
depthBoundsTestEnable
depthCompareOp
depthTestEnable
depthWriteEnable
minDepthBounds
maxDepthBounds
stencilTestEnable
front
compareMask
compareOp
depthFailOp
passOp
failOp
writeMask
primitiveRestartEnable
blendEnable
colorWriteMask
alphaBlendOp
colorBlendOp
srcColorBlendFactor
dstColorBlendFactor
srcAlphaBlendFactor
dstAlphaBlendFactor
minDepth
maxDepth
domainOrigin
depthClipEnable
rasterizationStream
Compute pipeline
Graphics pipeline
apiVersion
robustBufferAccess
applicationName
engineName
applicationVersion
engineVersion
pipelineBindPoint
depthStencilAttachment
resolveAttachments
inputAttachments
colorAttachments
preserveAttachments
dataSize
mapEntries
logicOp
logicOpEnable
blendConstants
attachments
alphaToCoverageEnable
alphaToOneEnable
minSampleShading
sampleMask
sampleShadingEnable
rasterizationSamples
dynamicState
scissorCount
scissors
viewportCount
viewports
vertexBindingDivisorCount
vertexBindingDivisors
divisor
attributes
pNext
cullMode
depthBiasClamp
depthBiasConstantFactor
depthBiasSlopeFactor
lineWidth
rasterizerDiscardEnable
depthBiasEnable
depthClampEnable
polygonMode
frontFace
patchControlPoints
codeSize
varintOffset
varintSize
setLayouts
addressModeU
addressModeV
addressModeW
anisotropyEnable
borderColor
compareEnable
magFilter
minFilter
maxAnisotropy
mipmapMode
maxLod
minLod
mipLodBias
unnormalizedCoordinates
dependencies
subpasses
basePipelineHandle
basePipelineIndex
specializationInfo
renderPass
tessellationState
multisampleState
vertexInputState
rasterizationState
inputAssemblyState
colorBlendState
viewportState
depthStencilState
stages
applicationInfo
physicalDeviceFeatures
pipelineLayouts
shaderModules
renderPasses
computePipelines
graphicsPipelines
link
Base pipeline
Fossilize ERROR: %s handle 0x%016lx is not registered. It has either not been recorded, or it failed to be recorded earlier.\n
Fossilize ERROR: Cannot find sampler in hashmap.\n
Fossilize ERROR: Cannot find descriptor set layout in hashmap.\n
Fossilize ERROR: Cannot find pipeline layout in hashmap.\n
Fossilize ERROR: Cannot find shader module in hashmap.\n
Fossilize ERROR: Cannot find render pass in hashmap.\n
Unsupported pNext found, cannot hash.
Fossilize ERROR: Referenced %s %016lx, but it does not exist.\n
pNext in VkApplicationInfo not supported.
Fossilize ERROR: Cannot copy unknown pNext sType: %d.\n
Fossilize ERROR: Base pipeline index is out of range.\n
pNext in VkPipelineColorBlendStateCreateInfo not supported.
pNext in VkPipelineMultisampleStateCreateInfo not supported.
pNext in VkPipelineViewportStateCreateInfo not supported.
pNext in VkPipelineInputAssemblyStateCreateInfo not supported.
pNext in VkPipelineDepthStencilStateCreateInfo not supported.
pNext in VkPipelineDynamicStateCreateInfo not supported.
pNext in VkPipelineShaderStageCreateInfo not supported.
Fossilize ERROR: Cannot find graphics pipeline in hashmap.\n
Fossilize ERROR: Cannot find compute pipeline in hashmap.\n
Fossilize ERROR: Failed to parse pNext chain for sType: %d\n
Fossilize ERROR: Binary varint buffer overflows payload.\n
Fossilize ERROR: Invalid varint format.\n
Fossilize ERROR: Failed to create shader module.\n
Fossilize ERROR: Failed to create pipeline layout.\n
Fossilize ERROR: Failed to create descriptor set layout.\n
Fossilize ERROR: Failed to create sampler.\n
Fossilize ERROR: Failed to create render pass.\n
Unsupported pNext found, cannot hash sType.
Fossilize ERROR: Failed to prepare database, will not dump data to database.\n
Fossilize ERROR: Failed to serialize application info.\n
pNext in VkSamplerCreateInfo not supported.
pNext in VkDescriptorSetLayoutCreateInfo not supported.
pNext in VkPipelineLayoutCreateInfo not supported.
pNext in VkGraphicsPipelineCreateInfo not supported.
pNext in VkComputePipelineCreateInfo not supported.
pNext in VkRenderPassCreateInfo not supported.
pNext in VkShaderModuleCreateInfo not supported.
Fossilize ERROR: Got parse error: %d\n
Fossilize ERROR: JSON version mismatches.
Fossilize ERROR: Failed to create compute pipeline.\n
Fossilize ERROR: Failed to create graphics pipeline.
St11_Mutex_baseILN9__gnu_cxx12_Lock_policyE2EE
St16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE
NSt6thread10_Impl_baseE
St19_Sp_make_shared_tag
vH7B
W4vC
9Y>)F$
raB3G
)c=H
]rHa
O8Mr
bnMG
.wN\f9
[*QmU
mr"iR
R$N(
>S\f}W
-sSO\
T%L9
hGT.
B}T}
=@[V
!a9X
X5AHx
%4xY
Z~$|7
+\0I
2a\|
\ysK
|M$D
pH_r
(:W"
s\ax}?
pc2g
@BXV
tC7Ddx
EydV
d6\f6
eax~Z
5h\r:
ekhHD
@iZb
k0V(
k*do^
k5=\v6~
:V!2m
RJqn
bzo=
$qE}
XqkY
r\v_|s
quAt
Jugm
~B v
STv/N
_w&2
xg^Jp5|
/L\rry=
yMzw\n
;\tFzo
{zel#|67
P/};
c}\n=!
[@JO
nQ:B
Fossilize ERROR: Member not found.\n
Fossilize ERROR: Failed to parse ApplicationInfoFilter, letting recording go through.\n
Fossilize INFO: pApplicationName %s is blacklisted for recording. Skipping.\n
Fossilize INFO: pEngineName %s is blacklisted for recording. Skipping.\n
Fossilize INFO: applicationVersion %u is too low for pApplicationName %s. Skipping.\n
Fossilize INFO: apiVersion %u is too low for pApplicationName %s. Skipping.\n
Fossilize INFO: engineVersion %u is too low for pEngineName %s. Skipping.\n
Fossilize INFO: apiVersion %u is too low for pEngineName %s. Skipping.\n
Fossilize ERROR: Not an object.\n
Fossilize ERROR: Not an array.\n
Fossilize ERROR: Not a string.\n
FossilizeApplicationInfoFilter
NSt13__future_base7_ResultIvEE
%02x.%016lx.json
.foz
%x.%lx.json
%0*x
Fossilize ERROR: Failed to write serialized state to disk (%s).\n
Fossilize ERROR: Failed to write serialized state to disk.\n
Fossilize ERROR: Failed to open file: %s\n
Fossilize ERROR: Failed to seek in file: %s\n
Fossilize ERROR: CRC mismatch!\n
Fossilize ERROR: Failed to finalize archive.\n
Fossilize ERROR: mz_zip_end failed!\n
Fossilize ERROR: Failed to extract blob.\n
Fossilize ERROR: Failed to add blob to cache.\n
Fossilize ERROR: Failed to initialize ZIP writer from reader.\n
Fossilize ERROR: Failed to open ZIP archive for writing. Cannot serialize anything to disk.\n
Fossilize ERROR: Detected sliced file. Dropping entries from here.\n
N9Fossilize17DatabaseInterfaceE
N9Fossilize13StreamArchiveE
N9Fossilize18ConcurrentDatabaseE
FOSSILIZEDB
file://
/proc/%u/%s
10.0.3
no error
undefined error
too many files
file too large
unsupported method
unsupported encryption
unsupported feature
not a ZIP archive
unsupported multidisk archive
compression failed
unexpected decompressed size
CRC-32 check failed
allocation failed
file open failed
file create failed
file write failed
file read failed
file close failed
file seek failed
file stat failed
invalid parameter
invalid filename
buffer too small
internal error
file not found
archive is too large
validation failed
write calledback failed
unknown error
 n;^
Qkkbal
3_L\n
>jm\r
Zjz\v
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
\t\t\t\t\n\n\n\n\n\n\n\n\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r
\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r
dir=%d %d %d, err=%f\n
KMeansQuantization
CopyAttrFrom
FillAttr
srgbgammatolinear
lineartogamma
GenerateDistanceField
FilterFrom
QuarterSizeAttrWithBoxFilter
filterinY
filterinZ
FindClosestMatchingRegion
eikonal
CSOAContainer::SetAttributeType - ERROR, trying to change type of previously-defined attribute %d!\n
PARALLEL_PROCESS utlsoacontainer.cpp:2533
Normalize3ComponentVectorInAttributes
Normalized3x3SobelEdgeFilterFrom
../public/tier1/utlblockmemory.h
Push
15CMemberFunctor7IP13CSOAContainerMS0_FviiiiPKS0_iiEiiiiS3_ii12CRefCounted1I8CFunctor20CRefCountServiceBaseILb1E6CRefMTEE18CFuncMemPolicyNoneE
15CMemberFunctor6IP13CSOAContainerMS0_FviiiiiDv4_fEiiiiiS2_12CRefCounted1I8CFunctor20CRefCountServiceBaseILb1E6CRefMTEE18CFuncMemPolicyNoneE
15CMemberFunctor1IP26CParallelProcessorAbstractI18CParallelProcessorIi27CMemberFuncJobItemProcessorIi11CCallQueueTI8CTSQueueIP8CFunctorLb0EEES8_ELi1EEEMSB_FviEi12CRefCounted1IS5_20CRefCountServiceBaseILb1E6CRefMTEE18CFuncMemPolicyNoneE
fff?fff?fff?fff?
>UPDATE_STRING_TOKEN_DATABASE
+inf
 \t\n\r
\r\n"""
Newline in string literal
"""\r\n
Too many bytes for PNG signature
Potential overflow in png_zalloc()
Unknown freer parameter in png_data_freer
\nlibpng version 1.5.2 - March 31, 2011\nCopyright (c) 1998-2011 Glenn Randers-Pehrson\nCopyright (c) 1996-1997 Andreas Dilger\nCopyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n
 libpng version 1.5.2 - March 31, 2011\n\n
Image width exceeds user limit in IHDR
Image height exceeds user limit in IHDR
Width is too large for libpng to process pixels
Invalid color type/bit depth combination in IHDR
Unknown interlace method in IHDR
Unknown compression method in IHDR
MNG features are not allowed in a PNG datastream
ASCII conversion buffer too small
Ignoring attempt to set negative chromaticity value
Ignoring attempt to set cHRM RGB triangle with zero area
%d %s %d %02d:%02d:%02d +0000
Image width is zero in IHDR
Image height is zero in IHDR
Invalid image width in IHDR
Invalid image height in IHDR
Invalid bit depth in IHDR
Invalid color type in IHDR
Unknown filter method in IHDR
Invalid filter method in IHDR
Invalid IHDR data
fixed point overflow ignored
Invalid cHRM white point
Invalid cHRM red point
Invalid cHRM green point
Invalid cHRM blue point
o@libpng warning: %s
libpng error: %s
0123456789ABCDEF
\nF%u
?Out of Memory
1.2.5
zlib memory error
zlib stream error
zlib version error
Unknown zlib error
Missing IHDR before IDAT
Missing PLTE before IDAT
Decompression error
Not enough image data
Extra compressed data
Too many IDATs found
Application built with libpng-%.20s but running with %.20s
Ignoring extra png_read_update_info() call; row buffer not reallocated
Ignoring extra png_start_read_image() call; row buffer not reallocated
Invalid attempt to read row data
Interlace handling should be turned on when using png_read_image
Image is too high to process with png_read_png()
Read Error
Call to NULL read function
Can't set both read_data_fn and write_data_fn in the same structure
Can't discard critical data on CRC error
Application must supply a known background gamma
invalid error action to rgb_to_gray
ignoring out of range rgb_to_gray coefficients
NULL row buffer for row %ld, pass %d
png_do_rgb_to_gray found nongray pixel
png_do_quantize returned rowbytes=0
png_set_background
png_set_gamma file gamma
png_set_gamma screen gamma
rgb to gray green coefficient
rgb to gray red coefficient
invalid background gamma type
Buffer error in compressed datastream in %s chunk
Data error in compressed datastream in %s chunk
Incomplete compressed datastream in %s chunk
PNG unsigned integer out of range
PNG file corrupted by ASCII conversion
Exceeded size limit while expanding chunk
Not enough memory to decompress chunk
Unknown zTXt compression type %d
Ignoring PLTE chunk in grayscale PNG
Truncating incorrect tRNS chunk length
Truncating incorrect info tRNS chunk length
Ignoring gAMA chunk with out of range gamma
Ignoring incorrect gAMA value when sRGB is also present
Ignoring cHRM chunk with negative chromaticities
Ignoring incorrect cHRM value when sRGB is also present
Ignoring nonzero compression type in iCCP chunk
Profile size field missing from iCCP chunk
Ignoring iCCP chunk with declared size = %u and actual length = %u
No space in chunk cache for sPLT
sPLT chunk requires too much memory
tRNS chunk not allowed with alpha channel
Incorrect bKGD chunk index value
Invalid pCAL parameters for equation type
Unrecognized equation type for pCAL chunk
Out of memory while processing sCAL chunk
Invalid sCAL ignored: invalid unit
Invalid sCAL chunk ignored: bad width format
Invalid sCAL chunk ignored: bad height format
No space in chunk cache for tEXt
No memory to process text chunk
Not enough memory to process text chunk
Insufficient memory to process text chunk
No space in chunk cache for zTXt
Out of memory processing zTXt chunk
Unknown compression type in zTXt chunk
Not enough memory to process zTXt chunk
Insufficient memory to store zTXt chunk
No space in chunk cache for iTXt
No memory to process iTXt chunk
Not enough memory to process iTXt chunk
Insufficient memory to store iTXt chunk
No space in chunk cache for unknown chunk
Ignoring bad adaptive filter type
Row has too many bytes to allocate in memory
Not a PNG file
CRC error
invalid chunklength
png_inflate logic error
Out of place IHDR
Invalid IHDR chunk
Missing IHDR before PLTE
Invalid PLTE after IDAT
Duplicate PLTE chunk
Invalid palette chunk
No image in file
Incorrect IEND chunk length
Missing IHDR before gAMA
Invalid gAMA after IDAT
Out of place gAMA chunk
Duplicate gAMA chunk
Incorrect gAMA chunk length
gamma = (%d/100000)
Missing IHDR before sBIT
Invalid sBIT after IDAT
Out of place sBIT chunk
Duplicate sBIT chunk
Incorrect sBIT chunk length
Missing IHDR before cHRM
Invalid cHRM after IDAT
Missing PLTE before cHRM
Duplicate cHRM chunk
Incorrect cHRM chunk length
wx=%d, wy=%d, rx=%d, ry=%d\n
gx=%d, gy=%d, bx=%d, by=%d\n
Missing IHDR before sRGB
Invalid sRGB after IDAT
Out of place sRGB chunk
Duplicate sRGB chunk
Incorrect sRGB chunk length
Unknown sRGB intent
incorrect gamma=(%d/100000)\n
Missing IHDR before iCCP
Invalid iCCP after IDAT
Out of place iCCP chunk
Duplicate iCCP chunk
Malformed iCCP chunk
Missing IHDR before sPLT
Invalid sPLT after IDAT
malformed sPLT chunk
sPLT chunk has bad length
Missing IHDR before tRNS
Invalid tRNS after IDAT
Duplicate tRNS chunk
Incorrect tRNS chunk length
Missing PLTE before tRNS
Zero length tRNS chunk
Missing IHDR before bKGD
Invalid bKGD after IDAT
Missing PLTE before bKGD
Duplicate bKGD chunk
Incorrect bKGD chunk length
Missing IHDR before hIST
Invalid hIST after IDAT
Missing PLTE before hIST
Duplicate hIST chunk
Incorrect hIST chunk length
Missing IHDR before pHYs
Invalid pHYs after IDAT
Duplicate pHYs chunk
Incorrect pHYs chunk length
Missing IHDR before oFFs
Invalid oFFs after IDAT
Duplicate oFFs chunk
Incorrect oFFs chunk length
Missing IHDR before pCAL
Invalid pCAL after IDAT
Duplicate pCAL chunk
No memory for pCAL purpose
Invalid pCAL data
No memory for pCAL params
Missing IHDR before sCAL
Invalid sCAL after IDAT
Duplicate sCAL chunk
Out of place tIME chunk
Duplicate tIME chunk
Incorrect tIME chunk length
Missing IHDR before tEXt
Missing IHDR before zTXt
Truncated zTXt chunk
Missing IHDR before iTXt
Truncated iTXt chunk
Malformed iTXt chunk
unknown critical chunk
error in user chunk
invalid chunk type
Decompression Error
Extra compression data
cHRM Blue Y
cHRM Blue X
cHRM Green Y
cHRM Green X
cHRM Red Y
cHRM Red X
cHRM White Y
cHRM White X
png_set_gAMA
Invalid pCAL equation type
Invalid sCAL unit
Invalid sCAL width
Invalid sCAL height
Invalid sCAL width ignored
Invalid sCAL height ignored
Invalid palette length
No memory for sPLT palettes
Negative or zero gamma ignored
Invalid palette size, hIST allocation skipped
Insufficient memory for hIST chunk data
Invalid format for pCAL parameter
Insufficient memory for pCAL purpose
Insufficient memory for pCAL units
Insufficient memory for pCAL params
Insufficient memory for pCAL parameter
Memory allocation failed while processing sCAL
Insufficient memory to process iCCP chunk
Insufficient memory to process iCCP profile
text compression mode is out of range
Insufficient memory to store text
tRNS chunk has out-of-range samples for bit_depth
Out of memory while processing sPLT chunk
Out of memory while processing unknown chunk
Attempt to set buffer size beyond max ignored
 0@P`p
!1AQaq
"2BRbr
#3CScs
$4DTdt
%5EUeu
&6FVfv
'7GWgw
(8HXhx
)9IYiy
*:JZjz
+;K[k{
,<L\l|
-=M]m}
.>N^n~
/?O_o
Bogus message code %d
Bogus buffer control mode
Invalid crop request
DCT coefficient out of range
Bogus input colorspace
Bogus JPEG colorspace
Bogus marker length
Invalid memory pool code %d
Bogus sampling factors
Bogus virtual array access
Suspension not allowed here
Bogus DAC index %d
Bogus DAC value 0x%x
Bogus DHT index %d
Bogus DQT index %d
Read from EMS failed
Write to EMS failed
Input file read error
Empty input file
Premature end of input file
Not implemented yet
Backing store not supported
Insufficient memory (case %d)
Read failed on temporary file
Seek failed on temporary file
Read from XMS failed
Write to XMS failed
8b  16-May-2010
Define Huffman Table 0x%02x
Define Restart Interval %u
Freed EMS handle %u
Obtained EMS handle %u
End Of Image
Unexpected marker 0x%02x
Quantizing to %d colors
RST%d
Start of Image
Start Of Scan: %d components
    Component %d: dc=%d ac=%d
  Ss=%d, Se=%d, Ah=%d, Al=%d
Closed temporary file %s
Opened temporary file %s
Freed XMS handle %u
Obtained XMS handle %u
Premature end of JPEG file
ALIGN_TYPE is wrong, please fix
MAX_ALLOC_CHUNK is wrong, please fix
Invalid component ID %d in SOS
DCT scaled block size %dx%d not supported
Component index %d: mismatching sampling ratio %d:%d, %d:%d, %c
Bogus Huffman table definition
Wrong JPEG library version: library is %d, caller expects %d
Sampling factors too large for interleaved scan
Unsupported JPEG data precision %d
Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d
Invalid progressive parameters at scan script entry %d
Invalid scan script at entry %d
Improper call to JPEG library in state %d
JPEG parameter struct mismatch: library thinks size is %u, caller expects %u
Buffer passed to JPEG library is too small
CCIR601 sampling not implemented yet
Too many color components: %d, max %d
Unsupported color conversion request
Empty JPEG image (DNL not supported)
Didn't expect more than one scan
Output file write error --- out of disk space?
Fractional sampling not implemented yet
Huffman code size table overflow
Missing Huffman code table entry
Maximum supported image dimension is %u pixels
Cannot transcode due to multiple use of quantization table %d
Scan script does not transmit all data
Invalid color quantization mode change
Requested feature was omitted at compile time
Arithmetic table 0x%02x was not defined
Huffman table 0x%02x was not defined
JPEG datastream contains no image
Quantization table 0x%02x was not defined
Not a JPEG file: starts with 0x%02x 0x%02x
Cannot quantize more than %d color components
Cannot quantize to fewer than %d colors
Cannot quantize to more than %d colors
Invalid JPEG file structure: two SOF markers
Invalid JPEG file structure: missing SOS marker
Unsupported JPEG process: SOF type 0x%02x
Invalid JPEG file structure: two SOI markers
Invalid JPEG file structure: SOS before SOF
Failed to create temporary file %s
Write failed on temporary file --- out of disk space?
Application transferred too few scanlines
Unsupported marker type 0x%02x
Virtual array controller messed up
Image too wide for this implementation
Copyright (C) 2010, Thomas G. Lane, Guido Vollbeding
Caution: quantization tables are too coarse for baseline JPEG
Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d
Unknown APP0 marker (not JFIF), length %u
Unknown APP14 marker (not Adobe), length %u
Define Arithmetic Table 0x%02x: 0x%02x
Define Quantization Table %d  precision %d
        %3d %3d %3d %3d %3d %3d %3d %3d
JFIF APP0 marker: version %d.%02d, density %dx%d  %d
Warning: thumbnail image size does not match data length %u
JFIF extension marker: type 0x%02x, length %u
    with %d x %d thumbnail image
Miscellaneous marker 0x%02x, length %u
        %4u %4u %4u %4u %4u %4u %4u %4u
Quantizing to %d = %d*%d*%d colors
Selected %d colors for quantization
At marker 0x%02x, recovery action %d
Smoothing not supported with nonstandard sampling ratios
Start Of Frame 0x%02x: width=%u, height=%u, components=%d
    Component %d: %dhx%dv q=%d
JFIF extension marker: JPEG-compressed thumbnail image, length %u
JFIF extension marker: palette thumbnail image, length %u
JFIF extension marker: RGB thumbnail image, length %u
Unrecognized component IDs %d %d %d, assuming YCbCr
Unknown Adobe color transform code %d
Corrupt JPEG data: bad arithmetic code
Inconsistent progression sequence for component %d coefficient %d
Corrupt JPEG data: %u extraneous bytes before marker 0x%02x
Corrupt JPEG data: premature end of data segment
Corrupt JPEG data: bad Huffman code
Warning: unknown JFIF revision number %d.%02d
Corrupt JPEG data: found marker 0x%02x instead of RST%d
Invalid SOS parameters for sequential JPEG
Application transferred too many scanlines
JPEGMEM
%ld%c
E\v0~
sAmTb
BKbhTb~XBK!;
A!;I2
"\v0A-
?u='@
@&LH
A'\r:
QC,A
TF<)
VGy#
KNQ\r
M0@\n
a\">
c]$8
eaFO
hd=<
c]^7
if1R
kh9F
gc^A
okOP
pm"U
*ZN3Etc13EncodeMipmapsEPfjjNS_5Image6FormatENS_11ErrorMetricEfjjjjPNS_8RawImageEPibEUlPhE_
*St19_Sp_counted_deleterIPhZN3Etc13EncodeMipmapsEPfjjNS1_5Image6FormatENS1_11ErrorMetricEfjjjjPNS1_8RawImageEPibEUlS0_E_SaIiELN9__gnu_cxx12_Lock_policyE2EE
/data/source2_main/src/thirdparty/etc2comp/EtcLib/Etc/EtcImage.cpp
/data/source2_main/src/thirdparty/etc2comp/EtcLib/./EtcCodec/EtcBlock4x4Encoding.h
a_uiMultithreadingStride > 0
m_pablock
SRGB8
SRGB8A1
SRGBA8
SIGNED_R11
SIGNED_RG11
m_fError >= 0.0f
m_paucEncodingBits == nullptr
effortblocks = %d\n
pass %u\n
    %u unfinished blocks\n
Finished %d Blocks out of %d\n
    %u iterated blocks\n
float Etc::Block4x4Encoding::GetError()
void Etc::Image::SetEncodingBits(unsigned int, unsigned int)
void Etc::Image::RunFirstPass(unsigned int, unsigned int)
void Etc::Image::FindEncodingWarningTypesForCurFormat()
unsigned int Etc::Image::IterateThroughWorstBlocks(unsigned int, unsigned int, unsigned int)
Etc::Image::EncodingStatus Etc::Image::Encode(Etc::Image::Format, Etc::ErrorMetric, float, unsigned int, unsigned int)
Etc::Image::Image(Etc::Image::Format, unsigned int, unsigned int, unsigned char*, unsigned int, Etc::Image*, Etc::ErrorMetric)
Etc::Image::Image(float*, unsigned int, unsigned int, Etc::ErrorMetric)
NSt13__future_base19_Async_state_commonE
NSt13__future_base7_ResultIjEE
NSt13__future_base17_Async_state_implISt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS4_ijEEvEE
NSt13__future_base15_Deferred_stateISt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS4_ijEEvEE
NSt13__future_base17_Async_state_implISt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFjjjjEEPS4_jijEEjEE
St23_Sp_counted_ptr_inplaceINSt13__future_base17_Async_state_implISt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS5_ijEEvEESaISC_ELN9__gnu_cxx12_Lock_policyE2EE
St23_Sp_counted_ptr_inplaceINSt13__future_base15_Deferred_stateISt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS5_ijEEvEESaISC_ELN9__gnu_cxx12_Lock_policyE2EE
St23_Sp_counted_ptr_inplaceINSt13__future_base17_Async_state_implISt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFjjjjEEPS5_jijEEjEESaISC_ELN9__gnu_cxx12_Lock_policyE2EE
NSt6thread5_ImplISt12_Bind_simpleIFZNSt13__future_base17_Async_state_implIS1_IFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS6_ijEEvEC1EOSC_EUlvE_vEEEE
NSt6thread5_ImplISt12_Bind_simpleIFZNSt13__future_base17_Async_state_implIS1_IFSt7_Mem_fnIMN3Etc5ImageEFjjjjEEPS6_jijEEjEC1EOSC_EUlvE_vEEEE
NSt13__future_base12_Task_setterISt10unique_ptrINS_7_ResultIvEENS_12_Result_base8_DeleterEEvEE
NSt13__future_base12_Task_setterISt10unique_ptrINS_7_ResultIjEENS_12_Result_base8_DeleterEEjEE
St12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS2_ijEE
St12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFjjjjEEPS2_jijEE
PSt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS2_ijEE
PSt12_Bind_simpleIFSt7_Mem_fnIMN3Etc5ImageEFjjjjEEPS2_jijEE
St23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFZNSt13__future_base17_Async_state_implIS2_IFSt7_Mem_fnIMN3Etc5ImageEFvjjEEPS7_ijEEvEC1EOSD_EUlvE_vEEEESaISJ_ELN9__gnu_cxx12_Lock_policyE2EE
St23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFZNSt13__future_base17_Async_state_implIS2_IFSt7_Mem_fnIMN3Etc5ImageEFjjjjEEPS7_jijEEjEC1EOSD_EUlvE_vEEEESaISJ_ELN9__gnu_cxx12_Lock_policyE2EE
@@/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4.cpp
void Etc::Block4x4::InitFromEtcEncodingBits(Etc::Image::Format, unsigned int, unsigned int, unsigned char*, Etc::Image*, Etc::ErrorMetric)
void Etc::Block4x4::InitFromSource(Etc::Image*, unsigned int, unsigned int, unsigned char*, Etc::ErrorMetric)
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding_RG11.cpp
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding.h
fMinGrn <= fMaxGrn
!m_boolDone
virtual void Etc::Block4x4Encoding_RG11::SetEncodingBits()
void Etc::Block4x4Encoding_RG11::CalculateG11(unsigned int, float, float)
float Etc::Block4x4Encoding::GetError()
virtual void Etc::Block4x4Encoding_RG11::PerformIteration(float)
virtual void Etc::Block4x4Encoding_RG11::InitFromEncodingBits(Etc::Block4x4*, unsigned char*, Etc::ColorFloatRGBA*, Etc::ErrorMetric)
N3Etc21Block4x4Encoding_RG11E
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding_RGB8A1.cpp
ptry < &a_phalf->m_atry[DifferentialTrys::Half::MAX_TRYS]
ptry->m_fError < 3.40282346638528859812e+38F
encodingTry.m_fError < 3.40282346638528859812e+38F
iDGreen2 >= -4 && iDGreen2 < 4
!m_boolOpaque
m_uiEncodingIterations == 0
iRed >= 0 && iRed <= 31
iGreen >= 0 && iGreen <= 31
iBlue >= 0 && iBlue <= 31
ptryBest1 != nullptr
ptryBest2 != nullptr
iDRed >= -4 && iDRed < 4
iDGreen >= -4 && iDGreen < 4
iDBlue >= -4 && iDBlue < 4
!m_boolTransparent
m_boolDiff
iDRed2 >= -4 && iDRed2 < 4
iDBlue2 >= -4 && iDBlue2 < 4
m_mode == MODE_T
m_boolDiff == true
iRed2 < 0 || iRed2 > 31
m_mode == MODE_H
iRed2 >= 0 && iRed2 <= 31
iGreen2 < 0 || iGreen2 > 31
!m_boolPunchThroughPixels
virtual void Etc::Block4x4Encoding_RGB8A1_Transparent::PerformIteration(float)
virtual void Etc::Block4x4Encoding_RGB8A1_Opaque::PerformIteration(float)
void Etc::Block4x4Encoding_RGB8A1::SetEncodingBits_H()
void Etc::Block4x4Encoding_RGB8A1::SetEncodingBits_T()
void Etc::Block4x4Encoding_RGB8A1::SetEncodingBits_ETC1()
virtual void Etc::Block4x4Encoding_RGB8A1::SetEncodingBits()
void Etc::Block4x4Encoding_RGB8A1::TryDifferentialHalf(Etc::DifferentialTrys::Half*)
void Etc::Block4x4Encoding_RGB8A1::TryDifferential(bool, unsigned int, int, int)
float Etc::Block4x4Encoding::GetError()
virtual void Etc::Block4x4Encoding_RGB8A1::PerformIteration(float)
N3Etc16Block4x4EncodingE
N3Etc23Block4x4Encoding_RGB8A1E
N3Etc30Block4x4Encoding_RGB8A1_OpaqueE
N3Etc35Block4x4Encoding_RGB8A1_TransparentE
B/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcSortedBlockList.cpp
m_uiAddedBlocks < m_uiImageBlocks
m_uiAddedBlocks == m_uiImageBlocks
pbucket->plinkLast->GetNext() == nullptr
%3d: e=%.3f rms=%.6f %u\n
float Etc::Block4x4Encoding::GetError()
void Etc::SortedBlockList::Sort()
void Etc::SortedBlockList::AddBlock(Etc::Block4x4*)
</data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding_R11.cpp
fMinRed <= fMaxRed
virtual void Etc::Block4x4Encoding_R11::SetEncodingBits()
void Etc::Block4x4Encoding_R11::CalculateR11(unsigned int, float, float)
float Etc::Block4x4Encoding::GetError()
virtual void Etc::Block4x4Encoding_R11::PerformIteration(float)
virtual void Etc::Block4x4Encoding_R11::InitFromEncodingBits(Etc::Block4x4*, unsigned char*, Etc::ColorFloatRGBA*, Etc::ErrorMetric)
N3Etc20Block4x4Encoding_R11E
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding_RGB8.cpp
uiTransparentPixels < PIXELS
m_mode == MODE_PLANAR
iGreen2 >= 0 && iGreen2 <= 31
iBlue2 < 0 || iBlue2 > 31
void Etc::Block4x4Encoding_RGB8::SetEncodingBits_Planar()
void Etc::Block4x4Encoding_RGB8::SetEncodingBits_H()
void Etc::Block4x4Encoding_RGB8::SetEncodingBits_T()
virtual void Etc::Block4x4Encoding_RGB8::SetEncodingBits()
void Etc::Block4x4Encoding_RGB8::CalculateBaseColorsForTAndH()
float Etc::Block4x4Encoding::GetError()
virtual void Etc::Block4x4Encoding_RGB8::PerformIteration(float)
N3Etc21Block4x4Encoding_RGB8E
@@/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcDifferentialTrys.cpp
iRed1 >= (signed)(0 + a_uiRadius) && iRed1 <= (signed)(31 - a_uiRadius)
iRed2 >= (signed)(0 + a_uiRadius) && iRed2 <= (signed)(31 - a_uiRadius)
iGreen1 >= (signed)(0 + a_uiRadius) && iGreen1 <= (signed)(31 - a_uiRadius)
iGreen2 >= (signed)(0 + a_uiRadius) && iGreen2 <= (signed)(31 - a_uiRadius)
iBlue1 >= (signed)(0+a_uiRadius) && iBlue1 <= (signed)(31 - a_uiRadius)
iBlue2 >= (signed)(0 + a_uiRadius) && iBlue2 <= (signed)(31 - a_uiRadius)
a_uiRadius <= MAX_RADIUS
Etc::DifferentialTrys::DifferentialTrys(Etc::ColorFloatRGBA, Etc::ColorFloatRGBA, const unsigned int*, const unsigned int*, unsigned int, int, int)
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding.cpp
a_fDecodedAlpha >= 0.0f
float Etc::Block4x4Encoding::CalcPixelError(Etc::ColorFloatRGBA, float, Etc::ColorFloatRGBA)
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding_ETC1.cpp
(fWeightSumLeft + fWeightSumRight) > 0.0f
(fWeightSumTop + fWeightSumBottom) > 0.0f
ptry < &a_phalf->m_atry[IndividualTrys::Half::MAX_TRYS]
m_mode == MODE_ETC1
fWeightSumRight > 0.0f
fWeightSumLeft > 0.0f
fWeightSumBottom > 0.0f
fWeightSumTop > 0.0f
iRed >= 0 && iRed <= 15
iGreen >= 0 && iGreen <= 15
iBlue >= 0 && iBlue <= 15
virtual void Etc::Block4x4Encoding_ETC1::SetEncodingBits()
void Etc::Block4x4Encoding_ETC1::TryIndividualHalf(Etc::IndividualTrys::Half*)
void Etc::Block4x4Encoding_ETC1::TryDifferentialHalf(Etc::DifferentialTrys::Half*)
void Etc::Block4x4Encoding_ETC1::TryDifferential(bool, unsigned int, int, int)
void Etc::Block4x4Encoding_ETC1::CalculateSourceAverages()
float Etc::Block4x4Encoding::GetError()
virtual void Etc::Block4x4Encoding_ETC1::PerformIteration(float)
N3Etc21Block4x4Encoding_ETC1E
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcBlock4x4Encoding_RGBA8.cpp
fMinAlpha <= fMaxAlpha
virtual void Etc::Block4x4Encoding_RGBA8_Transparent::PerformIteration(float)
virtual void Etc::Block4x4Encoding_RGBA8_Opaque::PerformIteration(float)
void Etc::Block4x4Encoding_RGBA8::CalculateA8(float)
virtual void Etc::Block4x4Encoding_RGBA8::PerformIteration(float)
N3Etc22Block4x4Encoding_RGBA8E
N3Etc29Block4x4Encoding_RGBA8_OpaqueE
N3Etc34Block4x4Encoding_RGBA8_TransparentE
/data/source2_main/src/thirdparty/etc2comp/EtcLib/EtcCodec/EtcIndividualTrys.cpp
Etc::IndividualTrys::IndividualTrys(Etc::ColorFloatRGBA, Etc::ColorFloatRGBA, const unsigned int*, const unsigned int*, unsigned int)
count=
, total size (bytes)=
, bytes per element=
>jm\r
MGiI
_~6\f
=G\\v
LMb#
q\n>(
+OQv
ZEo^
i8P/
?(3w
*0"Z
l!;b
:1X:
y9*O
\rmj>
IiGM
\f6~_
\v\G=
#bML
(>\nq
vQO+
^oEZ
/P8i
w3(?
Z"0*
b;!l
:X1:
O*9y
incorrect header check
unknown compression method
invalid window size
unknown header flags set
header crc mismatch
invalid block type
invalid stored block lengths
invalid code lengths set
invalid bit length repeat
invalid literal/lengths set
invalid distances set
invalid literal/length code
invalid distance code
invalid distance too far back
incorrect data check
incorrect length check
too many length or distance symbols
invalid code -- missing end-of-block
texcoord
texcoord
texcoord
texcoord
texcoord
texcoord
texcoord
texcoord
position
color
texcoord
position
color
\f   
    
GCC: (SteamRT 5.4.0-7.really.6+steamrt1.2+srt1) 5.4.1 20160803
GCC: (SteamRT 5.4.0-7.really.6+steamrt1.1+srt2) 5.4.1 20160803
GCC: (crosstool-NG 1.17.0) 4.6.3
GCC: (Ubuntu 4.8.4-1ubuntu15~12.04+steamrt1+srt2) 4.8.4
